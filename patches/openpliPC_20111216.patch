diff -Naur enigma2.ori/configure.ac enigma2/configure.ac
--- enigma2.ori/configure.ac	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/configure.ac	2011-12-16 06:15:29.000000000 +0100
@@ -113,6 +113,16 @@
 fi
 AM_CONDITIONAL(HAVE_LIBXINE, test "$with_libxine" = "yes")
 
+AC_ARG_WITH(xlib,
+	AS_HELP_STRING([--with-xlib],[use xlib, yes or no]),
+	[with_xlib=$withval],[with_xlib=no])
+if test "$with_xlib" = "yes"; then
+	PKG_CHECK_MODULES(LIBXINE, libxine)
+	PKG_CHECK_MODULES(X11, x11)
+	AC_DEFINE([WITH_XLIB],[1],[Define to 1 if you want to use xlib])
+fi
+AM_CONDITIONAL(HAVE_XLIB, test "$with_xlib" = "yes")
+
 AC_ARG_WITH(debug,
 	AS_HELP_STRING([--without-debug],[disable debugging code]),
 	[with_debug="$withval"],[with_debug="yes"])
@@ -222,8 +232,6 @@
 lib/python/Plugins/SystemPlugins/CleanupWizard/meta/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/meta/Makefile
-lib/python/Plugins/SystemPlugins/CrashlogAutoSubmit/Makefile
-lib/python/Plugins/SystemPlugins/CrashlogAutoSubmit/meta/Makefile
 lib/python/Plugins/SystemPlugins/DefaultServicesScanner/Makefile
 lib/python/Plugins/SystemPlugins/DefaultServicesScanner/meta/Makefile
 lib/python/Plugins/SystemPlugins/DiseqcTester/Makefile
diff -Naur enigma2.ori/data/Makefile.am enigma2/data/Makefile.am
--- enigma2.ori/data/Makefile.am	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/data/Makefile.am	2011-12-16 06:15:29.000000000 +0100
@@ -19,7 +19,8 @@
 	tutorialwizard.xml \
 	freesat.t1 \
 	freesat.t2 \
-	unicable.xml
+	unicable.xml \
+	xine.conf
 
 if HAVE_TEXTLCD
 dist_pkgdata_DATA += skin_text.xml
diff -Naur enigma2.ori/data/keymap.xml enigma2/data/keymap.xml
--- enigma2.ori/data/keymap.xml	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/data/keymap.xml	2011-12-16 06:15:29.000000000 +0100
@@ -88,6 +88,9 @@
 		<device name="dreambox remote control (native)">
 			<key id="KEY_RED" mapto="instantRecord" flags="b" />
 		</device>
+		<device name="Xlib">
+			<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
+		</device>
 	</map>
 
 	<map context="InfobarExtensions">
@@ -195,6 +198,9 @@
 		<device name="dreambox advanced remote control (native)">
 			<key id="KEY_YELLOW" mapto="audioSelection" flags="b" />
 		</device>
+		<device name="Xlib">
+			<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
+		</device>
 	</map>
 
 	<map context="InfobarSubtitleSelectionActions">
@@ -291,7 +297,14 @@
 		<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
 		<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
 		<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
-
+		<device name="Xlib">
+			<key id="KEY_PAUSE" mapto="pauseService" flags="m" />
+			<key id="KEY_PLAYPAUSE" mapto="playpauseService" flags="m" />
+			<key id="KEY_REWIND" mapto="seekBack" flags="b" />
+			<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
+			<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
+			<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
+		</device>
 		<key id="KEY_LEFT" mapto="seekBack" flags="m" />
 		<key id="KEY_RIGHT" mapto="seekFwd" flags="m" />
 
@@ -302,6 +315,8 @@
 		<key id="KEY_4" mapto="seekdef:4" flags="m" />
 		<key id="KEY_6" mapto="seekdef:6" flags="m" />
 		<key id="KEY_7" mapto="seekdef:7" flags="m" />
+		<key id="KEY_8" mapto="seekFwd" flags="b" />
+		<key id="KEY_0" mapto="seekBack" flags="b" />
 		<key id="KEY_9" mapto="seekdef:9" flags="m" />
 	</map>
 
@@ -328,6 +343,8 @@
 		<key id="KEY_4" mapto="seekdef:4" flags="m" />
 		<key id="KEY_6" mapto="seekdef:6" flags="m" />
 		<key id="KEY_7" mapto="seekdef:7" flags="m" />
+		<key id="KEY_8" mapto="seekFwd" flags="b" />
+		<key id="KEY_0" mapto="seekBack" flags="b" />
 		<key id="KEY_9" mapto="seekdef:9" flags="m" />
 	</map>
 
@@ -372,6 +389,13 @@
 	</map>
 
 	<map context="MoviePlayerActions">
+		<device name="dreambox ir keyboard">
+			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
+		</device>
+		<device name="Xlib">
+			<key id="KEY_TV" mapto="leavePlayer" flags="m" />
+			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
+		</device>
 		<key id="KEY_TV" mapto="leavePlayer" flags="m" />
 		<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
 	</map>
@@ -392,6 +416,11 @@
 			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
 			<key id="KEY_NEXTSONG" mapto="jumpNextMark" flags="m" />
 		</device>
+		<device name="Xlib">
+			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="b" />
+			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
+			<key id="KEY_PLAYPAUSE" mapto="timeshiftStart" flags="m" />
+		</device>
 	</map>
 	
 	<map context="MediaPlayerCueSheetActions">
@@ -404,6 +433,9 @@
 		<device name="dreambox ir keyboard">
 			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
 		</device>
+		<device name="Xlib">
+			<key id="KEY_PLAYPAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
+		</device>
 	</map>
 
 	<map context="VirtualKeyboardActions">
@@ -619,6 +651,14 @@
 			<key id="KEY_PREVIOUSSONG" mapto="previous" flags="m" />
 			<key id="KEY_NEXTSONG" mapto="next" flags="m" />
 		</device>
+		<device name="Xlib">
+			<key id="KEY_YELLOW" mapto="pause" flags="b" />
+			<key id="KEY_GREEN" mapto="play" flags="m" />
+			<key id="KEY_RED" mapto="previous" flags="m" />
+			<key id="KEY_BLUE" mapto="next" flags="m" />
+			<key id="KEY_2" mapto="pause" flags="b" />
+			<key id="KEY_5" mapto="play" flags="b" />
+		</device>
 		<key id="KEY_PLAYPAUSE" mapto="pause" flags="m" />
 		<key id="KEY_PAUSE" mapto="pause" flags="m" />
 		<key id="KEY_PLAY" mapto="play" flags="m" />
@@ -626,7 +666,6 @@
 		<key id="KEY_STOP" mapto="shift_stop" flags="l" />
 		<key id="KEY_TV" mapto="stop" flags="b" />
 		<key id="KEY_TV" mapto="shift_stop" flags="l" />
-
 		<key id="KEY_MENU" mapto="menu" flags="m" />
 		<key id="KEY_SPACE" mapto="menu" flags="m" />
 
diff -Naur enigma2.ori/data/setup.xml enigma2/data/setup.xml
--- enigma2.ori/data/setup.xml	2011-12-14 17:20:11.000000000 +0100
+++ enigma2/data/setup.xml	2011-12-16 06:15:29.000000000 +0100
@@ -158,4 +158,13 @@
 			<item text="Use power measurement" >config.sat.diseqcc</item>
 			<!--<item text="DiSEqC D">config.sat.diseqcd</item>-->
 		</setup>
+		<setup key="pc" title="PC settings">
+			<item level="0" text="Fullscreen default">config.pc.default_fullscreen</item>
+ 			<item level="1" text="Zoom enable">config.pc.zoom_enable</item>
+ 			<item level="2" text="Zoom aspect 4:3 of X (%)">config.pc.image4_3_zoom_x</item>
+ 			<item level="2" text="Zoom aspect 4:3 of Y (%)">config.pc.image4_3_zoom_y</item>
+ 			<item level="2" text="Zoom aspect 16:9 of X (%)">config.pc.image16_9_zoom_x</item>
+ 			<item level="2" text="Zoom aspect 16:9 of Y (%)">config.pc.image16_9_zoom_y</item>
+		</setup>
+
 </setupxml>
diff -Naur enigma2.ori/data/xine.conf enigma2/data/xine.conf
--- enigma2.ori/data/xine.conf	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/data/xine.conf	2011-12-16 03:04:14.000000000 +0100
@@ -0,0 +1,364 @@
+#
+# xine config file
+#
+.version:2
+
+# wybór sterownika dźwięku
+# { auto  null  pulseaudio  alsa  oss  esd  none  file }, default: 0
+audio.driver:alsa
+
+# device used for pulseaudio
+# string, default: 
+#audio.pulseaudio_device:
+
+# use A/52 dynamic range compression
+# bool, default: 0
+#audio.a52.dynamic_range:0
+
+# downmix audio to 2 channel surround stereo
+# bool, default: 0
+#audio.a52.surround_downmix:0
+
+# A/52 volume
+# [0..200], default: 100
+#audio.a52.level:100
+
+# offset for digital passthrough
+# numeric, default: 0
+#audio.synchronization.passthrough_offset:0
+
+# play audio even on slow/fast speeds
+# bool, default: 0
+#audio.synchronization.slow_fast_audio:0
+
+# method to sync audio and video
+# { metronom feedback  resample }, default: 0
+#audio.synchronization.av_sync_method:metronom feedback
+
+# always resample to this rate (0 to disable)
+# numeric, default: 0
+#audio.synchronization.force_rate:0
+
+# enable resampling
+# { auto  off  on }, default: 0
+#audio.synchronization.resample_mode:auto
+
+# startup audio volume
+# [0..100], default: 50
+#audio.volume.mixer_volume:50
+
+# przywracanie głośności przy starcie
+# bool, default: 0
+#audio.volume.remember_volume:0
+
+# wybór sterownika wideo
+# { auto  vdpau  aadxr3  dxr3  opengl  raw  caca  xshm  aa  none  sdl  vidixfb  vidix  fb }, default: 0
+video.driver:auto
+
+video.device.xv_sync_to_vblank:1
+
+# disable all video scaling
+# bool, default: 0
+#video.output.disable_scaling:0
+
+# horizontal image position in the output window
+# [0..100], default: 50
+#video.output.horizontal_position:50
+
+# vdpau: color of none video area in output window
+# numeric, default: 0
+#video.output.vdpau_background_color:0
+
+# vdpau: Try to recreate progressive frames from pulldown material
+# bool, default: 1
+#video.output.vdpau_enable_inverse_telecine:1
+
+# vdpau: HD deinterlace method
+# { bob  half temporal  half temporal_spatial  temporal  temporal_spatial }, default: 3
+video.output.vdpau_hd_deinterlace_method:temporal
+
+# vdpau: disable deinterlacing when progressive_frame flag is set
+# bool, default: 0
+#video.output.vdpau_honor_progressive:0
+
+# vdpau: SD deinterlace method
+# { bob  half temporal  half temporal_spatial  temporal  temporal_spatial }, default: 3
+video.output.vdpau_sd_deinterlace_method:temporal_spatial
+
+# vdpau: restrict enabling video properties for SD video only
+# { none  noise  sharpness  noise+sharpness }, default: 0
+#video.output.vdpau_sd_only_properties:none
+
+# vdpau: disable advanced deinterlacers chroma filter
+# bool, default: 0
+#video.output.vdpau_skip_chroma_deinterlace:0
+
+# vdpau: disable studio level
+# bool, default: 0
+video.output.vdpau_studio_levels:1
+
+# vertical image position in the output window
+# [0..100], default: 50
+#video.output.vertical_position:50
+
+# default length of display queue
+# numeric, default: 3
+#video.output.vdpau_display_queue_length:3
+
+video.output.vdpau_deinterlace_method:temporal
+
+video.output.vdpau_scaling_quality:1
+
+# Choose speed over specification compliance
+# bool, default: 0
+#video.processing.ffmpeg_choose_speed_over_accuracy:0
+
+# MPEG-4 postprocessing quality
+# [0..6], default: 3
+#video.processing.ffmpeg_pp_quality:3
+
+# Skip loop filter
+# { default  none  nonref  bidir  nonkey  all }, default: 0
+#video.processing.ffmpeg_skip_loop_filter:default
+
+# FFmpeg video decoding thread count
+# numeric, default: 1
+#video.processing.ffmpeg_thread_count:1
+
+# path to RealPlayer codecs
+# string, default: 
+#decoder.external.real_codecs_path:
+
+# path to Win32 codecs
+# string, default: /usr/lib/codecs
+#decoder.external.win32_codecs_path:/usr/lib/codecs
+
+# frames per second to generate
+# numeric, default: 14
+#effects.goom.fps:14
+
+# goom image height
+# numeric, default: 240
+#effects.goom.height:240
+
+# goom image width
+# numeric, default: 320
+#effects.goom.width:320
+
+# colour space conversion method
+# { Fast but not photorealistic  Slow but looks better }, default: 0
+#effects.goom.csc_method:Fast but not photorealistic
+
+# number of audio buffers
+# numeric, default: 230
+audio.synchronization.slow_fast_audio:1
+engine.buffers.audio_num_buffers:230
+
+# number of video buffers
+# numeric, default: 500
+engine.buffers.video_num_buffers:1800
+
+# default number of video frames
+# numeric, default: 15
+engine.buffers.video_num_frames:22
+
+# disable decoder flush at discontinuity
+# bool, default: 0
+#engine.decoder.disable_flush_at_discontinuity:0
+
+# disable decoder flush from video out
+# bool, default: 0
+#engine.decoder.disable_flush_from_video_out:0
+
+# priority for a/52 decoder
+# numeric, default: 0
+#engine.decoder_priorities.a/52:0
+
+# priority for bitplane decoder
+# numeric, default: 0
+#engine.decoder_priorities.bitplane:0
+
+# priority for dts decoder
+# numeric, default: 0
+#engine.decoder_priorities.dts:0
+
+# priority for dvaudio decoder
+# numeric, default: 0
+#engine.decoder_priorities.dvaudio:0
+
+# priority for dxr3-mpeg2 decoder
+# numeric, default: 0
+#engine.decoder_priorities.dxr3-mpeg2:0
+
+# priority for dxr3-spudec decoder
+# numeric, default: 0
+#engine.decoder_priorities.dxr3-spudec:0
+
+# priority for faad decoder
+# numeric, default: 0
+#engine.decoder_priorities.faad:0
+
+# priority for ffmpeg-wmv8 decoder
+# numeric, default: 0
+#engine.decoder_priorities.ffmpeg-wmv8:0
+
+# priority for ffmpeg-wmv9 decoder
+# numeric, default: 0
+#engine.decoder_priorities.ffmpeg-wmv9:0
+
+# priority for ffmpegaudio decoder
+# numeric, default: 0
+#engine.decoder_priorities.ffmpegaudio:0
+
+# priority for ffmpegvideo decoder
+# numeric, default: 0
+#engine.decoder_priorities.ffmpegvideo:0
+
+# priority for gdkpixbuf decoder
+# numeric, default: 0
+#engine.decoder_priorities.gdkpixbuf:0
+
+# priority for gsm610 decoder
+# numeric, default: 0
+#engine.decoder_priorities.gsm610:0
+
+# priority for mad decoder
+# numeric, default: 0
+#engine.decoder_priorities.mad:0
+
+# priority for mpeg2 decoder
+# numeric, default: 0
+#engine.decoder_priorities.mpeg2:0
+
+# priority for nsfdec decoder
+# numeric, default: 0
+#engine.decoder_priorities.nsfdec:0
+
+# priority for pcm decoder
+# numeric, default: 0
+#engine.decoder_priorities.pcm:0
+
+# priority for qta decoder
+# numeric, default: 0
+#engine.decoder_priorities.qta:0
+
+# priority for qtv decoder
+# numeric, default: 0
+#engine.decoder_priorities.qtv:0
+
+# priority for realadec decoder
+# numeric, default: 0
+#engine.decoder_priorities.realadec:0
+
+# priority for realvdec decoder
+# numeric, default: 0
+#engine.decoder_priorities.realvdec:0
+
+# priority for rgb decoder
+# numeric, default: 0
+#engine.decoder_priorities.rgb:0
+
+# priority for spucc decoder
+# numeric, default: 0
+#engine.decoder_priorities.spucc:0
+
+# priority for spucmml decoder
+# numeric, default: 0
+#engine.decoder_priorities.spucmml:0
+
+# priority for spudec decoder
+# numeric, default: 0
+#engine.decoder_priorities.spudec:0
+
+# priority for spudvb decoder
+# numeric, default: 0
+#engine.decoder_priorities.spudvb:0
+
+# priority for spuhdmv decoder
+# numeric, default: 0
+#engine.decoder_priorities.spuhdmv:0
+
+# priority for sputext decoder
+# numeric, default: 0
+#engine.decoder_priorities.sputext:0
+
+# priority for vdpau_h264 decoder
+# numeric, default: 0
+#engine.decoder_priorities.vdpau_h264:0
+
+# priority for vdpau_mpeg12 decoder
+# numeric, default: 0
+#engine.decoder_priorities.vdpau_mpeg12:0
+
+# priority for vdpau_mpeg4 decoder
+# numeric, default: 0
+#engine.decoder_priorities.vdpau_mpeg4:0
+
+# priority for vdpau_vc1 decoder
+# numeric, default: 0
+#engine.decoder_priorities.vdpau_vc1:0
+
+# priority for win32a decoder
+# numeric, default: 0
+#engine.decoder_priorities.win32a:0
+
+# priority for win32v decoder
+# numeric, default: 0
+#engine.decoder_priorities.win32v:0
+
+# priority for yuv decoder
+# numeric, default: 0
+#engine.decoder_priorities.yuv:0
+
+# media format detection strategy
+# { default  reverse  content  extension }, default: 0
+#engine.demux.strategy:default
+
+# memcopy method used by xine
+# { probe  libc  kernel  mmx  mmxext  sse }, default: 0
+engine.performance.memcpy_method:sse
+
+# percentage of discarded frames to tolerate
+# numeric, default: 10
+#engine.performance.warn_discarded_threshold:10
+
+# percentage of skipped frames to tolerate
+# numeric, default: 10
+#engine.performance.warn_skipped_threshold:10
+
+# allow implicit changes to the configuration (e.g. by MRL)
+# bool, default: 0
+#misc.implicit_config:0
+
+################################################################
+################################################################
+################# SUBTITLE SETTING #############################
+################################################################
+
+# opacity for the black parts of bitmapped subtitles
+# [0..100], default: 67
+#subtitles.bitmap.black_opacity:67
+
+# opacity for the colour parts of bitmapped subtitles
+# [0..100], default: 100
+#subtitles.bitmap.colour_opacity:100
+
+# altyazı büyüklüğü
+# { tiny  small  normal  large  very large  huge }, default: 1
+subtitles.separate.subtitle_size:large
+
+# altyazı dikey konumu
+# numeric, default: 0
+#subtitles.separate.vertical_offset:0
+
+# altyazılar için yazı tipi
+# string, default: sans
+subtitles.separate.font:sans
+
+# alt yazılar kodlanıyor
+# string, default: iso-8859-1
+subtitles.separate.src_encoding:iso-8859-1
+
+# eğer mümkünse hesaplanmamış OSD kullanın
+# bool, default: 1
+subtitles.separate.use_unscaled_osd:1
diff -Naur enigma2.ori/dvbsoftwareca/Makefile enigma2/dvbsoftwareca/Makefile
--- enigma2.ori/dvbsoftwareca/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/dvbsoftwareca/Makefile	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,16 @@
+obj-m := dvbsoftwareca.o
+dvbsoftwareca-objs := dvb_softwareca.o ca_netlink.o
+KDIR := /lib/modules/$(shell uname -r)/build
+PWD := $(shell pwd)
+
+default:
+	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
+clean:
+	rm -f Module.symvers
+	rm -f *.o
+	rm -f *.ko
+	rm -f *.mod.c
+	rm -f .*.o.cmd
+	rm -f .*.ko.cmd
+	rm -f modules.order
+	rm -Rf .tmp_versions
diff -Naur enigma2.ori/dvbsoftwareca/ca_netlink.c enigma2/dvbsoftwareca/ca_netlink.c
--- enigma2.ori/dvbsoftwareca/ca_netlink.c	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/dvbsoftwareca/ca_netlink.c	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,166 @@
+/*
+ * ca_netlink.c: Generic netlink communication
+ *
+ * See the main source file 'dvb_softwareca.c' for copyright information.
+ *
+ */
+
+#include <linux/kernel.h>
+#include "ca_netlink.h"
+
+// attribute policy 
+struct nla_policy ca_policy[ATTR_MAX + 1] = {
+	[ATTR_CA_SIZE] = { .type = NLA_U32 },
+};
+
+struct genl_family ca_family = {
+	.id = GENL_ID_GENERATE,
+	.hdrsize = 0,
+	.name = "CA_SEND",
+	.version = 1,
+	.maxattr = ATTR_MAX,
+};
+
+// commands: mapping between the command enumeration and the actual function
+struct genl_ops ask_ca_size_ops = {
+	.cmd = CMD_ASK_CA_SIZE,
+	.flags = 0,
+	.policy = ca_policy,
+	.doit = reply_ca,
+	.dumpit = NULL,
+};
+
+int processPid = 0;
+
+int reply_ca(struct sk_buff *skb_2, struct genl_info *info)
+{
+        struct sk_buff *skb;
+	void *msg_head;
+	int ret;
+	
+	printk("reply_ca %d\n", info->snd_pid);
+
+        if (!info)
+                goto out;
+  
+        skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		goto out;
+
+       	msg_head = genlmsg_put(skb, 0, info->snd_seq, &ca_family, 0, CMD_ASK_CA_SIZE);
+	if (!msg_head) {
+		goto out;
+	}
+
+	ret = nla_put_u32(skb, ATTR_CA_SIZE, devices_counter);
+	if (ret)
+		goto out;
+	
+	genlmsg_end(skb, msg_head);
+
+	ret = genlmsg_unicast(&init_net, skb, info->snd_pid );
+	if (ret)
+		goto out;
+
+	processPid = info->snd_pid;
+	return 0;
+
+ out:
+        printk("dvbsoftwareca: reply_ca error\n");
+	return 0;
+}
+
+int netlink_send_cw(unsigned char ca_num, ca_descr_t *ca_descr) {
+        struct sk_buff *skb;
+	void *msg_head;
+	int ret;
+
+        skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		goto out;
+
+       	msg_head = genlmsg_put(skb, 0, 0, &ca_family, 0, CMD_SET_CW);
+	if (!msg_head) {
+		goto out;
+	}
+
+	ret = nla_put_u16(skb, ATTR_CA_NUM, ca_num);
+	if (ret)
+		goto out;
+	ret = nla_put(skb, ATTR_CA_DESCR, sizeof(ca_descr_t), ca_descr);
+	if (ret)
+		goto out;
+
+	genlmsg_end(skb, msg_head);
+
+	ret = genlmsg_unicast(&init_net, skb, processPid );
+	if (ret)
+		goto out;
+
+	return 0;
+
+ out:
+        printk("dvbsoftwareca: send_cw error\n");
+	return 0;
+}
+
+int netlink_send_pid(unsigned char ca_num, ca_pid_t *ca_pid) {
+        struct sk_buff *skb;
+	void *msg_head;
+	int ret;
+
+        skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		goto out;
+
+       	msg_head = genlmsg_put(skb, 0, 0, &ca_family, 0, CMD_SET_CW);
+	if (!msg_head) {
+		goto out;
+	}
+
+	ret = nla_put_u16(skb, ATTR_CA_NUM, ca_num);
+	if (ret)
+		goto out;
+	ret = nla_put(skb, ATTR_CA_PID, sizeof(ca_pid_t), ca_pid);
+	if (ret)
+		goto out;
+
+	genlmsg_end(skb, msg_head);
+
+	ret = genlmsg_unicast(&init_net, skb, processPid );
+	if (ret)
+		goto out;
+
+	return 0;
+
+ out:
+        printk("dvbsoftwareca: send_pid error\n");
+	return 0;
+}
+
+int register_netlink(void) {
+	int ret;
+
+	// register new family
+	ret = genl_register_family(&ca_family);
+	if (ret) {
+		printk("dvbsoftwareca: genl_register_family error\n");
+		return ret;
+	}
+	// register functions (commands) of the new family
+	ret = genl_register_ops(&ca_family, &ask_ca_size_ops);
+	if (ret) {
+		genl_unregister_family(&ca_family);
+		printk("dvbsoftwareca: genl_register_family error\n");
+	}
+
+	return ret;
+}
+
+void unregister_netlink(void) {
+        // unregister the functions
+	genl_unregister_ops(&ca_family, &ask_ca_size_ops);
+        // unregister the family
+	genl_unregister_family(&ca_family);
+}
+
diff -Naur enigma2.ori/dvbsoftwareca/ca_netlink.h enigma2/dvbsoftwareca/ca_netlink.h
--- enigma2.ori/dvbsoftwareca/ca_netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/dvbsoftwareca/ca_netlink.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,39 @@
+#ifndef __CA_NETLINK_H
+#define __CA_NETLINK_H
+
+#include <linux/dvb/ca.h>
+#include <linux/netlink.h>
+#include <net/genetlink.h>
+
+int reply_ca(struct sk_buff *skb_2, struct genl_info *info);
+int netlink_send_cw(unsigned char ca_num, ca_descr_t *ca_descr);
+int netlink_send_pid(unsigned char ca_num, ca_pid_t *ca_pid);
+int register_netlink(void);
+void unregister_netlink(void);
+
+// attributes
+enum {
+	ATTR_UNSPEC,
+	ATTR_CA_SIZE,
+	ATTR_CA_NUM,
+	ATTR_CA_DESCR,
+	ATTR_CA_PID,
+        __ATTR_MAX,
+};
+#define ATTR_MAX (__ATTR_MAX - 1)
+
+// commands
+enum {
+	CMD_UNSPEC,
+	CMD_ASK_CA_SIZE,
+	CMD_SET_CW,
+	CMD_SET_PID,
+	CMD_MAX,
+};
+
+extern struct nla_policy ca_policy[ATTR_MAX + 1];
+extern struct genl_family ca_family;
+extern struct genl_ops ask_ca_size_ops;
+extern int devices_counter;
+
+#endif
diff -Naur enigma2.ori/dvbsoftwareca/dvb_softwareca.c enigma2/dvbsoftwareca/dvb_softwareca.c
--- enigma2.ori/dvbsoftwareca/dvb_softwareca.c	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/dvbsoftwareca/dvb_softwareca.c	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,318 @@
+/*
+ * dvb_softwareca.c
+ *
+ * DVBSoftwareCA Kernel Module - Copyright cougar 2011
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ *
+ *
+ * This code is based on the DVBLoopback driver - Alan Nisota 2006
+ *
+ */
+
+#define DVBSOFTWARECA_VERSION "0.0.1"
+#define DVBSOFTWARECA_MAJOR 236
+
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/dvb/ca.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+
+#include "../drivers/media/dvb/dvb-core/dvbdev.h"
+#include "dvb_softwareca.h"
+#include "ca_netlink.h"
+
+static struct platform_device *dvblb_basedev;
+static struct ca_device* ca_devices[MAX_CA_DEVICES];
+int devices_counter = 0;
+static struct class *dvb_class;
+static struct cdev ca_devices_cdev;
+
+struct ca_device* find_device(int minor) {
+	int i;
+
+	for(i = 0; i < devices_counter; i++)
+		if(ca_devices[i]->minor == minor)
+			return ca_devices[i];
+	return NULL;
+}
+
+static int ca_open(struct inode *inode, struct file *file)
+{
+	struct ca_device *cadev = find_device(iminor(inode));
+
+	if (!cadev)
+		return -ENODEV;
+	if (!cadev->users)
+		return -EBUSY;
+
+	dprintk("ca_open adapter%d - ca%d\n", cadev->adapter_num, cadev->device_num);
+
+	cadev->users--;
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int ca_release(struct inode *inode, struct file *f)
+{
+	struct ca_device *cadev = find_device(iminor(inode));
+
+	if (!cadev) {
+		printk("Failed to locate device\n");
+		return -EFAULT;
+	}
+
+	dprintk("ca_release adapter%d - ca%d\n", cadev->adapter_num, cadev->device_num);
+
+	cadev->users++;
+
+	/*f->private_data = dvbdev;
+	ret = dvb_generic_release(inode, f);
+	if (ret < 0) {
+		goto out;
+	}*/
+
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+#ifdef HAVE_UNLOCKED_IOCTL
+static long ca_ioctl(struct file *f,
+#else
+static int ca_ioctl(struct inode *inode, struct file *f,
+#endif
+	unsigned int cmd, unsigned long arg)
+{
+#ifdef HAVE_UNLOCKED_IOCTL
+	struct inode *inode = f->f_dentry->d_inode;
+#endif
+	struct ca_device *cadev = find_device(iminor(inode));
+
+	if (!cadev) {
+		printk("Failed to locate device\n");
+		return -EFAULT;
+	}
+	
+	dprintk("ca_ioctl adapter%d - ca%d cmd:%x\n", cadev->adapter_num,
+			cadev->device_num, cmd);
+
+	if (cmd == CA_SET_DESCR) {
+		ca_descr_t *ca_descr = (ca_descr_t *)arg;
+		int ca_num = ((cadev->adapter_num&0xFF)<<8)|(cadev->device_num&0xFF);
+
+		printk("cactl CA_SET_DESCR par %d idx %d %02X...%02X\n",
+				ca_descr->parity, ca_descr->index, ca_descr->cw[0], ca_descr->cw[7]);
+
+		netlink_send_cw(ca_num, ca_descr);
+		return 0;
+	}
+	if (cmd == CA_SET_PID) {
+		ca_pid_t *ca_pid = (ca_pid_t *)arg;
+		int ca_num = ((cadev->adapter_num&0xFF)<<8)|(cadev->device_num&0xFF);
+
+		printk("cactl CA_SET_PID %04X index %d\n", ca_pid->pid, ca_pid->index);
+
+		netlink_send_pid(ca_num, ca_pid);
+		return 0;
+	}
+
+	return -EFAULT;
+}
+
+static struct file_operations ca_device_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ca_open,
+	.release	= ca_release,
+#ifdef HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = ca_ioctl,
+#else
+	.ioctl		= ca_ioctl,
+#endif
+};
+
+static void destroy_ca_device(struct ca_device *cadev)
+{
+	if (!cadev)
+                return;
+        device_destroy(dvb_class, MKDEV(DVBSOFTWARECA_MAJOR, cadev->minor));
+        kfree (cadev);
+}
+
+static int create_ca_device(int adapter_num, int device_num, int global_num)
+{
+	struct ca_device *cadev;
+        struct device *clsdev;
+        int minor = nums2minor(adapter_num, device_num);
+
+        cadev = kmalloc(sizeof(struct ca_device), GFP_KERNEL);
+        if (!cadev){
+                return -ENOMEM;
+        }
+
+	cadev->adapter_num = adapter_num;
+	cadev->device_num = device_num;
+        cadev->minor = minor;
+	cadev->users = 1;
+	ca_devices[global_num] = cadev;
+
+	clsdev = device_create(dvb_class, NULL,
+			MKDEV(DVBSOFTWARECA_MAJOR, minor),
+			cadev, "dvb%d.ca%d", adapter_num, device_num);
+        if (IS_ERR(clsdev)) {
+                printk(KERN_ERR "dvbsoftwareca: failed to create device dvb%d.ca%d (%ld)\n",
+                      adapter_num, device_num, PTR_ERR(clsdev));
+                return PTR_ERR(clsdev);
+        }
+        printk(KERN_DEBUG "dvbsoftwareca: register adapter%d/ca%d @ minor: %04X\n",
+                adapter_num, device_num, minor);
+
+        return 0;
+}
+
+static int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct ca_device *cadev = dev_get_drvdata(dev);
+
+	add_uevent_var(env, "DVB_DEVICE_NUM=%d", cadev->device_num);
+	add_uevent_var(env, "DVB_ADAPTER_NUM=%d", cadev->adapter_num);
+	return 0;
+}
+
+static char *dvb_devnode(struct device *dev, mode_t *mode)
+{
+	struct ca_device *cadev = dev_get_drvdata(dev);
+
+	return kasprintf(GFP_KERNEL, "dvb/adapter%d/ca%d",
+		cadev->adapter_num, cadev->device_num);
+}
+
+static int __init dvblb_init(void)
+{
+	int i, j, ret, failed;
+	dev_t dev = MKDEV(DVBSOFTWARECA_MAJOR, 0);
+	char device_name[50];
+
+	failed=0;
+
+	if ((ret = register_chrdev_region(dev, MAX_CA_DEVICES, "DVBSOFTWARECSA")) != 0) {
+		printk(KERN_ERR "dvbsoftwareca: unable to get major %d\n", DVBSOFTWARECA_MAJOR);
+		return ret;
+	}
+
+	cdev_init(&ca_devices_cdev, &ca_device_fops);
+
+	if ((ret = cdev_add(&ca_devices_cdev, dev, MAX_CA_DEVICES)) != 0) {
+		printk(KERN_ERR "dvbsoftwareca: unable register character device\n");
+		return ret;
+	}
+
+ 	dvb_class = class_create(THIS_MODULE, "dvbsoftwareca");
+	if (IS_ERR(dvb_class)) {
+		printk("dvbsoftwareca: unable to create dvb_class\n");
+		return PTR_ERR(dvb_class);
+	}
+	dvb_class->dev_uevent = dvb_uevent;
+	dvb_class->devnode = dvb_devnode;
+
+	info("frontend loopback driver v"DVBSOFTWARECA_VERSION);
+	printk("dvbsoftwareca: registering adapters\n");
+
+	dvblb_basedev = platform_device_alloc("dvbsoftwareca", -1);
+	if (!dvblb_basedev) {
+		return -ENOMEM;
+	}
+	ret = platform_device_add(dvblb_basedev);
+	if (ret) {
+		platform_device_put(dvblb_basedev);
+		return ret;
+	}
+
+	ret = register_netlink();
+	if (ret) {
+		printk("dvbsoftwareca: unable to register netlink socket\n");
+		return -EFAULT;
+	}
+
+	for(i=0; i < 8; i++) {
+		for(j=0; (j<8 && devices_counter<MAX_CA_DEVICES); j++) {
+			struct file *filp;
+			
+			snprintf(device_name, 50, "/dev/dvb/adapter%d/frontend%d", i, j);
+			filp = filp_open(device_name,00,O_RDONLY);
+
+			if (!IS_ERR(filp) && filp!=NULL) {
+				filp_close(filp, NULL);
+
+				ret = create_ca_device(i, j, devices_counter++);
+				if (ret != 0) {
+					printk("dvbsoftwareca: Failed to add CA%d device for adapter%d\n", j, i);
+					failed = 1;
+					break;
+				}
+				printk("dvbsoftwareca: registered CA%d device for adapter%d\n", j, i);
+			}
+
+		}
+
+		if (failed)
+			break;
+	}
+
+	if (!failed)
+		printk("dvbsoftwareca: registered %d CA devices\n", devices_counter);
+	
+	if (failed) {
+		for(i = 0; i < devices_counter; i++) {
+			destroy_ca_device(ca_devices[i]);
+		}
+		platform_device_unregister(dvblb_basedev);
+		cdev_del(&ca_devices_cdev);
+		unregister_chrdev_region(dev, MAX_CA_DEVICES);
+
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_dvblb_module(void)
+{
+	int i;
+	printk("Unregistering CA devices");
+
+	for(i = 0; i < devices_counter; i++) {
+		destroy_ca_device(ca_devices[i]);
+	}
+
+        unregister_netlink();
+	class_destroy(dvb_class);
+
+	platform_device_unregister(dvblb_basedev);
+	cdev_del(&ca_devices_cdev);
+	unregister_chrdev_region(MKDEV(DVBSOFTWARECA_MAJOR, 0), MAX_CA_DEVICES);
+}
+
+module_init(dvblb_init);
+module_exit(cleanup_dvblb_module);
+
+MODULE_DESCRIPTION("DVB software CA device.");
+MODULE_AUTHOR("cougar");
+MODULE_LICENSE("GPL");
+MODULE_VERSION( DVBSOFTWARECA_VERSION );
+
diff -Naur enigma2.ori/dvbsoftwareca/dvb_softwareca.h enigma2/dvbsoftwareca/dvb_softwareca.h
--- enigma2.ori/dvbsoftwareca/dvb_softwareca.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/dvbsoftwareca/dvb_softwareca.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,17 @@
+#include <linux/wait.h>
+#include <linux/proc_fs.h>
+
+#define MAX_CA_DEVICES 16
+#define nums2minor(num,id)   ((num << 2) | id)
+
+#define dvblb_debug 0
+#define info(format, arg...) printk(KERN_INFO __FILE__ ": " format "\n" "", ## arg)
+#define dprintk if (dvblb_debug) printk
+
+struct ca_device {
+	int adapter_num;
+	int device_num;
+	int minor;
+	int users;
+};
+
diff -Naur enigma2.ori/lib/base/Makefile.am enigma2/lib/base/Makefile.am
--- enigma2.ori/lib/base/Makefile.am	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/base/Makefile.am	2011-12-16 06:15:29.000000000 +0100
@@ -26,6 +26,8 @@
 	rawfile.cpp \
 	smartptr.cpp \
 	thread.cpp \
+	tsRingbuffer.cpp \
+	condVar.cpp \
 	httpstream.cpp
 
 EXTRA_DIST = \
@@ -57,4 +59,6 @@
 	ringbuffer.h \
 	smartptr.h \
 	thread.h \
+	tsRingbuffer.h \
+	condVar.h \
 	httpstream.h
diff -Naur enigma2.ori/lib/base/condVar.cpp enigma2/lib/base/condVar.cpp
--- enigma2.ori/lib/base/condVar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/base/condVar.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+ * condVar.cpp: Mutexes, conditional vars.
+ *
+ * Video Disk Recorder
+ * Copyright (C) 2000, 2003, 2006, 2008 Klaus Schmidinger
+ * The author can be reached at kls@tvdr.de
+ * The project's page is at http://www.tvdr.de
+ *
+ */
+
+#include <lib/base/condVar.h>
+
+#if !defined(max)
+#define max(a, b)       ((a) > (b) ? (a) : (b))
+#endif
+
+static bool GetAbsTime(struct timespec *Abstime, int MillisecondsFromNow)
+{
+  struct timeval now;
+  if (gettimeofday(&now, NULL) == 0) {           // get current time
+     now.tv_usec += MillisecondsFromNow * 1000;  // add the timeout
+     while (now.tv_usec >= 1000000) {            // take care of an overflow
+           now.tv_sec++;
+           now.tv_usec -= 1000000;
+           }
+     Abstime->tv_sec = now.tv_sec;          // seconds
+     Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+     return true;
+     }
+  return false;
+}
+
+
+// --- cMutex ----------------------------------------------------------------
+
+cMutex::cMutex(void)
+{
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+  locked = 0;
+  pthread_mutex_init(&mutex, &attr);
+}
+
+cMutex::~cMutex()
+{
+  pthread_mutex_destroy(&mutex);
+}
+
+void cMutex::Lock(void)
+{
+  pthread_mutex_lock(&mutex);
+  locked++;
+}
+
+void cMutex::Unlock(void)
+{
+ if (!--locked)
+    pthread_mutex_unlock(&mutex);
+}
+
+
+// --- cCondVar --------------------------------------------------------------
+
+cCondVar::cCondVar(void)
+{
+  pthread_cond_init(&cond, 0);
+}
+
+cCondVar::~cCondVar()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+}
+
+void cCondVar::Wait(cMutex &Mutex)
+{
+  if (Mutex.locked) {
+     int locked = Mutex.locked;
+     Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_wait
+                       // does an implizit unlock of the mutex
+     pthread_cond_wait(&cond, &Mutex.mutex);
+     Mutex.locked = locked;
+     }
+}
+
+bool cCondVar::TimedWait(cMutex &Mutex, int TimeoutMs)
+{
+  bool r = true; // true = condition signaled false = timeout
+
+  if (Mutex.locked) {
+     struct timespec abstime;
+     if (GetAbsTime(&abstime, TimeoutMs)) {
+        int locked = Mutex.locked;
+        Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_timedwait
+                          // does an implizit unlock of the mutex.
+        if (pthread_cond_timedwait(&cond, &Mutex.mutex, &abstime) == ETIMEDOUT)
+           r = false;
+        Mutex.locked = locked;
+        }
+     }
+  return r;
+}
+
+void cCondVar::Broadcast(void)
+{
+  pthread_cond_broadcast(&cond);
+}
+
+
+// --- cCondWait -------------------------------------------------------------
+
+cCondWait::cCondWait(void)
+{
+  signaled = false;
+  pthread_mutex_init(&mutex, NULL);
+  pthread_cond_init(&cond, NULL);
+}
+
+cCondWait::~cCondWait()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+  pthread_mutex_destroy(&mutex);
+}
+
+void cCondWait::SleepMs(int TimeoutMs)
+{
+  cCondWait w;
+  w.Wait(max(TimeoutMs, 3)); // making sure the time is >2ms to avoid a possible busy wait
+}
+
+bool cCondWait::Wait(int TimeoutMs)
+{
+  pthread_mutex_lock(&mutex);
+  if (!signaled) {
+     if (TimeoutMs) {
+        struct timespec abstime;
+        if (GetAbsTime(&abstime, TimeoutMs)) {
+           while (!signaled) {
+                 if (pthread_cond_timedwait(&cond, &mutex, &abstime) == ETIMEDOUT)
+                    break;
+                 }
+           }
+        }
+     else
+        pthread_cond_wait(&cond, &mutex);
+     }
+  bool r = signaled;
+  signaled = false;
+  pthread_mutex_unlock(&mutex);
+  return r;
+}
+
+void cCondWait::Signal(void)
+{
+  pthread_mutex_lock(&mutex);
+  signaled = true;
+  pthread_cond_broadcast(&cond);
+  pthread_mutex_unlock(&mutex);
+}
+
+
+// --- cMutexLock ------------------------------------------------------------
+
+cMutexLock::cMutexLock(cMutex *Mutex)
+{
+  mutex = NULL;
+  locked = false;
+  Lock(Mutex);
+}
+
+cMutexLock::~cMutexLock()
+{
+  if (mutex && locked)
+     mutex->Unlock();
+}
+
+bool cMutexLock::Lock(cMutex *Mutex)
+{
+  if (Mutex && !mutex) {
+     mutex = Mutex;
+     Mutex->Lock();
+     locked = true;
+     return true;
+     }
+  return false;
+}
+
diff -Naur enigma2.ori/lib/base/condVar.h enigma2/lib/base/condVar.h
--- enigma2.ori/lib/base/condVar.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/base/condVar.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,52 @@
+#ifndef __base_condVar_h
+#define __base_condVar_h
+
+#include <pthread.h>
+
+class cMutex {
+  friend class cCondVar;
+private:
+  pthread_mutex_t mutex;
+  int locked;
+public:
+  cMutex(void);
+  ~cMutex();
+  void Lock(void);
+  void Unlock(void);
+};
+
+class cCondVar {
+private:
+  pthread_cond_t cond;
+public:
+  cCondVar(void);
+  ~cCondVar();
+  void Wait(cMutex &Mutex);
+  bool TimedWait(cMutex &Mutex, int TimeoutMs);
+  void Broadcast(void);
+};
+
+class cCondWait {
+private:
+  pthread_mutex_t mutex;
+  pthread_cond_t cond;
+  bool signaled;
+public:
+  cCondWait(void);
+  ~cCondWait();
+  static void SleepMs(int TimeoutMs);
+  bool Wait(int TimeoutMs = 0);
+  void Signal(void);
+};
+
+class cMutexLock {
+private:
+  cMutex *mutex;
+  bool locked;
+public:
+  cMutexLock(cMutex *Mutex = NULL);
+  ~cMutexLock();
+  bool Lock(cMutex *Mutex);
+};
+
+#endif
diff -Naur enigma2.ori/lib/base/filepush.cpp enigma2/lib/base/filepush.cpp
--- enigma2.ori/lib/base/filepush.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/base/filepush.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -1,6 +1,7 @@
 #include <lib/base/filepush.h>
 #include <lib/base/eerror.h>
 #include <lib/base/systemsettings.h>
+#include <lib/gdi/xineLib.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
@@ -83,6 +84,8 @@
 	act.sa_flags = 0;
 	sigaction(SIGUSR1, &act, 0);
 	
+	cXineLib *xineLib = cXineLib::getInstance();
+
 	hasStarted();
 
 		/* m_stop must be evaluated after each syscall. */
@@ -251,8 +254,8 @@
 			{
 				struct pollfd pfd;
 				pfd.fd = m_fd_dest;
-				pfd.events = POLLIN;
-				switch (poll(&pfd, 1, 250)) // wait for 250ms
+				pfd.events = POLLOUT;
+				switch (poll(&pfd, 1, 100)) // wait for 100ms
 				{
 					case 0:
 						eDebug("wait for driver eof timeout");
@@ -270,7 +273,19 @@
 				   over and over until somebody responds.
 				   
 				   in stream_mode, think of evtEOF as "buffer underrun occured". */
-			sendEvent(evtEOF);
+			/*xine_event_t *event;
+			while ( (event=xine_event_get(xine_queue)) != NULL ) {
+				if (event->type==XINE_EVENT_NBC_STATS) {
+					xine_nbc_stats_data_t* stats = (xine_nbc_stats_data_t*)event->data;
+					if (!stats->buffering && stats->v_percent<5) {
+						sendEvent(evtEOF);
+					}
+				}
+
+				xine_event_free(event);
+			}*/
+			if (xineLib->end_of_stream == true)
+				sendEvent(evtEOF);
 
 			if (m_stream_mode)
 			{
@@ -317,6 +332,16 @@
 	resume();
 }
 
+void eFilePushThread::start(ePtr<eDVBDemux> &demux, int fd, int fd_dest)
+{
+	eDecryptRawFile *f = new eDecryptRawFile();
+	ePtr<iTsSource> source = f;
+	f->setfd(fd);
+	f->setDemux(demux);
+
+	start(source, fd_dest);
+}
+
 void eFilePushThread::stop()
 {
 		/* if we aren't running, don't bother stopping. */
diff -Naur enigma2.ori/lib/base/filepush.h enigma2/lib/base/filepush.h
--- enigma2.ori/lib/base/filepush.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/base/filepush.h	2011-12-16 06:15:29.000000000 +0100
@@ -7,6 +7,7 @@
 #include <lib/base/message.h>
 #include <sys/types.h>
 #include <lib/base/rawfile.h>
+#include <lib/dvb/demux.h>
 
 class iFilePushScatterGather
 {
@@ -23,6 +24,7 @@
 	~eFilePushThread();
 	void thread();
 	void stop();
+	void start(ePtr<eDVBDemux> &demux, int fd, int fd_dest);
 	void start(int sourcefd, int destfd);
 	int start(const char *filename, int destfd);
 
diff -Naur enigma2.ori/lib/base/rawfile.cpp enigma2/lib/base/rawfile.cpp
--- enigma2.ori/lib/base/rawfile.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/base/rawfile.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -255,3 +255,120 @@
 {
 	return m_totallength;
 }
+
+#define KILOBYTE(n) ((n) * 1024)
+#define MEGABYTE(n) ((n) * 1024LL * 1024LL)
+#define AUDIO_STREAM_S   0xC0
+#define AUDIO_STREAM_E   0xDF
+#define VIDEO_STREAM_S   0xE0
+#define VIDEO_STREAM_E   0xEF
+
+eDecryptRawFile::eDecryptRawFile()
+{
+	ringBuffer = new cRingBufferLinear(MEGABYTE(2),TS_SIZE,true,"IN-TS");
+	ringBuffer->SetTimeouts(100,100);
+	bs_size = dvbcsa_bs_batch_size();
+	delivered=false;
+	lastPacketsCount = 0;
+	stream_correct = false;
+}
+
+eDecryptRawFile::~eDecryptRawFile()
+{
+	delete ringBuffer;
+}
+
+void eDecryptRawFile::setDemux(ePtr<eDVBDemux> _demux) {
+	demux = _demux;
+}
+
+uint8_t* eDecryptRawFile::getPackets(int &packetsCount) {
+	int Count=0;
+	if(delivered) {
+		ringBuffer->Del(lastPacketsCount*TS_SIZE);
+		delivered=false;
+	}
+	packetsCount = 0;
+
+	if (ringBuffer->Available()<bs_size*TS_SIZE)
+		return NULL;
+
+	uint8_t* p=ringBuffer->Get(Count);
+	if (Count>KILOBYTE(64))
+		Count = KILOBYTE(64);
+
+	if(p && Count>=TS_SIZE) {
+		if(*p!=TS_SYNC_BYTE) {
+			for(int i=1; i<Count; i++)
+				if(p[i]==TS_SYNC_BYTE &&
+						(i+TS_SIZE==Count || (i+TS_SIZE>Count && p[i+TS_SIZE]==TS_SYNC_BYTE)) ) {
+					Count=i;
+					break;
+				}
+				ringBuffer->Del(Count);
+				eDebug("ERROR: skipped %d bytes to sync on TS packet", Count);
+				return NULL;
+		}
+		if(!demux->decrypt(p, Count, packetsCount)) {
+			cCondWait::SleepMs(20);
+			return NULL;
+		}
+		lastPacketsCount = packetsCount;
+		delivered=true;
+		return p;
+	}
+
+	return NULL;
+}
+
+ssize_t eDecryptRawFile::read(off_t offset, void *buf, size_t count)
+{
+	eSingleLocker l(m_lock);
+	int ret;
+
+	while (ringBuffer->Available()<KILOBYTE(128)) {
+		ret = ringBuffer->Read(m_fd, KILOBYTE(64));
+		if (ret<0)
+			break;
+	}
+
+	int packetsCount = 0;
+
+	uint8_t *data = getPackets(packetsCount);
+
+	ret = -EBUSY;
+	if (data && packetsCount>0) {
+		if (!stream_correct) {
+			for (int i=0;i<packetsCount;i++) {
+				unsigned char* packet = data+i*TS_SIZE;
+				int adaptation_field_exist = (packet[3]&0x30)>>4;
+				unsigned char* wsk;
+				int len;
+
+				if (adaptation_field_exist==3) {
+					wsk = packet+5+packet[4];
+					len = 183-packet[4];
+				} else {
+					wsk = packet+4;
+					len = 184;
+				}
+
+				if (len>4 && wsk[0]==0 && wsk[1]==0 && wsk[2]==1
+						&& ((wsk[3]>=VIDEO_STREAM_S && wsk[3]<=VIDEO_STREAM_E)
+						|| (wsk[3]>=AUDIO_STREAM_S && wsk[3]<=AUDIO_STREAM_E)) ) {
+					stream_correct = true;
+					printf("-------------------- I have PES ---------------------- %02X\n", wsk[3]);
+					ret = (packetsCount-i)*TS_SIZE;
+					memcpy(buf, packet, (packetsCount-i)*TS_SIZE);
+					break;
+				}
+			}
+          	} else {
+			ret = packetsCount*TS_SIZE;
+			memcpy(buf, data, ret);
+		}
+	}
+
+	return ret;
+}
+
diff -Naur enigma2.ori/lib/base/rawfile.h enigma2/lib/base/rawfile.h
--- enigma2.ori/lib/base/rawfile.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/base/rawfile.h	2011-12-16 06:15:29.000000000 +0100
@@ -3,14 +3,15 @@
 
 #include <string>
 #include <lib/base/itssource.h>
+#include <lib/base/tsRingbuffer.h>
+#include <lib/dvb/demux.h>
 
 class eRawFile: public iTsSource
 {
 	DECLARE_REF(eRawFile);
-	eSingleLock m_lock;
 public:
 	eRawFile();
-	~eRawFile();
+	virtual ~eRawFile();
 	int open(const char *filename, int cached = 0);
 	void setfd(int fd);
 	int close();
@@ -20,8 +21,10 @@
 	ssize_t read(off_t offset, void *buf, size_t count);
 	off_t length();
 	int valid();
-private:
+protected:
+	eSingleLock m_lock;
 	int m_fd;     /* for uncached */
+private:
 	FILE *m_file; /* for cached */
 	int m_cached;
 	std::string m_basename;
@@ -36,4 +39,22 @@
 	int openFileUncached(int nr);
 };
 
+class eDecryptRawFile: public eRawFile
+{
+public:
+	eDecryptRawFile();
+	~eDecryptRawFile();
+	void setDemux(ePtr<eDVBDemux> demux);
+	ssize_t read(off_t offset, void *buf, size_t count);
+private:
+	ePtr<eDVBDemux> demux;
+	cRingBufferLinear *ringBuffer;
+	int bs_size;
+	bool delivered;
+	int lastPacketsCount;
+	bool stream_correct;
+
+	uint8_t* getPackets(int &packetsCount);
+};
+
 #endif
diff -Naur enigma2.ori/lib/base/tsRingbuffer.cpp enigma2/lib/base/tsRingbuffer.cpp
--- enigma2.ori/lib/base/tsRingbuffer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/base/tsRingbuffer.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,335 @@
+/*
+ * tsRingbuffer.cpp: A ring buffer
+ *
+ * Video Disk Recorder
+ * Copyright (C) 2000, 2003, 2006, 2008 Klaus Schmidinger
+ * The author can be reached at kls@tvdr.de
+ * The project's page is at http://www.tvdr.de
+ *
+ */
+
+#include <lib/base/tsRingbuffer.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+
+// --- cRingBuffer -----------------------------------------------------------
+
+#define OVERFLOWREPORTDELTA 5 // seconds between reports
+#define PERCENTAGEDELTA     10
+#define PERCENTAGETHRESHOLD 70
+
+cRingBuffer::cRingBuffer(int Size, bool Statistics)
+{
+  size = Size;
+  statistics = Statistics;
+  maxFill = 0;
+  lastPercent = 0;
+  putTimeout = getTimeout = 0;
+  lastOverflowReport = 0;
+  overflowCount = overflowBytes = 0;
+}
+
+cRingBuffer::~cRingBuffer()
+{
+  if (statistics)
+     printf("buffer stats: %d (%d%%) used\n", maxFill, maxFill * 100 / (size - 1));
+}
+
+void cRingBuffer::UpdatePercentage(int Fill)
+{
+  if (Fill > maxFill)
+     maxFill = Fill;
+  int percent = Fill * 100 / (Size() - 1) / PERCENTAGEDELTA * PERCENTAGEDELTA; // clamp down to nearest quantum
+  if (percent != lastPercent) {
+    if ((percent >= PERCENTAGETHRESHOLD && percent > lastPercent)
+        || (percent < PERCENTAGETHRESHOLD && lastPercent >= PERCENTAGETHRESHOLD)) {
+      printf("buffer usage: %d%%\n", percent);
+      lastPercent = percent;
+    }
+  }
+}
+
+void cRingBuffer::WaitForPut(void)
+{
+  if (putTimeout)
+     readyForPut.Wait(putTimeout);
+}
+
+void cRingBuffer::WaitForGet(void)
+{
+  if (getTimeout)
+     readyForGet.Wait(getTimeout);
+}
+
+void cRingBuffer::EnablePut(void)
+{
+  if (putTimeout && Free() > Size() / 3)
+     readyForPut.Signal();
+}
+
+void cRingBuffer::EnableGet(void)
+{
+  if (getTimeout && Available() > Size() / 3)
+     readyForGet.Signal();
+}
+
+void cRingBuffer::SetTimeouts(int PutTimeout, int GetTimeout)
+{
+  putTimeout = PutTimeout;
+  getTimeout = GetTimeout;
+}
+
+void cRingBuffer::ReportOverflow(int Bytes)
+{
+  overflowCount++;
+  overflowBytes += Bytes;
+  if (time(NULL) - lastOverflowReport > OVERFLOWREPORTDELTA) {
+     printf("ERROR: %d ring buffer overflow%s (%d bytes dropped)\n", overflowCount, overflowCount > 1 ? "s" : "", overflowBytes);
+     overflowCount = overflowBytes = 0;
+     lastOverflowReport = time(NULL);
+     }
+}
+
+// --- cRingBufferLinear -----------------------------------------------------
+
+#ifdef DEBUGRINGBUFFERS
+#define MAXRBLS 30
+#define DEBUGRBLWIDTH 45
+
+cRingBufferLinear *cRingBufferLinear::RBLS[MAXRBLS] = { NULL };
+
+void cRingBufferLinear::AddDebugRBL(cRingBufferLinear *RBL)
+{
+  for (int i = 0; i < MAXRBLS; i++) {
+      if (!RBLS[i]) {
+         RBLS[i] = RBL;
+         break;
+         }
+      }
+}
+
+void cRingBufferLinear::DelDebugRBL(cRingBufferLinear *RBL)
+{
+  for (int i = 0; i < MAXRBLS; i++) {
+      if (RBLS[i] == RBL) {
+         RBLS[i] = NULL;
+         break;
+         }
+      }
+}
+
+void cRingBufferLinear::PrintDebugRBL(void)
+{
+  bool printed = false;
+  for (int i = 0; i < MAXRBLS; i++) {
+      cRingBufferLinear *p = RBLS[i];
+      if (p) {
+         printed = true;
+         int lh = p->lastHead;
+         int lt = p->lastTail;
+         int h = lh * DEBUGRBLWIDTH / p->Size();
+         int t = lt * DEBUGRBLWIDTH / p->Size();
+         char buf[DEBUGRBLWIDTH + 10];
+         memset(buf, '-', DEBUGRBLWIDTH);
+         if (lt <= lh)
+            memset(buf + t, '*', max(h - t, 1));
+         else {
+            memset(buf, '*', h);
+            memset(buf + t, '*', DEBUGRBLWIDTH - t);
+            }
+         buf[t] = '<';
+         buf[h] = '>';
+         buf[DEBUGRBLWIDTH] = 0;
+         printf("%2d %s %8d %8d %s\n", i, buf, p->lastPut, p->lastGet, p->description);
+         }
+      }
+  if (printed)
+     printf("\n");
+  }
+#endif
+
+cRingBufferLinear::cRingBufferLinear(int Size, int Margin, bool Statistics, const char *Description)
+:cRingBuffer(Size, Statistics)
+{
+  description = Description ? strdup(Description) : NULL;
+  tail = head = margin = Margin;
+  gotten = 0;
+  buffer = NULL;
+  if (Size > 1) { // 'Size - 1' must not be 0!
+     if (Margin <= Size / 2) {
+        buffer = (uint8_t*)malloc(sizeof(uint8_t) * Size);
+        if (!buffer)
+           printf("ERROR: can't allocate ring buffer (size=%d)\n", Size);
+        Clear();
+        }
+     else
+        printf("ERROR: invalid margin for ring buffer (%d > %d)\n", Margin, Size / 2);
+     }
+  else
+     printf("ERROR: invalid size for ring buffer (%d)\n", Size);
+#ifdef DEBUGRINGBUFFERS
+  lastHead = head;
+  lastTail = tail;
+  lastPut = lastGet = -1;
+  AddDebugRBL(this);
+#endif
+}
+
+cRingBufferLinear::~cRingBufferLinear()
+{
+#ifdef DEBUGRINGBUFFERS
+  DelDebugRBL(this);
+#endif
+  free(buffer);
+  free(description);
+}
+
+int cRingBufferLinear::DataReady(const uint8_t *Data, int Count)
+{
+  return Count >= margin ? Count : 0;
+}
+
+int cRingBufferLinear::Available(void)
+{
+  int diff = head - tail;
+  return (diff >= 0) ? diff : Size() + diff - margin;
+}
+
+void cRingBufferLinear::Clear(void)
+{
+  tail = head = margin;
+#ifdef DEBUGRINGBUFFERS
+  lastHead = head;
+  lastTail = tail;
+  lastPut = lastGet = -1;
+#endif
+  maxFill = 0;
+  EnablePut();
+}
+
+int cRingBufferLinear::Read(int FileHandle, int Max)
+{
+  int Tail = tail;
+  int diff = Tail - head;
+  int free = (diff > 0) ? diff - 1 : Size() - head;
+  if (Tail <= margin)
+     free--;
+  int Count = -1;
+  errno = EAGAIN;
+
+  if (free > 0) {
+     if (0 < Max && Max < free)
+        free = Max;
+     Count = read(FileHandle, buffer + head, free);
+     if (Count > 0) {
+        int Head = head + Count;
+        if (Head >= Size())
+           Head = margin;
+        head = Head;
+        if (statistics) {
+           int fill = head - Tail;
+           if (fill < 0)
+              fill = Size() + fill;
+           else if (fill >= Size())
+              fill = Size() - 1;
+           UpdatePercentage(fill);
+           }
+        }
+     }
+#ifdef DEBUGRINGBUFFERS
+  lastHead = head;
+  lastPut = Count;
+#endif
+  EnableGet();
+  if (free == 0)
+     WaitForPut();
+  return Count;
+}
+
+int cRingBufferLinear::Put(const uint8_t *Data, int Count)
+{
+  if (Count > 0) {
+     int Tail = tail;
+     int rest = Size() - head;
+     int diff = Tail - head;
+     int free = ((Tail < margin) ? rest : (diff > 0) ? diff : Size() + diff - margin) - 1;
+     if (statistics) {
+        int fill = Size() - free - 1 + Count;
+        if (fill >= Size())
+           fill = Size() - 1;
+        UpdatePercentage(fill);
+        }
+     if (free > 0) {
+        if (free < Count)
+           Count = free;
+        if (Count >= rest) {
+           memcpy(buffer + head, Data, rest);
+           if (Count - rest)
+              memcpy(buffer + margin, Data + rest, Count - rest);
+           head = margin + Count - rest;
+           }
+        else {
+           memcpy(buffer + head, Data, Count);
+           head += Count;
+           }
+        }
+     else
+        Count = 0;
+#ifdef DEBUGRINGBUFFERS
+     lastHead = head;
+     lastPut = Count;
+#endif
+     EnableGet();
+     if (Count == 0)
+        WaitForPut();
+     }
+  return Count;
+}
+
+uint8_t *cRingBufferLinear::Get(int &Count)
+{
+  int Head = head;
+  int rest = Size() - tail;
+  if (rest < margin && Head < tail) {
+     int t = margin - rest;
+     memcpy(buffer + t, buffer + tail, rest);
+     tail = t;
+     rest = Head - tail;
+     }
+  int diff = Head - tail;
+  int cont = (diff >= 0) ? diff : Size() + diff - margin;
+  if (cont > rest)
+     cont = rest;
+  uint8_t *p = buffer + tail;
+
+  if ((cont = DataReady(p, cont)) > 0) {
+     Count = gotten = cont;
+     return p;
+     }
+  WaitForGet();
+  return NULL;
+}
+
+void cRingBufferLinear::Del(int Count)
+{
+  if (Count > gotten) {
+     printf("ERROR: invalid Count in cRingBufferLinear::Del: %d (limited to %d)\n", Count, gotten);
+     Count = gotten;
+     }
+  if (Count > 0) {
+     int Tail = tail;
+     Tail += Count;
+     gotten -= Count;
+     if (Tail >= Size())
+        Tail = margin;
+     tail = Tail;
+     EnablePut();
+     }
+#ifdef DEBUGRINGBUFFERS
+  lastTail = tail;
+  lastGet = Count;
+#endif
+}
+
+
diff -Naur enigma2.ori/lib/base/tsRingbuffer.h enigma2/lib/base/tsRingbuffer.h
--- enigma2.ori/lib/base/tsRingbuffer.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/base/tsRingbuffer.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,90 @@
+#ifndef __tsringbuffer_h
+#define __tsringbuffer_h
+
+#include <lib/base/condVar.h>
+
+class cRingBuffer {
+private:
+  cCondWait readyForPut, readyForGet;
+  int putTimeout;
+  int getTimeout;
+  int size;
+  time_t lastOverflowReport;
+  int overflowCount;
+  int overflowBytes;
+protected:
+  int maxFill;//XXX
+  int lastPercent;
+  bool statistics;//XXX
+  void UpdatePercentage(int Fill);
+  void WaitForPut(void);
+  void WaitForGet(void);
+  void EnablePut(void);
+  void EnableGet(void);
+  virtual void Clear(void) = 0;
+  virtual int Available(void) = 0;
+  virtual int Free(void) { return Size() - Available() - 1; }
+  int Size(void) { return size; }
+public:
+  cRingBuffer(int Size, bool Statistics = false);
+  virtual ~cRingBuffer();
+  void SetTimeouts(int PutTimeout, int GetTimeout);
+  void ReportOverflow(int Bytes);
+  };
+
+class cRingBufferLinear : public cRingBuffer {
+//#define DEBUGRINGBUFFERS
+#ifdef DEBUGRINGBUFFERS
+private:
+  int lastHead, lastTail;
+  int lastPut, lastGet;
+  static cRingBufferLinear *RBLS[];
+  static void AddDebugRBL(cRingBufferLinear *RBL);
+  static void DelDebugRBL(cRingBufferLinear *RBL);
+public:
+  static void PrintDebugRBL(void);
+#endif
+private:
+  int margin, head, tail;
+  int gotten;
+  uint8_t *buffer;
+  char *description;
+protected:
+  virtual int DataReady(const uint8_t *Data, int Count);
+    ///< By default a ring buffer has data ready as soon as there are at least
+    ///< 'margin' bytes available. A derived class can reimplement this function
+    ///< if it has other conditions that define when data is ready.
+    ///< The return value is either 0 if there is not yet enough data available,
+    ///< or the number of bytes from the beginning of Data that are "ready".
+public:
+  cRingBufferLinear(int Size, int Margin = 0, bool Statistics = false, const char *Description = NULL);
+    ///< Creates a linear ring buffer.
+    ///< The buffer will be able to hold at most Size-Margin-1 bytes of data, and will
+    ///< be guaranteed to return at least Margin bytes in one consecutive block.
+    ///< The optional Description is used for debugging only.
+  virtual ~cRingBufferLinear();
+  virtual int Available(void);
+  virtual int Free(void) { return Size() - Available() - 1 - margin; }
+  virtual void Clear(void);
+    ///< Immediately clears the ring buffer.
+  int Read(int FileHandle, int Max = 0);
+    ///< Reads at most Max bytes from FileHandle and stores them in the
+    ///< ring buffer. If Max is 0, reads as many bytes as possible.
+    ///< Only one actual read() call is done.
+    ///< \return Returns the number of bytes actually read and stored, or
+    ///< an error value from the actual read() call.
+  int Put(const uint8_t *Data, int Count);
+    ///< Puts at most Count bytes of Data into the ring buffer.
+    ///< \return Returns the number of bytes actually stored.
+  uint8_t *Get(int &Count);
+    ///< Gets data from the ring buffer.
+    ///< The data will remain in the buffer until a call to Del() deletes it.
+    ///< \return Returns a pointer to the data, and stores the number of bytes
+    ///< actually available in Count. If the returned pointer is NULL, Count has no meaning.
+  void Del(int Count);
+    ///< Deletes at most Count bytes from the ring buffer.
+    ///< Count must be less or equal to the number that was returned by a previous
+    ///< call to Get().
+  };
+
+#endif
diff -Naur enigma2.ori/lib/components/Makefile.am enigma2/lib/components/Makefile.am
--- enigma2.ori/lib/components/Makefile.am	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/components/Makefile.am	2011-12-16 06:15:29.000000000 +0100
@@ -8,8 +8,7 @@
 
 libenigma_components_a_SOURCES = \
 	file_eraser.cpp \
-	scan.cpp \
-	tuxtxtapp.cpp
+	scan.cpp
 
 
 componentsincludedir = $(pkgincludedir)/lib/components
diff -Naur enigma2.ori/lib/components/tuxtxtapp.cpp enigma2/lib/components/tuxtxtapp.cpp
--- enigma2.ori/lib/components/tuxtxtapp.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/components/tuxtxtapp.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-#include <lib/components/tuxtxtapp.h>
-#include <lib/base/init.h>
-#include <lib/base/init_num.h>
-#include <lib/driver/rc.h>
-#include <lib/gdi/lcd.h>
-#include <lib/gdi/fb.h>
-#include <lib/gui/ewidget.h>
-#include <lib/gui/ewidgetdesktop.h>
-#include <lib/python/python.h>
-
-extern "C" int tuxtxt_run_ui(int pid, int demux);
-extern "C" int tuxtxt_init();
-extern "C" void tuxtxt_start(int tpid, int demux);
-extern "C" int tuxtxt_stop();
-extern "C" void tuxtxt_close();
-
-eAutoInitP0<eTuxtxtApp> init_eTuxtxtApp(eAutoInitNumbers::lowlevel, "Tuxtxt");
-eTuxtxtApp *eTuxtxtApp::instance = NULL;
-
-eTuxtxtApp::eTuxtxtApp() : pid(0), enableTtCaching(false), uiRunning(false), messagePump(eApp, 0)
-{
-	CONNECT(messagePump.recv_msg, eTuxtxtApp::recvEvent);
-	pthread_mutex_init( &cacheChangeLock, 0 );
-	if (!instance)
-		instance=this;
-}
-
-eTuxtxtApp::~eTuxtxtApp()
-{
-	if (instance==this)
-		instance=0;
-	kill();
-	pthread_mutex_destroy( &cacheChangeLock );
-}
-
-void eTuxtxtApp::recvEvent(const int &evt)
-{
-	uiRunning = false;
-	eRCInput::getInstance()->unlock();
-	eDBoxLCD::getInstance()->unlock();
-	eDBoxLCD::getInstance()->update();
-	fbClass::getInstance()->unlock();
-	/* emit */appClosed();
-}
-
-int eTuxtxtApp::startUi()
-{
-	if (fbClass::getInstance()->lock() >= 0)
-	{
-		eDBoxLCD::getInstance()->lock();
-		eRCInput::getInstance()->lock();
-		pthread_mutex_lock( &cacheChangeLock );
-		uiRunning = true;
-		pthread_mutex_unlock( &cacheChangeLock );
-		run();
-	}
-	else
-	{
-		/* emit */appClosed();
-	}
-	return 0;
-}
-
-void eTuxtxtApp::thread()
-{
-	hasStarted();
-	tuxtxt_run_ui(pid, demux);
-}
-
-void eTuxtxtApp::thread_finished()
-{
-	messagePump.send(0);
-}
-
-void eTuxtxtApp::initCache()
-{
-	if (enableTtCaching)
-		tuxtxt_init();
-}
-
-void eTuxtxtApp::freeCache()
-{
-	pthread_mutex_lock( &cacheChangeLock );
-	if ( !uiRunning )
-	{
-		tuxtxt_close();
-		pid = 0;
-	}
-	pthread_mutex_unlock( &cacheChangeLock );
-}
-
-void eTuxtxtApp::startCaching( int tpid, int tdemux)
-{
-	pid = tpid;
-	demux = tdemux;
-	if (enableTtCaching)
-		tuxtxt_start(pid, demux);
-}
-
-void eTuxtxtApp::stopCaching()
-{
-	pthread_mutex_lock( &cacheChangeLock );
-	if ( !uiRunning )
-		tuxtxt_stop();
-
-	pthread_mutex_unlock( &cacheChangeLock );
-}
-
-void eTuxtxtApp::setEnableTtCachingOnOff( int onoff )
-{
-	if (onoff && !enableTtCaching)		// Switch caching on
-	{
-		enableTtCaching = true;
-		if (pid)
-		{
-			initCache();
-			startCaching(pid, demux);
-		}
-	}
-	else if (!onoff && enableTtCaching)	// Switch caching off
-	{
-		enableTtCaching = false;
-		int savePid = pid;
-		freeCache();
-		pid = savePid;
-	}
-}
diff -Naur enigma2.ori/lib/components/tuxtxtapp.h enigma2/lib/components/tuxtxtapp.h
--- enigma2.ori/lib/components/tuxtxtapp.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/components/tuxtxtapp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-#ifndef __LIB_COMPONENTS_TUXTXTAPP_H__
-#define __LIB_COMPONENTS_TUXTXTAPP_H__
-
-#include <string>
-#include <lib/base/ebase.h>
-#include <lib/base/thread.h>
-#include <lib/base/message.h>
-#include <lib/python/python.h>
-#include <lib/python/connections.h>
-
-class eTuxtxtApp: private eThread, public Object
-{
-#ifndef SWIG
-	int pid;
-	int demux;
-	bool enableTtCaching, uiRunning;
-	static eTuxtxtApp *instance;
-	pthread_mutex_t cacheChangeLock;
-
-	eFixedMessagePump<int> messagePump;
-	void recvEvent(const int &evt);
-
-	void thread();
-	void thread_finished();
-#endif
-public:
-	eTuxtxtApp();
-	~eTuxtxtApp();
-	static eTuxtxtApp *getInstance() { return instance; }
-	int startUi();
-	void initCache();
-	void freeCache();
-	void startCaching( int tpid, int tdemux );
-	void stopCaching();
-	void resetPid() { pid = 0; demux = 0; }
-	void setEnableTtCachingOnOff( int onoff );
-	PSignal0<void> appClosed;
-};
-
-#endif // __LIB_COMPONENTS_TUXTXTAPP_H__
diff -Naur enigma2.ori/lib/driver/Makefile.am enigma2/lib/driver/Makefile.am
--- enigma2.ori/lib/driver/Makefile.am	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/driver/Makefile.am	2011-12-16 06:15:29.000000000 +0100
@@ -37,3 +37,9 @@
 	rcsdl.cpp \
 	rcsdl.h
 endif
+
+if HAVE_XLIB
+libenigma_driver_a_SOURCES += \
+	rcxlib.cpp \
+	rcxlib.h
+endif
diff -Naur enigma2.ori/lib/driver/avswitch.cpp enigma2/lib/driver/avswitch.cpp
--- enigma2.ori/lib/driver/avswitch.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/driver/avswitch.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -2,278 +2,83 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <string.h>
-
 #include <lib/base/init.h>
 #include <lib/base/init_num.h>
 #include <lib/base/eerror.h>
 #include <lib/base/ebase.h>
 #include <lib/driver/avswitch.h>
-
+#include <lib/gdi/xineLib.h>
 eAVSwitch *eAVSwitch::instance = 0;
-
+ 
 eAVSwitch::eAVSwitch()
 {
-	ASSERT(!instance);
-	instance = this;
-	m_video_mode = 0;
-	m_active = false;
-	m_fp_fd = open("/dev/dbox/fp0", O_RDONLY|O_NONBLOCK);
-	if (m_fp_fd == -1)
-	{
-		eDebug("couldnt open /dev/dbox/fp0 to monitor vcr scart slow blanking changed!");
-		m_fp_notifier=0;
-	}
-	else
-	{
-		m_fp_notifier = eSocketNotifier::create(eApp, m_fp_fd, eSocketNotifier::Read|POLLERR);
-		CONNECT(m_fp_notifier->activated, eAVSwitch::fp_event);
-	}
-}
-
-#ifndef FP_IOCTL_GET_EVENT
-#define FP_IOCTL_GET_EVENT 20
-#endif
-
-#ifndef FP_IOCTL_GET_VCR
-#define FP_IOCTL_GET_VCR 7
-#endif
-
-#ifndef FP_EVENT_VCR_SB_CHANGED
-#define FP_EVENT_VCR_SB_CHANGED 1
-#endif
-
-int eAVSwitch::getVCRSlowBlanking()
-{
-	int val=0;
-	if (m_fp_fd >= 0)
-	{
-		FILE *f = fopen("/proc/stb/fp/vcr_fns", "r");
-		if (f)
-		{
-			if (fscanf(f, "%d", &val) != 1)
-				eDebug("read /proc/stb/fp/vcr_fns failed!! (%m)");
-			fclose(f);
-		}
-		else if (ioctl(m_fp_fd, FP_IOCTL_GET_VCR, &val) < 0)
-			eDebug("FP_GET_VCR failed (%m)");
-	}
-	return val;
-}
-
-void eAVSwitch::fp_event(int what)
-{
-	if (what & POLLERR) // driver not ready for fp polling
-	{
-		eDebug("fp driver not read for polling.. so disable polling");
-		m_fp_notifier->stop();
-	}
-	else
-	{
-		FILE *f = fopen("/proc/stb/fp/events", "r");
-		if (f)
-		{
-			int events;
-			if (fscanf(f, "%d", &events) != 1)
-				eDebug("read /proc/stb/fp/events failed!! (%m)");
-			else if (events & FP_EVENT_VCR_SB_CHANGED)
-				/* emit */ vcr_sb_notifier(getVCRSlowBlanking());
-			fclose(f);
-		}
-		else
-		{
-			int val = FP_EVENT_VCR_SB_CHANGED;  // ask only for this event
-			if (ioctl(m_fp_fd, FP_IOCTL_GET_EVENT, &val) < 0)
-				eDebug("FP_IOCTL_GET_EVENT failed (%m)");
-			else if (val & FP_EVENT_VCR_SB_CHANGED)
-				/* emit */ vcr_sb_notifier(getVCRSlowBlanking());
-		}
-	}
+ASSERT(!instance);
+instance = this;
+m_video_mode = 0;
 }
-
-eAVSwitch::~eAVSwitch()
+int eAVSwitch::getVCRSlowBlanking()
 {
-	if ( m_fp_fd >= 0 )
-		close(m_fp_fd);
+return 0;
 }
-
+eAVSwitch::~eAVSwitch() {}
 eAVSwitch *eAVSwitch::getInstance()
 {
-	return instance;
+return instance;
 }
-
 bool eAVSwitch::haveScartSwitch()
 {
-	char tmp[255];
-	int fd = open("/proc/stb/avs/0/input_choices", O_RDONLY);
-	if(fd < 0) {
-		eDebug("cannot open /proc/stb/avs/0/input_choices");
-		return false;
-	}
-	read(fd, tmp, 255);
-	close(fd);
-	return !!strstr(tmp, "scart");
-}
-
-void eAVSwitch::setInput(int val)
-{
-	/*
-	0-encoder
-	1-scart
-	2-aux
-	*/
-
-	const char *input[] = {"encoder", "scart", "aux"};
-
-	int fd;
-
-	m_active = val == 0;
-
-	if((fd = open("/proc/stb/avs/0/input", O_WRONLY)) < 0) {
-		eDebug("cannot open /proc/stb/avs/0/input");
-		return;
-	}
-
-	write(fd, input[val], strlen(input[val]));
-	close(fd);
+return false;
 }
-
 bool eAVSwitch::isActive()
 {
-	return m_active;
+return m_active;
 }
-
+void eAVSwitch::setInput(int val)
+{}
 void eAVSwitch::setColorFormat(int format)
-{
-	/*
-	0-CVBS
-	1-RGB
-	2-S-Video
-	*/
-	const char *cvbs="cvbs";
-	const char *rgb="rgb";
-	const char *svideo="svideo";
-	const char *yuv="yuv";
-	int fd;
-	
-	if((fd = open("/proc/stb/avs/0/colorformat", O_WRONLY)) < 0) {
-		printf("cannot open /proc/stb/avs/0/colorformat\n");
-		return;
-	}
-	switch(format) {
-		case 0:
-			write(fd, cvbs, strlen(cvbs));
-			break;
-		case 1:
-			write(fd, rgb, strlen(rgb));
-			break;
-		case 2:
-			write(fd, svideo, strlen(svideo));
-			break;
-		case 3:
-			write(fd, yuv, strlen(yuv));
-			break;
-	}	
-	close(fd);
-}
-
+{}
 void eAVSwitch::setAspectRatio(int ratio)
-{
-	/*
-	0-4:3 Letterbox
-	1-4:3 PanScan
-	2-16:9
-	3-16:9 forced ("panscan")
-	4-16:10 Letterbox
-	5-16:10 PanScan
-	6-16:9 forced ("letterbox")
-	*/
-	const char *aspect[] = {"4:3", "4:3", "any", "16:9", "16:10", "16:10", "16:9", "16:9"};
-	const char *policy[] = {"letterbox", "panscan", "bestfit", "panscan", "letterbox", "panscan", "letterbox"};
-
-	int fd;
-	if((fd = open("/proc/stb/video/aspect", O_WRONLY)) < 0) {
-		eDebug("cannot open /proc/stb/video/aspect");
-		return;
-	}
-//	eDebug("set aspect to %s", aspect[ratio]);
-	write(fd, aspect[ratio], strlen(aspect[ratio]));
-	close(fd);
-
-	if((fd = open("/proc/stb/video/policy", O_WRONLY)) < 0) {
-		eDebug("cannot open /proc/stb/video/policy");
-		return;
-	}
-//	eDebug("set ratio to %s", policy[ratio]);
-	write(fd, policy[ratio], strlen(policy[ratio]));
-	close(fd);
-
+{       cXineLib *xineLib = cXineLib::getInstance();
+          cXineLib::getInstance()->setAspectRatio(ratio);
+}
+void eAVSwitch::setPolicy43(int mode)
+  {cXineLib *xineLib = cXineLib::getInstance();
+   cXineLib::getInstance()->setPolicy43(mode);
+  }
+ 
+void eAVSwitch::setPolicy169(int mode)
+  {cXineLib *xineLib = cXineLib::getInstance();
+  cXineLib::getInstance()->setPolicy169(mode);
+}
+ 
+void eAVSwitch::setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y)
+{cXineLib *xineLib = cXineLib::getInstance();
+  cXineLib::getInstance()->setZoom(zoom43_x, zoom43_y, zoom169_x, zoom169_y);
+}
+ 
+void eAVSwitch::updateScreen()
+{cXineLib *xineLib = cXineLib::getInstance();
+  cXineLib::getInstance()->adjust_policy();
 }
-
+// 50/60 Hz
 void eAVSwitch::setVideomode(int mode)
 {
-	const char *pal="pal";
-	const char *ntsc="ntsc";
-	
-	if (mode == m_video_mode)
-		return;
-
-	if (mode == 2)
-	{
-		int fd1 = open("/proc/stb/video/videomode_50hz", O_WRONLY);
-		if(fd1 < 0) {
-			eDebug("cannot open /proc/stb/video/videomode_50hz");
-			return;
-		}
-		int fd2 = open("/proc/stb/video/videomode_60hz", O_WRONLY);
-		if(fd2 < 0) {
-			eDebug("cannot open /proc/stb/video/videomode_60hz");
-			close(fd1);
-			return;
-		}
-		write(fd1, pal, strlen(pal));
-		write(fd2, ntsc, strlen(ntsc));
-		close(fd1);
-		close(fd2);
-	}
-	else
-	{
-		int fd = open("/proc/stb/video/videomode", O_WRONLY);
-		if(fd < 0) {
-			eDebug("cannot open /proc/stb/video/videomode");
-			return;
-		}
-		switch(mode) {
-			case 0:
-				write(fd, pal, strlen(pal));
-				break;
-			case 1:
-				write(fd, ntsc, strlen(ntsc));
-				break;
-			default:
-				eDebug("unknown videomode %d", mode);
-		}
-		close(fd);
-	}
-
-	m_video_mode = mode;
+//printf("----------------------- eAVSwitch::setVideomode %d\n", mode);
+if (mode == m_video_mode)
+  return;
+m_video_mode = mode;
 }
-
 void eAVSwitch::setWSS(int val) // 0 = auto, 1 = auto(4:3_off)
-{
-	int fd;
-	if((fd = open("/proc/stb/denc/0/wss", O_WRONLY)) < 0) {
-		eDebug("cannot open /proc/stb/denc/0/wss");
-		return;
-	}
-	const char *wss[] = {
-		"off", "auto", "auto(4:3_off)", "4:3_full_format", "16:9_full_format",
-		"14:9_letterbox_center", "14:9_letterbox_top", "16:9_letterbox_center",
-		"16:9_letterbox_top", ">16:9_letterbox_center", "14:9_full_format"
-	};
-	write(fd, wss[val], strlen(wss[val]));
-//	eDebug("set wss to %s", wss[val]);
-	close(fd);
+{}
+ 
+void eAVSwitch::setDeinterlace(int global, int sd, int hd)
+{cXineLib *xineLib = cXineLib::getInstance();
+  cXineLib::getInstance()->setDeinterlace(global, sd, hd);
+}
+ 
+void eAVSwitch::setSDfeatures(int sharpness, int noise)
+{cXineLib *xineLib = cXineLib::getInstance();
+  cXineLib::getInstance()->setSDfeatures(sharpness, noise);
 }
-
 //FIXME: correct "run/startlevel"
-eAutoInitP0<eAVSwitch> init_avswitch(eAutoInitNumbers::rc, "AVSwitch Driver");
+eAutoInitP0<eAVSwitch> init_avswitch(eAutoInitNumbers::rc, "AVSwitch Driver");
\ No newline at end of file
diff -Naur enigma2.ori/lib/driver/avswitch.h enigma2/lib/driver/avswitch.h
--- enigma2.ori/lib/driver/avswitch.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/driver/avswitch.h	2011-12-16 06:15:29.000000000 +0100
@@ -2,18 +2,12 @@
 #define __avswitch_h
 
 #include <lib/base/object.h>
-#include <lib/python/connections.h>
-
-class eSocketNotifier;
 
 class eAVSwitch: public Object
 {
 	static eAVSwitch *instance;
 	int m_video_mode;
 	bool m_active;
-	ePtr<eSocketNotifier> m_fp_notifier;
-	void fp_event(int what);
-	int m_fp_fd;
 #ifdef SWIG
 	eAVSwitch();
 	~eAVSwitch();
@@ -29,9 +23,15 @@
 	int getVCRSlowBlanking();
 	void setColorFormat(int format);
 	void setAspectRatio(int ratio);
+	void setPolicy43(int mode);
+	void setPolicy169(int mode);
+ 	void setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y);
+ 	void updateScreen();
 	void setVideomode(int mode);
 	void setInput(int val);
 	void setWSS(int val);
+	void setDeinterlace(int global, int sd, int hd);
+ 	void setSDfeatures(int sharpness, int noise);
 	bool isActive();
 	PSignal1<void, int> vcr_sb_notifier;
 };
diff -Naur enigma2.ori/lib/driver/misc_options.cpp enigma2/lib/driver/misc_options.cpp
--- enigma2.ori/lib/driver/misc_options.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/driver/misc_options.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -22,10 +22,10 @@
 {
 	if (state == m_12V_output_state)
 		return 0;
-	int fd = open("/proc/stb/misc/12V_output", O_WRONLY);
+	int fd = open("/usr/local/e2/etc/stb/misc/12V_output", O_WRONLY);
 	if (fd < 0)
 	{
-		eDebug("couldn't open /proc/stb/misc/12V_output");
+		eDebug("couldn't open /usr/local/e2/etc/stb/misc/12V_output");
 		return -1;
 	}
 	const char *str=0;
@@ -42,10 +42,10 @@
 
 bool Misc_Options::detected_12V_output()
 {
-	int fd = open("/proc/stb/misc/12V_output", O_WRONLY);
+	int fd = open("/usr/local/e2/etc/stb/misc/12V_output", O_WRONLY);
 	if (fd < 0)
 	{
-		eDebug("couldn't open /proc/stb/misc/12V_output");
+		eDebug("couldn't open /usr/local/e2/etc/stb/misc/12V_output");
 		return false;
 	}
 	close(fd);
diff -Naur enigma2.ori/lib/driver/rcconsole.cpp enigma2/lib/driver/rcconsole.cpp
--- enigma2.ori/lib/driver/rcconsole.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/driver/rcconsole.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -111,4 +111,7 @@
 	}
 };
 
+#ifndef WITH_XLIB
 eAutoInitP0<eRCConsoleInit> init_rcconsole(eAutoInitNumbers::rc+1, "Console RC Driver");
+#endif
+
diff -Naur enigma2.ori/lib/driver/rcinput.cpp enigma2/lib/driver/rcinput.cpp
--- enigma2.ori/lib/driver/rcinput.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/driver/rcinput.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -175,4 +175,7 @@
 	}
 };
 
+#ifndef WITH_XLIB
 eAutoInitP0<eInputDeviceInit> init_rcinputdev(eAutoInitNumbers::rc+1, "input device driver");
+#endif
+
diff -Naur enigma2.ori/lib/driver/rcsdl.cpp enigma2/lib/driver/rcsdl.cpp
--- enigma2.ori/lib/driver/rcsdl.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/driver/rcsdl.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -1,4 +1,3 @@
-#include <lib/base/etrace.h>
 #include <lib/driver/rcsdl.h>
 //#include <lib/actions/action.h>
 #include <lib/base/init.h>
@@ -19,8 +18,6 @@
 
 void eSDLInputDevice::handleCode(long arg)
 {
-	D_ENTER();
-
 	const SDL_KeyboardEvent *event = (const SDL_KeyboardEvent *)arg;
 	const SDL_keysym *key = &event->keysym;
 	int km = input->getKeyboardMode();
@@ -35,13 +32,10 @@
 
 	if (km == eRCInput::kmNone) {
 		code = translateKey(key->sym);
-		D_PRINT("translated code: %d", code);
 	} else {
 		code = m_unicode;
-		D_PRINT("native virtual code: %d / sym: %d", code, key->sym);
 		if ((code == 0) && (key->sym < 128)) {
 			code = key->sym;
-			D_PRINT("ASCII code: %u", code);
 		}
 
 		if ((km == eRCInput::kmAscii) &&
@@ -53,14 +47,14 @@
 		} else {
 			// ASCII keys should only generate key press events
 			if (flags == eRCKey::flagBreak)
-				D_RETURN();
+				return;
 
 			if (km == eRCInput::kmAscii) {
 				// skip ESC c or ESC '[' c
 				if (m_escape) {
 					if (code != '[')
 						m_escape = false;
-					D_RETURN();
+					return;
 				}
 				if (code == SDLK_ESCAPE)
 					m_escape = true;
@@ -69,9 +63,7 @@
 		}
 	}
 
-	D_PRINT("code=%d (%#x) flags=%d (%#x)", code, code, flags, flags);
 	input->keyPressed(eRCKey(this, code, flags));
-	D_RETURN();
 }
 
 const char *eSDLInputDevice::getDescription() const
diff -Naur enigma2.ori/lib/driver/rcxlib.cpp enigma2/lib/driver/rcxlib.cpp
--- enigma2.ori/lib/driver/rcxlib.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/driver/rcxlib.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,224 @@
+#include <lib/driver/rcxlib.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+#include <lib/driver/input_fake.h>
+
+/*
+ * eXlibInputDevice
+ */
+
+eXlibInputDevice::eXlibInputDevice(eRCDriver *driver) : eRCDevice("Xlib", driver), m_escape(false), m_unicode(0)
+{
+}
+
+eXlibInputDevice::~eXlibInputDevice()
+{
+}
+
+void eXlibInputDevice::handleCode(long arg)
+{
+	const XKeyEvent* event = (const XKeyEvent*)arg;
+	int km = input->getKeyboardMode();
+	int code, flags;
+
+	if (event->type == KeyPress) {
+		//m_unicode = key->unicode;
+		flags = eRCKey::flagMake;
+	} else {
+		flags = eRCKey::flagBreak;
+	}
+
+	if (1/*km == eRCInput::kmNone*/) {
+		//eDebug("eRCInput::kmNone\n");
+		code = translateKey(event->keycode);
+	} else {
+		eDebug("eRCInput::kmNone NO\n");
+		// ASCII keys should only generate key press events
+		if (flags == eRCKey::flagBreak)
+			return;
+
+		/*eDebug("unicode=%04x scancode=%02x", m_unicode, key->scancode);
+		if (m_unicode & 0xff80) {
+			eDebug("SDL: skipping unicode character");
+			return;
+		}
+		code = m_unicode & ~0xff80;
+		// unicode not set...!? use key symbol
+		if (code == 0) {
+			// keysym is ascii
+			if (key >= 128) {
+				eDebug("SDL: cannot emulate ASCII");
+				return;
+			}
+			eDebug("SDL: emulate ASCII");
+			code = key;
+		}
+		if (km == eRCInput::kmAscii) {
+			// skip ESC c or ESC '[' c
+			if (m_escape) {
+				if (code != '[')
+					m_escape = false;
+				return;
+			}
+
+			if (code == SDLK_ESCAPE)
+				m_escape = true;
+
+			if ((code < SDLK_SPACE) ||
+			    (code == 0x7e) ||	// really?
+			    (code == SDLK_DELETE))
+				return;
+		}*/
+		flags |= eRCKey::flagAscii;
+	}
+
+	//eDebug("SDL code=%d flags=%d", code, flags);
+	input->keyPressed(eRCKey(this, code, flags));
+}
+
+const char *eXlibInputDevice::getDescription() const
+{
+	return "Xlib";
+}
+
+int eXlibInputDevice::translateKey(int key)
+{
+
+	switch (key) {
+	case 9:
+		return KEY_ESC;
+
+
+	case 10:
+		return KEY_1;
+	case 11:
+		return KEY_2;
+	case 12:
+		return KEY_3;
+	case 13:
+		return KEY_4;
+	case 14:
+		return KEY_5;
+	case 15:
+		return KEY_6;
+	case 16:
+		return KEY_7;
+	case 17:
+		return KEY_8;
+	case 18:
+		return KEY_9;
+	case 19:
+		return KEY_0;
+
+	case 26: // E
+		return KEY_EPG;
+
+	case 27: // R
+		return KEY_RECORD;
+	case 28: // T
+		return KEY_TV;
+
+	case 31: // I
+		return KEY_INFO;
+
+	case 33: // P
+		return KEY_PLAYPAUSE;
+
+	case 36:
+		return KEY_OK;
+
+	case 38: // A
+		return KEY_AUDIO;
+
+	case 55: // V
+		return KEY_VIDEO;
+
+
+	case 111:
+		return KEY_UP;
+	case 113:
+		return KEY_LEFT;
+	case 114:
+		return KEY_RIGHT;
+	case 116:
+		return KEY_DOWN;
+
+	case 58: // M
+		return KEY_MUTE;
+
+	case 65:
+		return KEY_MENU;
+
+
+	case 67:
+		return KEY_RED;
+	case 68:
+		return KEY_GREEN;
+	case 69:
+		return KEY_YELLOW;
+	case 70:
+		return KEY_BLUE;
+
+
+	case 82: // -
+		return KEY_VOLUMEDOWN;
+	case 86: // +
+		return KEY_VOLUMEUP;
+
+	case 112: // Page Up
+		return KEY_CHANNELUP;
+	case 117: // Page Down
+		return KEY_CHANNELDOWN;
+
+	default:
+		eDebug("unhandled KEYBOARD keycode: %d", key);
+		return KEY_RESERVED;
+	}
+
+}
+
+/*
+ * eXlibInputDriver
+ */
+
+eXlibInputDriver *eXlibInputDriver::instance;
+
+eXlibInputDriver::eXlibInputDriver() : eRCDriver(eRCInput::getInstance())
+{
+	ASSERT(instance == 0);
+	instance = this;
+}
+
+eXlibInputDriver::~eXlibInputDriver()
+{
+	instance = 0;
+}
+
+void eXlibInputDriver::keyPressed(const XKeyEvent &keyEvent)
+{
+	/*eDebug("km=%d enabled=%d locked=%d",
+		input->getKeyboardMode(), enabled, input->islocked());*/
+
+	if (!enabled || input->islocked())
+		return;
+
+	std::list<eRCDevice*>::iterator i(listeners.begin());
+	while (i != listeners.end()) {
+		(*i)->handleCode((long)&keyEvent);
+		++i;
+	}
+}
+
+class eRCXlibInit
+{
+private:
+	eXlibInputDriver driver;
+	eXlibInputDevice device;
+
+public:
+	eRCXlibInit(): driver(), device(&driver)
+	{
+	}
+};
+
+eAutoInitP0<eRCXlibInit> init_rcXlib(eAutoInitNumbers::rc+1, "Xlib RC Driver");
diff -Naur enigma2.ori/lib/driver/rcxlib.h enigma2/lib/driver/rcxlib.h
--- enigma2.ori/lib/driver/rcxlib.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/driver/rcxlib.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,35 @@
+#ifndef __lib_driver_rcxlib_h
+#define __lib_driver_rcxlib_h
+
+#include <lib/driver/rc.h>
+#include <X11/Xlib.h>
+
+class eXlibInputDevice : public eRCDevice
+{
+private:
+	bool m_escape;
+	unsigned int m_unicode;
+	int translateKey(int key);
+
+public:
+	eXlibInputDevice(eRCDriver *driver);
+	~eXlibInputDevice();
+
+	virtual void handleCode(long arg);
+	virtual const char *getDescription() const;
+};
+
+class eXlibInputDriver : public eRCDriver
+{
+private:
+	static eXlibInputDriver *instance;
+
+public:
+	eXlibInputDriver();
+	~eXlibInputDriver();
+
+	static eXlibInputDriver *getInstance() { return instance; }
+	void keyPressed(const XKeyEvent &keyEvent);
+};
+
+#endif
diff -Naur enigma2.ori/lib/dvb/Makefile.am enigma2/lib/dvb/Makefile.am
--- enigma2.ori/lib/dvb/Makefile.am	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/Makefile.am	2011-12-16 06:15:29.000000000 +0100
@@ -33,7 +33,9 @@
 	subtitle.cpp \
 	teletext.cpp \
 	tstools.cpp \
-	volume.cpp
+	volume.cpp \
+	ca_connector.cpp \
+	decsa.cpp
 
 dvbincludedir = $(pkgincludedir)/lib/dvb
 dvbinclude_HEADERS = \
@@ -67,4 +69,6 @@
 	subtitle.h \
 	teletext.h \
 	tstools.h \
-	volume.h
+	volume.h \
+	ca_connector.h \
+	decsa.h
diff -Naur enigma2.ori/lib/dvb/ca_connector.cpp enigma2/lib/dvb/ca_connector.cpp
--- enigma2.ori/lib/dvb/ca_connector.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/dvb/ca_connector.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,122 @@
+#include <lib/dvb/ca_connector.h>
+#include <lib/dvb/dvb.h>
+#include <lib/actions/action.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+
+caConnector *caConnector::instance;
+
+DEFINE_REF(caConnector)
+
+caConnector::caConnector()
+{
+	int family;
+	struct nl_msg *msg;
+	
+	sock = nl_socket_alloc();
+	genl_connect(sock);
+
+	family = genl_ctrl_resolve(sock, "CA_SEND");
+	if (family<0) {
+		eDebug("Cannot resolve family name of generic netlink socket");
+		return;
+	}
+
+	ca_policy[ATTR_CA_SIZE].type = NLA_U32;
+	ca_policy[ATTR_CA_NUM].type = NLA_U16;
+	ca_policy[ATTR_CA_DESCR].type = NLA_UNSPEC;
+	ca_policy[ATTR_CA_PID].type = NLA_UNSPEC;
+
+	ASSERT(instance == 0);
+	instance = this;
+
+	msg = nlmsg_alloc();
+	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, NLM_F_ECHO,
+			CMD_ASK_CA_SIZE, 1);
+	nl_send_auto_complete(sock, msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_recvmsgs_default(sock);
+	nlmsg_free(msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_socket_disable_seq_check(sock);
+
+	run();
+}
+
+caConnector::~caConnector()
+{
+	instance = 0;
+	kill(true);
+
+	nl_close(sock);
+	nl_socket_free(sock);
+}
+
+void caConnector::thread()
+{
+	hasStarted();
+
+	while (1) {
+		nl_recvmsgs_default(sock);
+	}
+}
+
+int caConnector::parse_cb(struct nl_msg *msg, void *arg) {
+	caConnector *connector = caConnector::getInstance();
+	ePtr<eDVBResourceManager> res_mgr;
+	int ret;
+
+	eDVBResourceManager::getInstance(res_mgr);
+	if (!res_mgr) {
+		eDebug("no resource manager !!!!!!!");
+		return -1;
+	}
+
+	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+	struct nlattr *attrs[ATTR_MAX+1];
+
+	genlmsg_parse(nlh, 0, attrs, ATTR_MAX, connector->ca_policy);
+
+	if (attrs[ATTR_CA_SIZE]) {
+		uint32_t value = nla_get_u32(attrs[ATTR_CA_SIZE]);
+		connector->ca_size = value;
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_DESCR]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_descr_t *ca = (ca_descr_t*)nla_data(attrs[ATTR_CA_DESCR]);
+		eDebug("CA_SET_DESCR ca_num %04X, idx %d, parity %d, cw %02X...%02X", ca_num, ca->index,
+				ca->parity, ca->cw[0], ca->cw[7]);
+
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaDescr(ca,0)) {
+			eDebug("CA_SET_DESCR failed (%s). Expect a black screen.",strerror(errno));
+		}
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_PID]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_pid_t *ca_pid = (ca_pid_t*)nla_data(attrs[ATTR_CA_PID]);
+
+		eDebug("CA_PID ca_num %04X, pid %04X, index %d", ca_num, ca_pid->pid, ca_pid->index);
+		
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaPid(ca_pid)) {
+			eDebug("CA_SET_PID failed");
+		}
+	}
+
+	return 0;
+}
+
+eAutoInitPtr<caConnector> init_caConnector(eAutoInitNumbers::dvb-1, "caConnector");
diff -Naur enigma2.ori/lib/dvb/ca_connector.h enigma2/lib/dvb/ca_connector.h
--- enigma2.ori/lib/dvb/ca_connector.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/dvb/ca_connector.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,50 @@
+#ifndef __lib_dvb_ca_connector_h
+#define __lib_dvb_ca_connector_h
+
+#include <linux/dvb/ca.h>
+#include <lib/base/thread.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+
+#include <lib/gdi/gmaindc.h>
+#include <lib/dvb/idvb.h>
+
+// attributes
+enum {
+	ATTR_UNSPEC,
+	ATTR_CA_SIZE,
+	ATTR_CA_NUM,
+	ATTR_CA_DESCR,
+	ATTR_CA_PID,
+        __ATTR_MAX,
+};
+#define ATTR_MAX (__ATTR_MAX - 1)
+
+// commands
+enum {
+	CMD_UNSPEC,
+	CMD_ASK_CA_SIZE,
+	CMD_SET_CW,
+	CMD_SET_PID,
+	CMD_MAX,
+};
+
+class caConnector: public eThread, public Object
+{
+	DECLARE_REF(caConnector);
+private:
+	int ca_size;
+	struct nla_policy ca_policy[ATTR_MAX + 1];
+	struct nl_sock *sock;
+	static caConnector *instance;
+
+	virtual void thread();
+	static int parse_cb(struct nl_msg *msg, void *arg);
+	static caConnector *getInstance() { return instance; }
+public:
+	caConnector();
+	~caConnector();
+};
+
+#endif
diff -Naur enigma2.ori/lib/dvb/db.cpp enigma2/lib/dvb/db.cpp
--- enigma2.ori/lib/dvb/db.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/db.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -803,18 +803,13 @@
 		return NULL;
 	}
 	XMLTree tree;
-	const char* satellitesFilename = "/etc/enigma2/satellites.xml";
-	struct stat stat_dummy;
-	if (stat(satellitesFilename, &stat_dummy) != 0)
-	{
-		satellitesFilename = "/etc/tuxbox/satellites.xml";
-	}
-	tree.setFilename(satellitesFilename);
+	std::string filename = eEnv::resolve("${sysconfdir}/tuxbox/satellites.xml");
+	tree.setFilename(filename.c_str());
 	tree.read();
 	Element *root = tree.getRoot();
 	if (!root)
 	{
-		eDebug("couldn't open /etc/tuxbox/satellites.xml!!");
+		eDebug("couldn't open %s!!", filename.c_str());
 		Py_INCREF(Py_False);
 		return Py_False;
 	}
@@ -963,12 +958,13 @@
 		return NULL;
 	}
 	XMLTree tree;
-	tree.setFilename("/etc/tuxbox/cables.xml");
+	std::string filename = eEnv::resolve("${sysconfdir}/tuxbox/cables.xml");
+	tree.setFilename(filename.c_str());
 	tree.read();
 	Element *root = tree.getRoot();
 	if (!root)
 	{
-		eDebug("couldn't open /etc/tuxbox/cables.xml!!");
+		eDebug("couldn't open %s!!", filename.c_str());
 		Py_INCREF(Py_False);
 		return Py_False;
 	}
@@ -1077,12 +1073,13 @@
 		return NULL;
 	}
 	XMLTree tree;
-	tree.setFilename("/etc/tuxbox/terrestrial.xml");
+	std::string filename = eEnv::resolve("${sysconfdir}/tuxbox/terrestrial.xml");
+	tree.setFilename(filename.c_str());
 	tree.read();
 	Element *root = tree.getRoot();
 	if (!root)
 	{
-		eDebug("couldn't open /etc/tuxbox/terrestrial.xml!!");
+		eDebug("couldn't open %s!!", filename.c_str());
 		Py_INCREF(Py_False);
 		return Py_False;
 	}
diff -Naur enigma2.ori/lib/dvb/decoder.cpp enigma2/lib/dvb/decoder.cpp
--- enigma2.ori/lib/dvb/decoder.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/decoder.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -1,32 +1,7 @@
 #include <lib/base/ebase.h>
 #include <lib/base/eerror.h>
 #include <lib/dvb/decoder.h>
-#include <lib/components/tuxtxtapp.h>
-#if HAVE_DVB_API_VERSION < 3 
-#define audioStatus audio_status
-#define videoStatus video_status
-#define pesType pes_type
-#define playState play_state
-#define audioStreamSource_t audio_stream_source_t
-#define videoStreamSource_t video_stream_source_t
-#define streamSource stream_source
-#define dmxPesFilterParams dmx_pes_filter_params
-#define DMX_PES_VIDEO0 DMX_PES_VIDEO
-#define DMX_PES_AUDIO0 DMX_PES_AUDIO
-#define DMX_PES_PCR0 DMX_PES_PCR
-#define DMX_PES_TELETEXT0 DMX_PES_TELETEXT
-#define DMX_PES_VIDEO1 DMX_PES_VIDEO
-#define DMX_PES_AUDIO1 DMX_PES_AUDIO
-#define DMX_PES_PCR1 DMX_PES_PCR
-#define DMX_PES_TELETEXT1 DMX_PES_TELETEXT
-#include <ost/dmx.h>
-#include <ost/video.h>
-#include <ost/audio.h>
-#else
-#include <linux/dvb/audio.h>
-#include <linux/dvb/video.h>
-#include <linux/dvb/dmx.h>
-#endif
+#include <lib/gdi/xineLib.h>
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -35,165 +10,39 @@
 #include <sys/stat.h>
 #include <errno.h>
 
-	/* these are quite new... */
-#ifndef AUDIO_GET_PTS
-#define AUDIO_GET_PTS              _IOR('o', 19, __u64)
-#define VIDEO_GET_PTS              _IOR('o', 57, __u64)
-#endif
 
 DEFINE_REF(eDVBAudio);
 
-eDVBAudio::eDVBAudio(eDVBDemux *demux, int dev)
-	:m_demux(demux), m_dev(dev)
-{
-	char filename[128];
-#if HAVE_DVB_API_VERSION < 3
-	sprintf(filename, "/dev/dvb/card%d/audio%d", demux->adapter, dev);
-#else
-	sprintf(filename, "/dev/dvb/adapter%d/audio%d", demux->adapter, dev);
-#endif
-	m_fd = ::open(filename, O_RDWR);
-	if (m_fd < 0)
-		eWarning("%s: %m", filename);
-#if HAVE_DVB_API_VERSION < 3
-	sprintf(filename, "/dev/dvb/card%d/demux%d", demux->adapter, demux->demux);
-#else
-	sprintf(filename, "/dev/dvb/adapter%d/demux%d", demux->adapter, demux->demux);
-#endif
-	m_fd_demux = ::open(filename, O_RDWR);
-	if (m_fd_demux < 0)
-		eWarning("%s: %m", filename);
-}
+eDVBAudio::eDVBAudio(int dev) : m_dev(dev) {}
 
-#if HAVE_DVB_API_VERSION < 3
-int eDVBAudio::setPid(int pid, int type)
-{
-	if ((m_fd < 0) || (m_fd_demux < 0))
-		return -1;
+#define STREAM_SPU_BITMAP_HDMV   0x90
+#define ISO_13818_AUDIO          0x04
+#define STREAM_VIDEO_VC1         0xea    /* VC-1 Video */
+#define HDMV_AUDIO_80_PCM        0x80 /* BluRay PCM */
+#define STREAM_AUDIO_AC3         0x81
+#define HDMV_AUDIO_82_DTS        0x82 /* DTS */
+#define HDMV_AUDIO_83_TRUEHD     0x83 /* Dolby TrueHD, primary audio */
+#define HDMV_AUDIO_84_EAC3       0x84 /* Dolby Digital plus, primary audio */
+#define HDMV_AUDIO_85_DTS_HRA    0x85 /* DTS-HRA */
+#define HDMV_AUDIO_86_DTS_HD_MA  0x86 /* DTS-HD Master audio */
 
-	int bypass = 0;
-
-	switch (type)
-	{
-	case aMPEG:
-		bypass = 1;
-		break;
-	case aAC3:
-		bypass = 0;
-		break;
-		/*
-	case aDTS:
-		bypass = 2;
-		break;
-		*/
-	}
-
-	if (::ioctl(m_fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
-		eDebug("failed (%m)");
 
-	dmx_pes_filter_params pes;
-
-	pes.pid      = pid;
-	pes.input    = DMX_IN_FRONTEND;
-	pes.output   = DMX_OUT_DECODER;
-	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
-	pes.flags    = 0;
-	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
-	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-
-	return 0;
-}
-
-int eDVBAudio::startPid()
-{
-	eDebugNoNewLine("DEMUX_START - audio - ");
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
-
-int eDVBAudio::start()
-{
-	eDebugNoNewLine("AUDIO_PLAY - ");
-	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
-
-int eDVBAudio::stopPid()
-{
-	eDebugNoNewLine("DEMUX_STOP - audio - ");
-	if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
-
-int eDVBAudio::setAVSync(int val)
-{
-	eDebugNoNewLine("AUDIO_SET_AV_SYNC - ");
-	if (::ioctl(m_fd, AUDIO_SET_AV_SYNC, val) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
-#else
 int eDVBAudio::startPid(int pid, int type)
 {
-	if ((m_fd < 0) || (m_fd_demux < 0))
-		return -1;
-	dmx_pes_filter_params pes;
+	cXineLib *xineLib = cXineLib::getInstance();
 
-	pes.pid      = pid;
-	pes.input    = DMX_IN_FRONTEND;
-	pes.output   = DMX_OUT_DECODER;
-	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
-	pes.flags    = 0;
-	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
-	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	eDebugNoNewLine("DEMUX_START - audio - ");
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
 	int bypass = 0;
 
 	switch (type)
 	{
 	case aMPEG:
-		bypass = 1;
+		bypass = ISO_13818_AUDIO;
 		break;
 	case aAC3:
-		bypass = 0;
+		bypass = STREAM_AUDIO_AC3;
 		break;
 	case aDTS:
-		bypass = 2;
+		bypass = HDMV_AUDIO_82_DTS;
 		break;
 	case aAAC:
 		bypass = 8;
@@ -202,215 +51,90 @@
 		bypass = 9;
 		break;
 	case aLPCM:
-		bypass = 6;
+		bypass = HDMV_AUDIO_80_PCM;
 		break;
 	case aDTSHD:
-		bypass = 0x10;
+		bypass = HDMV_AUDIO_86_DTS_HD_MA;
 		break;
 	case aDDP:
 		bypass = 0x22;
 		break;
 	}
-
-	eDebugNoNewLine("AUDIO_SET_BYPASS(%d) - ", bypass);
-	if (::ioctl(m_fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
-	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
-	eDebugNoNewLine("AUDIO_PLAY - ");
-	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	xineLib->setAudioType(pid, bypass);
+	xineLib->playVideo();
 	return 0;
 }
-#endif
+
 
 void eDVBAudio::stop()
 {
-	eDebugNoNewLine("AUDIO_STOP - ");
-	if (::ioctl(m_fd, AUDIO_STOP) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
-#if HAVE_DVB_API_VERSION > 2
-	eDebugNoNewLine("DEMUX_STOP - audio - ");
-	if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
-#endif
+	eDebug("AUDIO_STOP");
 }
 
 void eDVBAudio::flush()
 {
-	eDebugNoNewLine("AUDIO_CLEAR_BUFFER - ");
-	if (::ioctl(m_fd, AUDIO_CLEAR_BUFFER) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	eDebug("AUDIO_CLEAR_BUFFER");
 }
 
 void eDVBAudio::freeze()
 {
-	eDebugNoNewLine("AUDIO_PAUSE - ");
-	if (::ioctl(m_fd, AUDIO_PAUSE) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	eDebug("AUDIO_PAUSE");
 }
 
 void eDVBAudio::unfreeze()
 {
-	eDebugNoNewLine("AUDIO_CONTINUE - ");
-	if (::ioctl(m_fd, AUDIO_CONTINUE) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	eDebug("AUDIO_CONTINUE");
 }
 
 void eDVBAudio::setChannel(int channel)
 {
-	int val = AUDIO_STEREO;
-	switch (channel)
+	int val = 0;//AUDIO_STEREO;
+	/*switch (channel)
 	{
-	case aMonoLeft: val = AUDIO_MONO_LEFT; break;
-	case aMonoRight: val = AUDIO_MONO_RIGHT; break;
-	default: break;
-	}
-	eDebugNoNewLine("AUDIO_CHANNEL_SELECT(%d) - ", val);
-	if (::ioctl(m_fd, AUDIO_CHANNEL_SELECT, val) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	case aMonoLeft:
+		val = AUDIO_MONO_LEFT;
+		break;
+	case aMonoRight:
+		val = AUDIO_MONO_RIGHT;
+		break;
+	default:
+		break;
+	}*/
+	eDebug("AUDIO_CHANNEL_SELECT(%d)", val);
 }
 
 int eDVBAudio::getPTS(pts_t &now)
 {
-	if (::ioctl(m_fd, AUDIO_GET_PTS, &now) < 0)
-		eDebug("AUDIO_GET_PTS failed (%m)");
+	cXineLib *xineLib = cXineLib::getInstance();
+	//if (xineLib->getPTS(now) < 0)
+	//	eDebug("AUDIO_GET_PTS failed (%m)");
 	return 0;
 }
 
 eDVBAudio::~eDVBAudio()
 {
 	unfreeze();  // why unfreeze here... but not unfreeze video in ~eDVBVideo ?!?
-	if (m_fd >= 0)
-		::close(m_fd);
-	if (m_fd_demux >= 0)
-		::close(m_fd_demux);
+
 }
 
 DEFINE_REF(eDVBVideo);
 
-eDVBVideo::eDVBVideo(eDVBDemux *demux, int dev)
-	: m_demux(demux), m_dev(dev),
-	m_width(-1), m_height(-1), m_framerate(-1), m_aspect(-1), m_progressive(-1)
-{
-	char filename[128];
-#if HAVE_DVB_API_VERSION < 3
-	sprintf(filename, "/dev/dvb/card%d/video%d", demux->adapter, dev);
-	m_fd_video = ::open("/dev/video", O_RDWR);
-	if (m_fd_video < 0)
-		eWarning("/dev/video: %m");
-#else
-	sprintf(filename, "/dev/dvb/adapter%d/video%d", demux->adapter, dev);
-#endif
-	m_fd = ::open(filename, O_RDWR);
-	if (m_fd < 0)
-		eWarning("%s: %m", filename);
-	else
-	{
-		m_sn = eSocketNotifier::create(eApp, m_fd, eSocketNotifier::Priority);
-		CONNECT(m_sn->activated, eDVBVideo::video_event);
-	}
-	eDebug("Video Device: %s", filename);
-#if HAVE_DVB_API_VERSION < 3
-	sprintf(filename, "/dev/dvb/card%d/demux%d", demux->adapter, demux->demux);
-#else
-	sprintf(filename, "/dev/dvb/adapter%d/demux%d", demux->adapter, demux->demux);
-#endif
-	m_fd_demux = ::open(filename, O_RDWR);
-	if (m_fd_demux < 0)
-		eWarning("%s: %m", filename);
-	eDebug("demux device: %s", filename);
-}
+eDVBVideo::eDVBVideo(int dev) : m_dev(dev), m_progressive(-1) {}
 
 // not finally values i think.. !!
-#define VIDEO_STREAMTYPE_MPEG2 0
-#define VIDEO_STREAMTYPE_MPEG4_H264 1
-#define VIDEO_STREAMTYPE_VC1 3
-#define VIDEO_STREAMTYPE_MPEG4_Part2 4
-#define VIDEO_STREAMTYPE_VC1_SM 5
-#define VIDEO_STREAMTYPE_MPEG1 6
-
-#if HAVE_DVB_API_VERSION < 3
-int eDVBVideo::setPid(int pid)
-{
-	if ((m_fd < 0) || (m_fd_demux < 0))
-		return -1;
-	dmx_pes_filter_params pes;
-
-	pes.pid      = pid;
-	pes.input    = DMX_IN_FRONTEND;
-	pes.output   = DMX_OUT_DECODER;
-	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
-	pes.flags    = 0;
-	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
-	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
-
-int eDVBVideo::startPid()
-{
-	eDebugNoNewLine("DEMUX_START - video - ");
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
+#define VIDEO_STREAMTYPE_MPEG2       0x02
+#define VIDEO_STREAMTYPE_MPEG4_H264  0x1B
+#define VIDEO_STREAMTYPE_VC1         0xEA
+#define VIDEO_STREAMTYPE_MPEG4_Part2 0x10
+#define VIDEO_STREAMTYPE_VC1_SM      0xEA
+#define VIDEO_STREAMTYPE_MPEG1       0x01
 
-int eDVBVideo::start()
-{
-	eDebugNoNewLine("VIDEO_PLAY - ");
-	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
 
-int eDVBVideo::stopPid()
-{
-	eDebugNoNewLine("DEMUX_STOP - video - ");
-	if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
-#else
 int eDVBVideo::startPid(int pid, int type)
 {
+	cXineLib *xineLib = cXineLib::getInstance();
 	int streamtype = VIDEO_STREAMTYPE_MPEG2;
 
-	if ((m_fd < 0) || (m_fd_demux < 0))
-		return -1;
-	dmx_pes_filter_params pes;
-
 	switch(type)
 	{
 	default:
@@ -433,153 +157,82 @@
 		break;
 	}
 
-	eDebugNoNewLine("VIDEO_SET_STREAMTYPE %d - ", streamtype);
-	if (::ioctl(m_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	eDebug("VIDEO_SET_STREAMTYPE %d", streamtype);
+
+	xineLib->setVideoType(pid, streamtype);
+
+	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in 
+	eDebug("VIDEO_PLAY\n");
+
+	xineLib->playVideo();
 
-	pes.pid      = pid;
-	pes.input    = DMX_IN_FRONTEND;
-	pes.output   = DMX_OUT_DECODER;
-	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
-	pes.flags    = 0;
-	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
-	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	eDebugNoNewLine("DEMUX_START - video - ");
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
-	eDebugNoNewLine("VIDEO_PLAY - ");
-	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
 	return 0;
 }
-#endif
 
 void eDVBVideo::stop()
 {
-#if HAVE_DVB_API_VERSION > 2
-	eDebugNoNewLine("DEMUX_STOP - video - ");
-	if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
-#endif
-	eDebugNoNewLine("VIDEO_STOP - ");
-	if (::ioctl(m_fd, VIDEO_STOP, 1) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->stopVideo();
 }
 
 void eDVBVideo::flush()
 {
-	eDebugNoNewLine("VIDEO_CLEAR_BUFFER - ");
-	if (::ioctl(m_fd, VIDEO_CLEAR_BUFFER) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	eDebug("VIDEO_CLEAR_BUFFER");
 }
 
 void eDVBVideo::freeze()
 {
-	eDebugNoNewLine("VIDEO_FREEZE - ");
-	if (::ioctl(m_fd, VIDEO_FREEZE) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoPause();
+	eDebug("VIDEO_FREEZE");
 }
 
 void eDVBVideo::unfreeze()
 {
-	eDebugNoNewLine("VIDEO_CONTINUE - ");
-	if (::ioctl(m_fd, VIDEO_CONTINUE) < 0)
-		eDebug("failed (%m)");
-	else
-		eDebug("ok");
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoResume();
+	eDebug("VIDEO_CONTINUE");
 }
 
 int eDVBVideo::setSlowMotion(int repeat)
 {
-	eDebugNoNewLine("VIDEO_SLOWMOTION(%d) - ", repeat);
-	int ret = ::ioctl(m_fd, VIDEO_SLOWMOTION, repeat);
-	if (ret < 0)
-		eDebug("failed(%m)");
-	else
-		eDebug("ok");
+	eDebug("VIDEO_SLOWMOTION(%d)", repeat);
+	int ret = 0;
+
 	return ret;
 }
 
 int eDVBVideo::setFastForward(int skip)
 {
-	eDebugNoNewLine("VIDEO_FAST_FORWARD(%d) - ", skip);
-	int ret = ::ioctl(m_fd, VIDEO_FAST_FORWARD, skip);
-	if (ret < 0)
-		eDebug("failed(%m)");
-	else
-		eDebug("ok");
+	eDebug("VIDEO_FAST_FORWARD(%d)", skip);
+	int ret = 0;
+
 	return ret;
 }
 
 int eDVBVideo::getPTS(pts_t &now)
 {
-#if HAVE_DVB_API_VERSION < 3
-	#define VIDEO_GET_PTS_OLD           _IOR('o', 1, unsigned int*)
-	unsigned int pts;
-	int ret = ::ioctl(m_fd_video, VIDEO_GET_PTS_OLD, &pts);
-	now = pts;
-	now *= 2;
-#else
-	int ret = ::ioctl(m_fd, VIDEO_GET_PTS, &now);
-#endif
+	cXineLib *xineLib = cXineLib::getInstance();
+
+	int ret = 0;//xineLib->getPTS(now);
+	now = 0;
+
 	if (ret < 0)
 		eDebug("VIDEO_GET_PTS failed(%m)");
 	return ret;
 }
 
-eDVBVideo::~eDVBVideo()
-{
-	if (m_fd >= 0)
-		::close(m_fd);
-	if (m_fd_demux >= 0)
-		::close(m_fd_demux);
-#if HAVE_DVB_API_VERSION < 3
-	if (m_fd_video >= 0)
-		::close(m_fd_video);
-#endif
-}
+eDVBVideo::~eDVBVideo() {}
 
 void eDVBVideo::video_event(int)
 {
-#if HAVE_DVB_API_VERSION >= 3
 	struct video_event evt;
-	eDebugNoNewLine("VIDEO_GET_EVENT - ");
+	eDebug("VIDEO_GET_EVENT");
+#if 0
 	if (::ioctl(m_fd, VIDEO_GET_EVENT, &evt) < 0)
 		eDebug("failed (%m)");
 	else
 	{
-		eDebug("ok");
-		if (evt.type == VIDEO_EVENT_SIZE_CHANGED)
-		{
-			struct iTSMPEGDecoder::videoEvent event;
-			event.type = iTSMPEGDecoder::videoEvent::eventSizeChanged;
-			m_aspect = event.aspect = evt.u.size.aspect_ratio == 0 ? 2 : 3;  // convert dvb api to etsi
-			m_height = event.height = evt.u.size.h;
-			m_width = event.width = evt.u.size.w;
-			/* emit */ m_event(event);
-		}
 		else if (evt.type == VIDEO_EVENT_FRAME_RATE_CHANGED)
 		{
 			struct iTSMPEGDecoder::videoEvent event;
@@ -597,259 +250,43 @@
 		else
 			eDebug("unhandled DVBAPI Video Event %d", evt.type);
 	}
-#else
-#warning "FIXMEE!! Video Events not implemented for old api"
-#endif
-}
-
-RESULT eDVBVideo::connectEvent(const Slot1<void, struct iTSMPEGDecoder::videoEvent> &event, ePtr<eConnection> &conn)
-{
-	conn = new eConnection(this, m_event.connect(event));
-	return 0;
-}
-
-static int readMpegProc(const char *str, int decoder)
-{
-	int val = -1;
-	char tmp[64];
-	sprintf(tmp, "/proc/stb/vmpeg/%d/%s", decoder, str);
-	FILE *f = fopen(tmp, "r");
-	if (f)
-	{
-		fscanf(f, "%x", &val);
-		fclose(f);
-	}
-	return val;
-}
-
-static int readApiSize(int fd, int &xres, int &yres, int &aspect)
-{
-#if HAVE_DVB_API_VERSION >= 3
-	video_size_t size;
-	if (!::ioctl(fd, VIDEO_GET_SIZE, &size))
-	{
-		xres = size.w;
-		yres = size.h;
-		aspect = size.aspect_ratio == 0 ? 2 : 3;  // convert dvb api to etsi
-		return 0;
-	}
-//	eDebug("VIDEO_GET_SIZE failed (%m)");
-#endif
-	return -1;
-}
-
-static int readApiFrameRate(int fd, int &framerate)
-{
-#if HAVE_DVB_API_VERSION >= 3
-	unsigned int frate;
-	if (!::ioctl(fd, VIDEO_GET_FRAME_RATE, &frate))
-	{
-		framerate = frate;	
-		return 0;
-	}
-//	eDebug("VIDEO_GET_FRAME_RATE failed (%m)");
 #endif
-	return -1;
-}
-
-int eDVBVideo::getWidth()
-{
-	if (m_width == -1)
-		readApiSize(m_fd, m_width, m_height, m_aspect);
-	if (m_width == -1)
-		m_width = readMpegProc("xres", m_dev);
-	return m_width;
-}
-
-int eDVBVideo::getHeight()
-{
-	if (m_height == -1)
-		readApiSize(m_fd, m_width, m_height, m_aspect);
-	if (m_height == -1)
-		m_height = readMpegProc("yres", m_dev);
-	return m_height;
-}
-
-int eDVBVideo::getAspect()
-{
-	if (m_aspect == -1)
-		readApiSize(m_fd, m_width, m_height, m_aspect);
-	if (m_aspect == -1)
-		m_aspect = readMpegProc("aspect", m_dev);
-	return m_aspect;
-}
-
-int eDVBVideo::getProgressive()
-{
-	if (m_progressive == -1)
-		m_progressive = readMpegProc("progressive", m_dev);
-	return m_progressive;
-}
-
-int eDVBVideo::getFrameRate()
-{
-	if (m_framerate == -1)
-		readApiFrameRate(m_fd, m_framerate);
-	if (m_framerate == -1)
-		m_framerate = readMpegProc("framerate", m_dev);
-	return m_framerate;
 }
 
 DEFINE_REF(eDVBPCR);
 
-eDVBPCR::eDVBPCR(eDVBDemux *demux, int dev): m_demux(demux), m_dev(dev)
-{
-	char filename[128];
-#if HAVE_DVB_API_VERSION < 3
-	sprintf(filename, "/dev/dvb/card%d/demux%d", demux->adapter, demux->demux);
-#else
-	sprintf(filename, "/dev/dvb/adapter%d/demux%d", demux->adapter, demux->demux);
-#endif
-	m_fd_demux = ::open(filename, O_RDWR);
-	if (m_fd_demux < 0)
-		eWarning("%s: %m", filename);
-}
-
-#if HAVE_DVB_API_VERSION < 3
-int eDVBPCR::setPid(int pid)
-{
-	if (m_fd_demux < 0)
-		return -1;
-	dmx_pes_filter_params pes;
-
-	pes.pid      = pid;
-	pes.input    = DMX_IN_FRONTEND;
-	pes.output   = DMX_OUT_DECODER;
-	pes.pes_type = DMX_PES_PCR;
-	pes.flags    = 0;
-
-	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
-	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
+eDVBPCR::eDVBPCR(int dev) : m_dev(dev) {}
 
-int eDVBPCR::startPid()
-{
-	if (m_fd_demux < 0)
-		return -1;
-	eDebugNoNewLine("DEMUX_START - pcr - ");
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	return 0;
-}
-#else
 int eDVBPCR::startPid(int pid)
 {
-	if (m_fd_demux < 0)
-		return -1;
-	dmx_pes_filter_params pes;
-
-	pes.pid      = pid;
-	pes.input    = DMX_IN_FRONTEND;
-	pes.output   = DMX_OUT_DECODER;
-	pes.pes_type = m_dev ? DMX_PES_PCR1 : DMX_PES_PCR0; /* FIXME */
-	pes.flags    = 0;
-	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
-	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	eDebugNoNewLine("DEMUX_START - pcr - ");
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebug("failed (%m)");
-		return -errno;
-	}
-	eDebug("ok");
+	eDebug("DEMUX_START - pcr");
 	return 0;
 }
-#endif
 
 void eDVBPCR::stop()
 {
-	eDebugNoNewLine("DEMUX_STOP - pcr - ");
-	if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-		eDebug("failed(%m)");
-	else
-		eDebug("ok");
+	eDebug("DEMUX_STOP - pcr");
 }
 
-eDVBPCR::~eDVBPCR()
-{
-	if (m_fd_demux >= 0)
-		::close(m_fd_demux);
-}
+eDVBPCR::~eDVBPCR() {}
 
 DEFINE_REF(eDVBTText);
 
-eDVBTText::eDVBTText(eDVBDemux *demux, int dev)
-    :m_demux(demux), m_dev(dev)
-{
-	char filename[128];
-#if HAVE_DVB_API_VERSION < 3
-	sprintf(filename, "/dev/dvb/card%d/demux%d", demux->adapter, demux->demux);
-#else
-	sprintf(filename, "/dev/dvb/adapter%d/demux%d", demux->adapter, demux->demux);
-#endif
-	m_fd_demux = ::open(filename, O_RDWR);
-	if (m_fd_demux < 0)
-		eWarning("%s: %m", filename);
-}
+eDVBTText::eDVBTText(int dev) : m_dev(dev) {}
 
 int eDVBTText::startPid(int pid)
 {
-	if (m_fd_demux < 0)
-		return -1;
-	dmx_pes_filter_params pes;
-
-	pes.pid      = pid;
-	pes.input    = DMX_IN_FRONTEND;
-	pes.output   = DMX_OUT_DECODER;
-	pes.pes_type = m_dev ? DMX_PES_TELETEXT1 : DMX_PES_TELETEXT0; // FIXME
-	pes.flags    = 0;
+	eDebug("DEMUX_START - ttx");
 
-	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - ttx - ", pid);
-	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
-	{
-		eDebug("failed(%m)");
-		return -errno;
-	}
-	eDebug("ok");
-	eDebugNoNewLine("DEMUX_START - ttx - ");
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebug("failed(%m)");
-		return -errno;
-	}
-	eDebug("ok");
 	return 0;
 }
 
 void eDVBTText::stop()
 {
-	eDebugNoNewLine("DEMUX_STOP - ttx - ");
-	if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-		eDebug("failed(%m)");
-	else
-		eDebug("ok");
+	eDebug("DEMUX_STOP - ttx");
 }
 
-eDVBTText::~eDVBTText()
-{
-	if (m_fd_demux >= 0)
-		::close(m_fd_demux);
-}
+eDVBTText::~eDVBTText() {}
 
 DEFINE_REF(eTSMPEGDecoder);
 
@@ -870,77 +307,7 @@
 	eDebug("decoder state: %s, vpid=%d, apid=%d", decoder_states[m_state], m_vpid, m_apid);
 
 	int changed = m_changed;
-#if HAVE_DVB_API_VERSION < 3
-	bool checkAVSync = m_changed & (changeAudio|changeVideo|changePCR);
-	if (m_changed & changeAudio && m_audio)
-		m_audio->stopPid();
-	if (m_changed & changeVideo && m_video)
-		m_video->stopPid();
-	if (m_changed & changePCR && m_pcr)
-	{
-		m_pcr->stop();
-		m_pcr=0;
-		if (!(m_pcrpid >= 0 && m_pcrpid < 0x1ff))
-			m_changed &= ~changePCR;
-	}
-	if (m_changed & changeAudio && m_audio)
-	{
-		m_audio->stop();
-		m_audio=0;
-		if (!(m_apid >= 0 && m_apid < 0x1ff))
-			m_changed &= ~changeAudio;
-	}
-	if (m_changed & changeVideo && m_video)
-	{
-		m_video->stop();
-		m_video=0;
-		m_video_event_conn=0;
-		if (!(m_vpid >= 0 && m_vpid < 0x1ff))
-			m_changed &= ~changeVideo;
-	}
-	if (m_changed & changeVideo)
-	{
-		m_video = new eDVBVideo(m_demux, m_decoder);
-		m_video->connectEvent(slot(*this, &eTSMPEGDecoder::video_event), m_video_event_conn);
-		if (m_video->setPid(m_vpid))
-			res -1;
-	}
-	if (m_changed & changePCR)
-	{
-		m_pcr = new eDVBPCR(m_demux, m_decoder);
-		if (m_pcr->setPid(m_pcrpid))
-			res = -1;
-	}
-	if (m_changed & changeAudio)
-	{
-		m_audio = new eDVBAudio(m_demux, m_decoder);
-		if (m_audio->setPid(m_apid, m_atype))
-			res = -1;
-	}
-	if (m_changed & changePCR)
-	{
-		if (m_pcr->startPid())
-			res = -1;
-		m_changed &= ~changePCR;
-	}
-	else if (checkAVSync && m_audio && m_video)
-	{
-		if (m_audio->setAVSync(1))
-			res = -1;
-	}
-	if (m_changed & changeVideo)
-	{
-		if (m_video->startPid() || m_video->start())
-			res = -1;
-		m_changed &= ~changeVideo;
-	}
-	if (m_changed & changeAudio)
-	{
-		if (m_audio->start() || m_audio->startPid())
-			res = -1;
-		m_changed &= ~changeAudio;
-	}
-#else
+
 	if (m_changed & changePCR)
 	{
 		if (m_pcr)
@@ -953,7 +320,6 @@
 		{
 			m_video->stop();
 			m_video = 0;
-			m_video_event_conn = 0;
 		}
 	}
 	if (m_changed & changeAudio)
@@ -967,8 +333,6 @@
 		if (m_text)
 		{
 			m_text->stop();
-			if ( m_decoder == 0 )	// Tuxtxt caching actions only on primary decoder
-				eTuxtxtApp::getInstance()->stopCaching();
 		}
 		m_text = 0;
 	}
@@ -976,7 +340,7 @@
 	{
 		if ((m_pcrpid >= 0) && (m_pcrpid < 0x1FFF))
 		{
-			m_pcr = new eDVBPCR(m_demux, m_decoder);
+			m_pcr = new eDVBPCR(m_decoder);
 			if (m_pcr->startPid(m_pcrpid))
 				res = -1;
 		}
@@ -986,7 +350,7 @@
 	{
 		if ((m_apid >= 0) && (m_apid < 0x1FFF) && !noaudio)
 		{
-			m_audio = new eDVBAudio(m_demux, m_decoder);
+			m_audio = new eDVBAudio(m_decoder);
 			if (m_audio->startPid(m_apid, m_atype))
 				res = -1;
 		}
@@ -996,8 +360,7 @@
 	{
 		if ((m_vpid >= 0) && (m_vpid < 0x1FFF))
 		{
-			m_video = new eDVBVideo(m_demux, m_decoder);
-			m_video->connectEvent(slot(*this, &eTSMPEGDecoder::video_event), m_video_event_conn);
+			m_video = new eDVBVideo(m_decoder);
 			if (m_video->startPid(m_vpid, m_vtype))
 				res = -1;
 		}
@@ -1007,23 +370,13 @@
 	{
 		if ((m_textpid >= 0) && (m_textpid < 0x1FFF) && !nott)
 		{
-			m_text = new eDVBTText(m_demux, m_decoder);
+			m_text = new eDVBTText(m_decoder);
 			if (m_text->startPid(m_textpid))
 				res = -1;
-
-			if ( m_decoder == 0 )	// Tuxtxt caching actions only on primary decoder
-			{
-				uint8_t demux = 0;
-				m_demux->getCADemuxID(demux);
-				eTuxtxtApp::getInstance()->startCaching(m_textpid, demux);
-			}
 		}
-		else if ( m_decoder == 0 )	// Tuxtxt caching actions only on primary decoder
-			eTuxtxtApp::getInstance()->resetPid();
-
 		m_changed &= ~changeText;
 	}
-#endif
+
 
 	if (changed & (changeState|changeVideo|changeAudio))
 	{
@@ -1070,7 +423,7 @@
 {
 	if (delay != m_pcm_delay )
 	{
-		FILE *fp = fopen("/proc/stb/audio/audio_delay_pcm", "w");
+		FILE *fp = fopen("/usr/local/e2/etc/stb/audio/audio_delay_pcm", "w");
 		if (fp)
 		{
 			fprintf(fp, "%x", delay*90);
@@ -1086,7 +439,7 @@
 {
 	if ( delay != m_ac3_delay )
 	{
-		FILE *fp = fopen("/proc/stb/audio/audio_delay_bitstream", "w");
+		FILE *fp = fopen("/usr/local/e2/etc/stb/audio/audio_delay_bitstream", "w");
 		if (fp)
 		{
 			fprintf(fp, "%x", delay*90);
@@ -1109,32 +462,16 @@
 	return m_decoder == 0 ? setHwAC3Delay(delay) : -1;
 }
 
-eTSMPEGDecoder::eTSMPEGDecoder(eDVBDemux *demux, int decoder)
-	: m_demux(demux), 
-		m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
-		m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp))
+eTSMPEGDecoder::eTSMPEGDecoder(int decoder)
+	: m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
+	  m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp))
 {
-	demux->connectEvent(slot(*this, &eTSMPEGDecoder::demux_event), m_demux_event_conn);
 	CONNECT(m_showSinglePicTimer->timeout, eTSMPEGDecoder::finishShowSinglePic);
 	m_state = stateStop;
-
-	char filename[128];
-#if HAVE_DVB_API_VERSION < 3
-	sprintf(filename, "/dev/dvb/card%d/audio%d", m_demux->adapter, m_decoder);
-#else
-	sprintf(filename, "/dev/dvb/adapter%d/audio%d", m_demux->adapter, m_decoder);
-#endif
-	m_has_audio = !access(filename, W_OK);
-
-	if ( m_decoder == 0 )	// Tuxtxt caching actions only on primary decoder
-		eTuxtxtApp::getInstance()->initCache();
 }
 
 eTSMPEGDecoder::~eTSMPEGDecoder()
 {
-	if ( m_decoder == 0 )	// Tuxtxt caching actions only on primary decoder
-		eTuxtxtApp::getInstance()->freeCache();
-
 	finishShowSinglePic();
 	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
 	m_changed = -1;
@@ -1143,6 +480,7 @@
 
 RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
 {
+printf("eTSMPEGDecoder setVideoPID %d\n", vpid);
 	if ((m_vpid != vpid) || (m_vtype != type))
 	{
 		m_changed |= changeVideo;
@@ -1154,9 +492,7 @@
 
 RESULT eTSMPEGDecoder::setAudioPID(int apid, int type)
 {
-	/* do not set an audio pid on decoders without audio support */
-	if (!m_has_audio) apid = -1;
-
+	printf("eTSMPEGDecoder setAudioPID %d\n", apid);
 	if ((m_apid != apid) || (m_atype != type))
 	{
 		m_changed |= changeAudio;
@@ -1225,6 +561,7 @@
 
 RESULT eTSMPEGDecoder::play()
 {
+printf("eTSMPEGDecoder play\n");
 	if (m_state == statePlay)
 	{
 		if (!m_changed)
@@ -1239,6 +576,7 @@
 
 RESULT eTSMPEGDecoder::pause()
 {
+printf("eTSMPEGDecoder pause\n");
 	if (m_state == statePause)
 		return 0;
 	m_state = statePause;
@@ -1289,18 +627,6 @@
 	return 0;
 }
 
-void eTSMPEGDecoder::demux_event(int event)
-{
-	switch (event)
-	{
-	case eDVBDemux::evtFlush:
-		flush();
-		break;
-	default:
-		break;
-	}
-}
-
 RESULT eTSMPEGDecoder::getPTS(int what, pts_t &pts)
 {
 	if (what == 0) /* auto */
@@ -1412,42 +738,3 @@
 	return 0;
 }
 
-void eTSMPEGDecoder::video_event(struct videoEvent event)
-{
-	/* emit */ m_video_event(event);
-}
-
-int eTSMPEGDecoder::getVideoWidth()
-{
-	if (m_video)
-		return m_video->getWidth();
-	return -1;
-}
-
-int eTSMPEGDecoder::getVideoHeight()
-{
-	if (m_video)
-		return m_video->getHeight();
-	return -1;
-}
-
-int eTSMPEGDecoder::getVideoProgressive()
-{
-	if (m_video)
-		return m_video->getProgressive();
-	return -1;
-}
-
-int eTSMPEGDecoder::getVideoFrameRate()
-{
-	if (m_video)
-		return m_video->getFrameRate();
-	return -1;
-}
-
-int eTSMPEGDecoder::getVideoAspect()
-{
-	if (m_video)
-		return m_video->getAspect();
-	return -1;
-}
diff -Naur enigma2.ori/lib/dvb/decoder.h enigma2/lib/dvb/decoder.h
--- enigma2.ori/lib/dvb/decoder.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/decoder.h	2011-12-16 06:15:29.000000000 +0100
@@ -3,6 +3,7 @@
 
 #include <lib/base/object.h>
 #include <lib/dvb/demux.h>
+#include <lib/gdi/gxlibdc.h>
 
 class eSocketNotifier;
 
@@ -10,23 +11,15 @@
 {
 	DECLARE_REF(eDVBAudio);
 private:
-	ePtr<eDVBDemux> m_demux;
-	int m_fd, m_fd_demux, m_dev, m_is_freezed;
+	int m_dev, m_is_freezed;
 public:
 	enum { aMPEG, aAC3, aDTS, aAAC, aAACHE, aLPCM, aDTSHD, aDDP };
-	eDVBAudio(eDVBDemux *demux, int dev);
+	eDVBAudio(int dev);
 	enum { aMonoLeft, aStereo, aMonoRight };
 	void setChannel(int channel);
 	void stop();
-#if HAVE_DVB_API_VERSION < 3
-	int setPid(int pid, int type);
-	int startPid();
-	int start();
-	int stopPid();
-	int setAVSync(int val);
-#else
 	int startPid(int pid, int type);
-#endif
+
 	void flush();
 	void freeze();
 	void unfreeze();
@@ -38,28 +31,19 @@
 {
 	DECLARE_REF(eDVBVideo);
 private:
-	ePtr<eDVBDemux> m_demux;
-	int m_fd, m_fd_demux, m_dev;
-#if HAVE_DVB_API_VERSION < 3
-	m_fd_video;
-#endif
+	int m_dev;
+
 	int m_is_slow_motion, m_is_fast_forward, m_is_freezed;
 	ePtr<eSocketNotifier> m_sn;
 	void video_event(int what);
 	Signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
-	int m_width, m_height, m_framerate, m_aspect, m_progressive;
+	int m_progressive;
 public:
 	enum { MPEG2, MPEG4_H264, MPEG1, MPEG4_Part2, VC1, VC1_SM };
-	eDVBVideo(eDVBDemux *demux, int dev);
+	eDVBVideo(int dev);
 	void stop();
-#if HAVE_DVB_API_VERSION < 3
-	int setPid(int pid);
-	int startPid();
-	int start();
-	int stopPid();
-#else
 	int startPid(int pid, int type=MPEG2);
-#endif
+
 	void flush();
 	void freeze();
 	int setSlowMotion(int repeat);
@@ -67,28 +51,16 @@
 	void unfreeze();
 	int getPTS(pts_t &now);
 	virtual ~eDVBVideo();
-	RESULT connectEvent(const Slot1<void, struct iTSMPEGDecoder::videoEvent> &event, ePtr<eConnection> &conn);
-	int getWidth();
-	int getHeight();
-	int getProgressive();
-	int getFrameRate();
-	int getAspect();
 };
 
 class eDVBPCR: public iObject
 {
 	DECLARE_REF(eDVBPCR);
 private:
-	ePtr<eDVBDemux> m_demux;
-	int m_fd_demux, m_dev;
+	int m_dev;
 public:
-	eDVBPCR(eDVBDemux *demux, int dev);
-#if HAVE_DVB_API_VERSION < 3
-	int setPid(int pid);
-	int startPid();
-#else
+	eDVBPCR(int dev);
 	int startPid(int pid);
-#endif
 	void stop();
 	virtual ~eDVBPCR();
 };
@@ -97,10 +69,9 @@
 {
 	DECLARE_REF(eDVBTText);
 private:
-	ePtr<eDVBDemux> m_demux;
-	int m_fd_demux, m_dev;
+	int m_dev;
 public:
-	eDVBTText(eDVBDemux *demux, int dev);
+	eDVBTText(int dev);
 	int startPid(int pid);
 	void stop();
 	virtual ~eDVBTText();
@@ -114,7 +85,6 @@
 	static int m_ac3_delay;
 	static int m_audio_channel;
 	std::string m_radio_pic;
-	ePtr<eDVBDemux> m_demux;
 	ePtr<eDVBAudio> m_audio;
 	ePtr<eDVBVideo> m_video;
 	ePtr<eDVBPCR> m_pcr;
@@ -133,18 +103,16 @@
 	int m_ff_sm_ratio;
 	bool m_has_audio;
 	int setState();
-	ePtr<eConnection> m_demux_event_conn;
-	ePtr<eConnection> m_video_event_conn;
 	
-	void demux_event(int event);
-	void video_event(struct videoEvent);
 	Signal1<void, struct videoEvent> m_video_event;
 	int m_video_clip_fd;
 	ePtr<eTimer> m_showSinglePicTimer;
 	void finishShowSinglePic(); // called by timer
+
 public:
+
 	enum { pidNone = -1 };
-	eTSMPEGDecoder(eDVBDemux *demux, int decoder);
+	eTSMPEGDecoder(int decoder);
 	virtual ~eTSMPEGDecoder();
 	RESULT setVideoPID(int vpid, int type);
 	RESULT setAudioPID(int apid, int type);
@@ -189,11 +157,11 @@
 		/* what 0=auto, 1=video, 2=audio. */
 	RESULT getPTS(int what, pts_t &pts);
 	RESULT connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection);
-	int getVideoWidth();
-	int getVideoHeight();
-	int getVideoProgressive();
-	int getVideoFrameRate();
-	int getVideoAspect();
+	int getVideoWidth() { return -1; };
+	int getVideoHeight() { return -1; };
+	int getVideoProgressive() { return -1; };
+	int getVideoFrameRate() { return -1; };
+	int getVideoAspect() { return -1; };
 	static RESULT setHwPCMDelay(int delay);
 	static RESULT setHwAC3Delay(int delay);
 };
diff -Naur enigma2.ori/lib/dvb/decsa.cpp enigma2/lib/dvb/decsa.cpp
--- enigma2.ori/lib/dvb/decsa.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/dvb/decsa.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,212 @@
+/*
+ * Based on "Softcam plugin to VDR (C++)"
+ */
+
+#include <lib/dvb/decsa.h>
+
+cDeCSA::cDeCSA(int _adapter, int _demux) {
+  adapter = _adapter;
+  demux = _demux;
+
+  cs=dvbcsa_bs_batch_size();
+  pcks = new dvbcsa_bs_batch_s[cs+1];
+
+  for (int i=0; i<=cs; i++) {
+    pcks[i].data = NULL;
+  }
+
+  memset(csa_bs_key_even,0,sizeof(csa_bs_key_even));
+  memset(csa_bs_key_odd,0,sizeof(csa_bs_key_odd));
+  memset(pidmap,0,sizeof(pidmap));
+  ResetState();
+}
+
+cDeCSA::~cDeCSA()
+{
+  for(int i=0; i<MAX_CSA_IDX; i++) {
+    if(csa_bs_key_even[i])
+      dvbcsa_bs_key_free(csa_bs_key_even[i]);
+    if(csa_bs_key_odd[i])
+      dvbcsa_bs_key_free(csa_bs_key_odd[i]);
+  }
+}
+
+void cDeCSA::ResetState(void)
+{
+  printf("adapter%d/demux%d: reset state", adapter, demux);
+  memset(even_odd,0,sizeof(even_odd));
+  memset(flags,0,sizeof(flags));
+  memset(usedPids,0,sizeof(usedPids));
+  lastData=0;
+}
+
+static bool CheckNull(const unsigned char *data, int len)
+{
+  while(--len>=0)
+    if(data[len])
+      return false;
+  return true;
+}
+
+bool cDeCSA::GetKeyStruct(int idx)
+{
+  if(!csa_bs_key_even[idx])
+    csa_bs_key_even[idx] = dvbcsa_bs_key_alloc();
+  if(!csa_bs_key_odd[idx])
+    csa_bs_key_odd[idx] = dvbcsa_bs_key_alloc();
+
+  return (csa_bs_key_even[idx]!=0 && csa_bs_key_odd[idx]!=0);
+}
+
+bool cDeCSA::SetDescr(ca_descr_t *ca_descr, bool initial)
+{
+  cMutexLock lock(&mutex);
+
+  int idx=ca_descr->index;
+  if(idx<MAX_CSA_IDX && GetKeyStruct(idx)) {
+    if(!initial && ca_descr->parity==(even_odd[idx]&0x40)>>6) {
+      if(flags[idx] & (ca_descr->parity?FL_ODD_GOOD:FL_EVEN_GOOD)) {
+        printf("adapter%d/demux%d idx %d: %s key in use (%d ms)", adapter, demux ,idx,ca_descr->parity?"odd":"even",MAX_REL_WAIT);
+        if(wait.TimedWait(mutex,MAX_REL_WAIT))
+          printf("adapter%d/demux%d idx %d: successfully waited for release\n", adapter, demux, idx);
+        else
+          printf("adapter%d/demux%d idx %d: timed out. setting anyways\n", adapter, demux, idx);
+      }
+      else
+        printf("adapter%d/demux%d idx %d: late key set...\n", adapter, demux, idx);
+    }
+    if(ca_descr->parity==0) {
+      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_even[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_EVEN_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx %d: zero even CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    } else {
+      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_odd[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_ODD_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx%d: zero odd CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    }
+  }
+
+  return true;
+}
+
+bool cDeCSA::SetCaPid(ca_pid_t *ca_pid)
+{
+  cMutexLock lock(&mutex);
+
+  if(ca_pid->index<MAX_CSA_IDX && ca_pid->pid<MAX_CSA_PIDS) {
+    int idx;
+
+    if (ca_pid->index!=-1) {
+      idx = ca_pid->index;
+      usedPids[idx]++;
+    } else {
+      idx = pidmap[ca_pid->pid];
+      usedPids[idx]--;
+      if (usedPids[idx]==0) {
+        even_odd[idx] = 0;
+        flags[idx] = 0;
+      }
+    }
+
+    pidmap[ca_pid->pid]=ca_pid->index;
+    //printf("adapter%d/demux%d idx %d: set pid %04x\n", adapter, demux, ca_pid->index, ca_pid->pid);
+    //printf("adapter%d/demux%d idx %d: udedPids %d\n", adapter, demux, idx, usedPids[idx]);
+  }
+
+  return true;
+}
+
+bool cDeCSA::Decrypt(unsigned char *data, int len, int& packetsCount)
+{
+  cMutexLock lock(&mutex);
+
+  int currIdx=-1;
+  len-=(TS_SIZE-1);
+  int l;
+  int packets=0, cryptedPackets=0;
+
+  for(l=0; l<len && cryptedPackets<cs; l+=TS_SIZE) {
+    unsigned int ev_od=data[l+3]&0xC0;
+    int adaptation_field_exist = (data[l+3]&0x30)>>4;
+
+    if((ev_od==0x80 || ev_od==0xC0) && adaptation_field_exist!=2) { // encrypted
+      int idx=pidmap[((data[l+1]<<8)+data[l+2])&(MAX_CSA_PIDS-1)];
+      if(currIdx<0 || idx==currIdx) { // same or no index
+        currIdx=idx;
+        if(ev_od!=even_odd[idx]) {
+          if (cryptedPackets==0) {
+            even_odd[idx]=ev_od;
+            wait.Broadcast();
+            printf("adapter%d/demux%d idx %d: change to %s key\n", adapter, demux, idx, (ev_od&0x40)?"odd":"even");
+          
+            bool doWait=false;
+            if(ev_od&0x40) {
+              flags[idx]&=~FL_EVEN_GOOD;
+              if(!(flags[idx]&FL_ODD_GOOD)) doWait=true;
+            }
+            else {
+              flags[idx]&=~FL_ODD_GOOD;
+              if(!(flags[idx]&FL_EVEN_GOOD)) doWait=true;
+            }
+            if(doWait) {
+              printf("adapter%d/demux%d idx %d: %s key not ready (%d ms)\n",
+                  adapter, demux, idx, (ev_od&0x40)?"odd":"even", MAX_KEY_WAIT);
+              if(flags[idx]&FL_ACTIVITY) {
+                flags[idx]&=~FL_ACTIVITY;
+                if(wait.TimedWait(mutex,MAX_KEY_WAIT))
+                  printf("adapter%d/demux%d idx %d: successfully waited for key\n", adapter, demux, idx);
+                else
+                  printf("adapter%d/demux%d idx %d: timed out. proceeding anyways\n", adapter, demux, idx);
+              } else
+                printf("adapter%d/demux%d idx %d: not active. wait skipped\n", adapter, demux, idx);
+            }
+          } else {
+            break;
+          }
+        }
+      }
+      else
+        break;
+
+      if (adaptation_field_exist==1) {
+        pcks[cryptedPackets].data = data+l+4;
+        pcks[cryptedPackets].len = 184;
+      } else if (adaptation_field_exist==3) {
+        pcks[cryptedPackets].data = data+l+5+data[l+4];
+        pcks[cryptedPackets].len = 183-data[l+4];
+      }
+      cryptedPackets++;
+    }
+
+    data[l+3] &= 0x3F;
+    packets++;
+  }
+
+  if (cryptedPackets>0) {
+    for (int i=cryptedPackets;i<=cs;i++) {
+      pcks[i].data = NULL;
+    }
+
+    if (GetKeyStruct(currIdx)) {
+      if (even_odd[currIdx]&0x40) {
+        dvbcsa_bs_decrypt(csa_bs_key_odd[currIdx], pcks, 184);
+      } else {
+        dvbcsa_bs_decrypt(csa_bs_key_even[currIdx], pcks, 184);
+      }
+    }
+  }
+
+  packetsCount = packets;
+
+  return true;
+}
+
+
diff -Naur enigma2.ori/lib/dvb/decsa.h enigma2/lib/dvb/decsa.h
--- enigma2.ori/lib/dvb/decsa.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/dvb/decsa.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,47 @@
+#ifndef __dvb_decsa_h
+#define __dvb_decsa_h
+
+#include <linux/dvb/ca.h>
+#include <lib/base/condVar.h>
+
+extern "C" {
+#include <dvbcsa/dvbcsa.h>
+}
+
+#define TS_SIZE          188
+#define TS_SYNC_BYTE     0x47
+
+#define MAX_REL_WAIT 100 // time to wait if key in used on set
+#define MAX_KEY_WAIT 200 // time to wait if key not ready on change
+
+#define MAX_CSA_PIDS 8192
+#define MAX_CSA_IDX  16
+#define FL_EVEN_GOOD 1
+#define FL_ODD_GOOD  2
+#define FL_ACTIVITY  4
+
+class cDeCSA {
+private:
+  int cs;
+  unsigned char *lastData;
+  unsigned char pidmap[MAX_CSA_PIDS];
+  unsigned int even_odd[MAX_CSA_IDX], flags[MAX_CSA_IDX], usedPids[MAX_CSA_IDX];
+  cMutex mutex;
+  cCondVar wait;
+  int adapter, demux;
+  struct dvbcsa_bs_key_s* csa_bs_key_even[MAX_CSA_IDX];
+  struct dvbcsa_bs_key_s* csa_bs_key_odd[MAX_CSA_IDX];
+  struct dvbcsa_bs_batch_s *pcks;
+
+  bool GetKeyStruct(int idx);
+  void ResetState(void);
+public:
+  cDeCSA(int _adapter, int _demux);
+  ~cDeCSA();
+  bool Decrypt(unsigned char *data, int len, int& packetsCount);
+
+  bool SetDescr(ca_descr_t *ca_descr, bool initial);
+  bool SetCaPid(ca_pid_t *ca_pid);
+};
+
+#endif
diff -Naur enigma2.ori/lib/dvb/demux.cpp enigma2/lib/dvb/demux.cpp
--- enigma2.ori/lib/dvb/demux.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/demux.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -84,21 +84,19 @@
 
 eDVBDemux::eDVBDemux(int adapter, int demux): adapter(adapter), demux(demux)
 {
-	m_dvr_busy = 0;
+	decsa = new cDeCSA(adapter, demux);
 }
 
 eDVBDemux::~eDVBDemux()
 {
+	delete decsa;
 }
 
+
 int eDVBDemux::openDemux(void)
 {
 	char filename[32];
-#if HAVE_DVB_API_VERSION < 3
-	snprintf(filename, sizeof(filename), "/dev/dvb/card%d/demux%d", adapter, demux);
-#else
 	snprintf(filename, sizeof(filename), "/dev/dvb/adapter%d/demux%d", adapter, demux);
-#endif
 	return ::open(filename, O_RDWR);
 }
 
@@ -121,7 +119,6 @@
 
 RESULT eDVBDemux::setSourceFrontend(int fenum)
 {
-#if HAVE_DVB_API_VERSION >= 3
 	int fd = openDemux();
 	int n = DMX_SOURCE_FRONT0 + fenum;
 	int res = ::ioctl(fd, DMX_SET_SOURCE, &n);
@@ -131,21 +128,6 @@
 		source = fenum;
 	::close(fd);
 	return res;
-#endif
-	return 0;
-}
-
-RESULT eDVBDemux::setSourcePVR(int pvrnum)
-{
-#if HAVE_DVB_API_VERSION >= 3
-	int fd = openDemux();
-	int n = DMX_SOURCE_DVR0 + pvrnum;
-	int res = ::ioctl(fd, DMX_SET_SOURCE, &n);
-	source = -1;
-	::close(fd);
-	return res;
-#endif
-	return 0;
 }
 
 RESULT eDVBDemux::createSectionReader(eMainloop *context, ePtr<iDVBSectionReader> &reader)
@@ -168,15 +150,19 @@
 
 RESULT eDVBDemux::createTSRecorder(ePtr<iDVBTSRecorder> &recorder)
 {
-	if (m_dvr_busy)
-		return -EBUSY;
 	recorder = new eDVBTSRecorder(this);
 	return 0;
 }
 
+RESULT eDVBDemux::createTSPlayer(ePtr<iDVBTSPlayer> &player)
+{
+	player = new eDVBTSPlayer(this);
+	return 0;
+}
+
 RESULT eDVBDemux::getMPEGDecoder(ePtr<iTSMPEGDecoder> &decoder, int primary)
 {
-	decoder = new eTSMPEGDecoder(this, primary ? 0 : 1);
+	decoder = new eTSMPEGDecoder(primary ? 0 : 1);
 	return 0;
 }
 
@@ -220,6 +206,20 @@
 	return 0;
 }
 
+RESULT eDVBDemux::setCaDescr(ca_descr_t *ca_descr, bool initial)
+{
+	return decsa->SetDescr(ca_descr, initial);
+}
+
+RESULT eDVBDemux::setCaPid(ca_pid_t *ca_pid)
+{
+	return decsa->SetCaPid(ca_pid);
+}
+
+bool eDVBDemux::decrypt(uint8_t *data, int len, int &packetsCount) {
+	return decsa->Decrypt(data, len, packetsCount);
+}
+
 void eDVBSectionReader::data(int)
 {
 	__u8 data[4096]; // max. section size
@@ -532,18 +532,12 @@
 	m_thread(new eDVBRecordFileThread())
 {
 	CONNECT(m_thread->m_event, eDVBTSRecorder::filepushEvent);
-#ifndef HAVE_ADD_PID
-	m_demux->m_dvr_busy = 1;
-#endif
 }
 
 eDVBTSRecorder::~eDVBTSRecorder()
 {
 	stop();
 	delete m_thread;
-#ifndef HAVE_ADD_PID
-	m_demux->m_dvr_busy = 0;
-#endif
 }
 
 RESULT eDVBTSRecorder::start()
@@ -560,20 +554,6 @@
 		return -3;
 
 	char filename[128];
-#ifndef HAVE_ADD_PID
-#if HAVE_DVB_API_VERSION < 3
-	snprintf(filename, 128, "/dev/dvb/card%d/dvr%d", m_demux->adapter, m_demux->demux);
-#else
-	snprintf(filename, 128, "/dev/dvb/adapter%d/dvr%d", m_demux->adapter, m_demux->demux);
-#endif
-	m_source_fd = ::open(filename, O_RDONLY);
-	
-	if (m_source_fd < 0)
-	{
-		eDebug("FAILED to open dvr (%s) in ts recoder (%m)", filename);
-		return -3;
-	}
-#else
 	snprintf(filename, 128, "/dev/dvb/adapter%d/demux%d", m_demux->adapter, m_demux->demux);
 
 	m_source_fd = ::open(filename, O_RDONLY);
@@ -584,16 +564,13 @@
 		return -3;
 	}
 	
-	setBufferSize(demuxSize);
-
+//	setBufferSize(demuxSize);
+	setBufferSize(4*1024*1024);
+	
 	dmx_pes_filter_params flt;
-#if HAVE_DVB_API_VERSION > 3
+
 	flt.pes_type = DMX_PES_OTHER;
 	flt.output  = DMX_OUT_TSDEMUX_TAP;
-#else
-	flt.pes_type = (dmx_pes_type_t)DMX_TAP_TS;
-	flt.output  = DMX_OUT_TAP;
-#endif
 	flt.pid     = i->first;
 	++i;
 	flt.input   = DMX_IN_FRONTEND;
@@ -608,20 +585,17 @@
 	}
 	
 	::ioctl(m_source_fd, DMX_START);
-	
-#endif
 
 	if (!m_target_filename.empty())
 		m_thread->startSaveMetaInformation(m_target_filename);
 	
-	m_thread->start(m_source_fd, m_target_fd);
-	m_running = 1;
-
 	while (i != m_pids.end()) {
 		startPID(i->first);
 		++i;
 	}
 
+	m_thread->start(m_demux, m_source_fd, m_target_fd);
+	m_running = 1;
 	return 0;
 }
 
@@ -683,33 +657,17 @@
 {
 	int state=3;
 
-	for (std::map<int,int>::iterator i(m_pids.begin()); i != m_pids.end(); ++i)
-		stopPID(i->first);
-
 	if (!m_running)
 		return -1;
 
-#if HAVE_DVB_API_VERSION >= 5
-	/* workaround for record thread stop */
-	if (::ioctl(m_source_fd, DMX_STOP) < 0)
-		perror("DMX_STOP");
-	else
-		state &= ~1;
-
 	if (::close(m_source_fd) < 0)
 		perror("close");
 	else
-		state &= ~2;
-#endif
+		m_source_fd = -1;
 
 	m_thread->stop();
-
-	if (state & 3)
-		::close(m_source_fd);
-
 	m_running = 0;
-	m_source_fd = -1;
-
+	
 	m_thread->stopSaveMetaInformation();
 	return 0;
 }
@@ -768,12 +726,8 @@
 	m_pids[pid] = fd;
 #else
 	while(true) {
-#if HAVE_DVB_API_VERSION > 3
 		__u16 p = pid;
 		if (::ioctl(m_source_fd, DMX_ADD_PID, &p) < 0) {
-#else
-		if (::ioctl(m_source_fd, DMX_ADD_PID, pid) < 0) {
-#endif
 			perror("DMX_ADD_PID");
 			if (errno == EAGAIN || errno == EINTR) {
 				eDebug("retry!");
@@ -784,24 +738,17 @@
 		break;
 	}
 #endif
+
 	return 0;
 }
 
 void eDVBTSRecorder::stopPID(int pid)
 {
-#ifndef HAVE_ADD_PID
-	if (m_pids[pid] != -1)
-		::close(m_pids[pid]);
-#else
 	if (m_pids[pid] != -1)
 	{
 		while(true) {
-#if HAVE_DVB_API_VERSION > 3
 			__u16 p = pid;
 			if (::ioctl(m_source_fd, DMX_REMOVE_PID, &p) < 0) {
-#else
-			if (::ioctl(m_source_fd, DMX_REMOVE_PID, pid) < 0) {
-#endif
 				perror("DMX_REMOVE_PID");
 				if (errno == EAGAIN || errno == EINTR) {
 					eDebug("retry!");
@@ -811,7 +758,7 @@
 			break;
 		}
 	}
-#endif
+
 	m_pids[pid] = -1;
 }
 
@@ -824,3 +771,188 @@
 		break;
 	}
 }
+
+
+DEFINE_REF(eDVBTSPlayer);
+
+eDVBTSPlayer::eDVBTSPlayer(eDVBDemux *demux): m_demux(demux)
+{
+	m_running = 0;
+	m_target_fd = -1;
+	m_thread = new eFilePushThread(IOPRIO_CLASS_RT, 7);
+	CONNECT(m_thread->m_event, eDVBTSPlayer::filepushEvent);
+}
+
+eDVBTSPlayer::~eDVBTSPlayer()
+{
+	stop();
+	delete m_thread;
+}
+
+RESULT eDVBTSPlayer::start()
+{
+	std::map<int,int>::iterator i(m_pids.begin());
+
+	if (m_running)
+		return -1;
+
+	m_running = 1;
+
+	if (m_target_fd == -1)
+		return -2;
+
+	if (i == m_pids.end())
+		return -3;
+
+	char filename[128];
+	snprintf(filename, 128, "/dev/dvb/adapter%d/demux%d", m_demux->adapter, m_demux->demux);
+
+	m_source_fd = ::open(filename, O_RDONLY);
+	
+	if (m_source_fd < 0)
+	{
+		eDebug("FAILED to open demux (%s) in ts recoder (%m)", filename);
+		return -3;
+	}
+
+	setBufferSize(4*1024*1024);
+
+	dmx_pes_filter_params flt;
+	flt.pes_type = DMX_PES_OTHER;
+	flt.output  = DMX_OUT_TSDEMUX_TAP;
+	flt.pid     = i->first;
+	++i;
+	flt.input   = DMX_IN_FRONTEND;
+	flt.flags   = 0;
+
+	int res = ::ioctl(m_source_fd, DMX_SET_PES_FILTER, &flt);
+	if (res)
+	{
+		eDebug("DMX_SET_PES_FILTER: %m");
+		::close(m_source_fd);
+		return -3;
+	}
+	
+	::ioctl(m_source_fd, DMX_START);
+	
+	while (i != m_pids.end()) {
+		startPID(i->first);
+		++i;
+	}
+
+	m_thread->start(m_demux, m_source_fd, m_target_fd);
+	return 0;
+}
+
+RESULT eDVBTSPlayer::setBufferSize(int size)
+{
+	int res = ::ioctl(m_source_fd, DMX_SET_BUFFER_SIZE, size);
+	if (res < 0)
+		eDebug("eDVBTSPlayer DMX_SET_BUFFER_SIZE failed(%m)");
+	return res;
+}
+
+RESULT eDVBTSPlayer::addPID(int pid)
+{
+	if (m_pids.find(pid) != m_pids.end())
+		return -1;
+	
+	m_pids.insert(std::pair<int,int>(pid, -1));
+	if (m_running)
+		startPID(pid);
+	return 0;
+}
+
+RESULT eDVBTSPlayer::removePID(int pid)
+{
+	if (m_pids.find(pid) == m_pids.end())
+		return -1;
+		
+	if (m_running)
+		stopPID(pid);
+	
+	m_pids.erase(pid);
+	return 0;
+}
+
+RESULT eDVBTSPlayer::setTargetFD(int fd)
+{
+	m_target_fd = fd;
+	return 0;
+}
+
+RESULT eDVBTSPlayer::stop()
+{
+	int state=3;
+
+	if (!m_running)
+		return -1;
+
+	if (::close(m_source_fd) < 0)
+		perror("DMX_close ERROR");
+	else
+		m_source_fd = -1;
+
+	m_thread->stop();
+	m_running = 0;
+	m_source_fd = -1;
+
+	printf("eDVBTSPlayer::stop past\n");
+	return 0;
+}
+
+/*RESULT eDVBTSPlayer::connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn)
+{
+	conn = new eConnection(this, m_event.connect(event));
+	return 0;
+}*/
+
+RESULT eDVBTSPlayer::startPID(int pid)
+{
+	while(true) {
+		__u16 p = pid;
+		if (::ioctl(m_source_fd, DMX_ADD_PID, &p) < 0) {
+			perror("DMX_ADD_PID");
+			if (errno == EAGAIN || errno == EINTR) {
+				eDebug("retry!");
+				continue;
+			}
+		} else
+			m_pids[pid] = 1;
+		break;
+	}
+
+	return 0;
+}
+
+void eDVBTSPlayer::stopPID(int pid)
+{
+	printf("eDVBTSPlayer::stopPID %d\n", pid);
+	if (m_pids[pid] != -1)
+	{
+		while(true) {
+			__u16 p = pid;
+			if (::ioctl(m_source_fd, DMX_REMOVE_PID, &p) < 0) {
+				perror("DMX_REMOVE_PID");
+				if (errno == EAGAIN || errno == EINTR) {
+					eDebug("retry!");
+					continue;
+				}
+			}
+			break;
+		}
+	}
+
+	m_pids[pid] = -1;
+}
+
+void eDVBTSPlayer::filepushEvent(int event)
+{
+	switch (event)
+	{
+	case eFilePushThread::evtWriteError:
+		m_event(eventWriteError);
+		break;
+	}
+}
+
diff -Naur enigma2.ori/lib/dvb/demux.h enigma2/lib/dvb/demux.h
--- enigma2.ori/lib/dvb/demux.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/demux.h	2011-12-16 06:15:29.000000000 +0100
@@ -3,6 +3,9 @@
 
 #include <lib/dvb/idvb.h>
 #include <lib/dvb/idemux.h>
+#include <lib/dvb/decsa.h>
+
+class eFilePushThread;
 
 class eDVBDemux: public iDVBDemux
 {
@@ -16,11 +19,11 @@
 	
 	RESULT setSourceFrontend(int fenum);
 	int getSource() { return source; }
-	RESULT setSourcePVR(int pvrnum);
 	
 	RESULT createSectionReader(eMainloop *context, ePtr<iDVBSectionReader> &reader);
 	RESULT createPESReader(eMainloop *context, ePtr<iDVBPESReader> &reader);
 	RESULT createTSRecorder(ePtr<iDVBTSRecorder> &recorder);
+	RESULT createTSPlayer(ePtr<iDVBTSPlayer> &player);
 	RESULT getMPEGDecoder(ePtr<iTSMPEGDecoder> &reader, int primary);
 	RESULT getSTC(pts_t &pts, int num);
 	RESULT getCADemuxID(uint8_t &id) { id = demux; return 0; }
@@ -30,10 +33,14 @@
 	int openDVR(int flags);
 
 	int getRefCount() { return ref; }
+
+	RESULT setCaDescr(ca_descr_t *ca_descr, bool initial);
+	RESULT setCaPid(ca_pid_t *ca_pid);
+	bool decrypt(uint8_t *data, int len, int &packetsCount);
 private:
 	int adapter, demux, source;
-	
-	int m_dvr_busy;
+	cDeCSA *decsa;
+
 	friend class eDVBSectionReader;
 	friend class eDVBPESReader;
 	friend class eDVBAudio;
@@ -41,6 +48,7 @@
 	friend class eDVBPCR;
 	friend class eDVBTText;
 	friend class eDVBTSRecorder;
+	friend class eDVBTSPlayer;
 	friend class eDVBCAService;
 	friend class eTSMPEGDecoder;
 	Signal1<void, int> m_event;
@@ -126,4 +134,35 @@
 	std::string m_target_filename;
 };
 
+class eDVBTSPlayer: public iDVBTSPlayer, public Object
+{
+	DECLARE_REF(eDVBTSPlayer);
+public:
+	eDVBTSPlayer(eDVBDemux *demux);
+	~eDVBTSPlayer();
+
+	RESULT setBufferSize(int size);
+	RESULT start();
+	RESULT addPID(int pid);
+	RESULT removePID(int pid);
+	RESULT setTargetFD(int fd);
+	
+	RESULT stop();
+
+	//RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn);
+private:
+	RESULT startPID(int pid);
+	void stopPID(int pid);
+	
+	eFilePushThread *m_thread;
+	void filepushEvent(int event);
+	
+	std::map<int,int> m_pids;
+	Signal1<void,int> m_event;
+	
+	ePtr<eDVBDemux> m_demux;
+	
+	int m_running, m_target_fd, m_source_fd;
+};
+
 #endif
diff -Naur enigma2.ori/lib/dvb/dvb.cpp enigma2/lib/dvb/dvb.cpp
--- enigma2.ori/lib/dvb/dvb.cpp	2011-12-14 17:20:11.000000000 +0100
+++ enigma2/lib/dvb/dvb.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -82,7 +82,7 @@
 		num_adapter++;
 	}
 
-	int fd = open("/proc/stb/info/model", O_RDONLY);
+	int fd = open("/usr/local/e2/etc/stb/info/model", O_RDONLY);
 	char tmp[16];
 	int rd = fd >= 0 ? read(fd, tmp, sizeof(tmp)) : 0;
 	if (fd >= 0)
@@ -101,7 +101,7 @@
 	else if (!strncmp(tmp, "dm7020hd\n", rd))
 		m_boxtype = DM7020HD;
 	else {
-		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
+		eDebug("boxtype detection via /usr/local/e2/etc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
 			m_boxtype = DM800;
 		else if (m_demux.size() < 5)
@@ -110,6 +110,8 @@
 			m_boxtype = DM8000;
 	}
 
+	m_boxtype = X86;
+
 	eDebug("found %zd adapter, %zd frontends(%zd sim) and %zd demux, boxtype %d",
 		m_adapter.size(), m_frontend.size(), m_simulate_frontend.size(), m_demux.size(), m_boxtype);
 
@@ -491,6 +493,17 @@
 			}
 		}
 	}
+	else if ( m_boxtype == X86 ) {
+
+		for (; i != m_demux.end(); ++i)
+		{
+			if ( !i->m_inuse && i->m_adapter==fe->m_adapter )
+			{
+				unused = i;
+				break;
+			}
+		}
+	}
 	else
 	{
 		iDVBAdapter *adapter = fe ? fe->m_adapter : m_adapter.begin(); /* look for a demux on the same adapter as the frontend, or the first adapter for dvr playback */
@@ -545,10 +558,7 @@
 	if (unused)
 	{
 		demux = new eDVBAllocatedDemux(unused);
-		if (fe)
-			demux->get().setSourceFrontend(fe->m_frontend->getDVBID());
-		else
-			demux->get().setSourcePVR(0);
+		demux->get().setSourceFrontend(fe->m_frontend->getDVBID());
 		return 0;
 	}
 
@@ -929,6 +939,22 @@
 	return false;
 }
 
+RESULT eDVBResourceManager::getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr)
+{
+	eSmartPtrList<iDVBAdapter>::iterator i(m_adapter.begin());
+
+	while (adapter_nr && (i != m_adapter.end())) {
+		--adapter_nr;
+		++i;
+	}
+
+	if (i != m_adapter.end())
+		return i->getDemux(demux, demux_nr);
+	else
+		return -1;
+}
+
+
 class eDVBChannelFilePush: public eFilePushThread
 {
 public:
@@ -1684,7 +1710,7 @@
 
 RESULT eDVBChannel::getDemux(ePtr<iDVBDemux> &demux, int cap)
 {
-	ePtr<eDVBAllocatedDemux> &our_demux = (cap & capDecode) ? m_decoder_demux : m_demux;
+	ePtr<eDVBAllocatedDemux> &our_demux = m_demux;
 
 	if (!our_demux)
 	{
@@ -1764,43 +1790,13 @@
 
 		/* DON'T EVEN THINK ABOUT FIXING THIS. FIX THE ATI SOURCES FIRST,
 		   THEN DO A REAL FIX HERE! */
-
-	if (m_pvr_fd_dst < 0)
-	{
-		/* (this codepath needs to be improved anyway.) */
-#if HAVE_DVB_API_VERSION < 3
-		m_pvr_fd_dst = open("/dev/pvr", O_WRONLY);
-		if (m_pvr_fd_dst < 0)
-		{
-			eDebug("can't open /dev/pvr - you need to buy the new(!) $$$ box! (%m)"); // or wait for the driver to be improved.
-			return -ENODEV;
-		}
-#else
-#ifdef HAVE_OLDPVR
-		m_pvr_fd_dst = open("/dev/misc/pvr", O_WRONLY);
+	if (m_pvr_fd_dst < 0) {
+		m_pvr_fd_dst = ::open("/tmp/ENIGMA_FIFO", O_RDWR);
 		if (m_pvr_fd_dst < 0)
 		{
-			eDebug("can't open /dev/misc/pvr - %m"); // or wait for the driver to be improved.
-			return -ENODEV;
-		}
-#else
-		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
-		if (demux)
-		{
-			m_pvr_fd_dst = demux->get().openDVR(O_WRONLY);
-			if (m_pvr_fd_dst < 0)
-			{
-				eDebug("can't open /dev/dvb/adapterX/dvrX - you need to buy the new(!) $$$ box! (%m)"); // or wait for the driver to be improved.
-				return -ENODEV;
-			}
-		}
-		else
-		{
-			eDebug("no demux allocated yet.. so its not possible to open the dvr device!!");
+			eDebug("can't open DVR device - FIFO file (%m)");
 			return -ENODEV;
 		}
-#endif
-#endif
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush();
@@ -1853,9 +1849,6 @@
 
 RESULT eDVBChannel::getCurrentPosition(iDVBDemux *decoding_demux, pts_t &pos, int mode)
 {
-	if (!decoding_demux)
-		return -1;
-
 	pts_t now;
 
 	int r;
diff -Naur enigma2.ori/lib/dvb/dvb.h enigma2/lib/dvb/dvb.h
--- enigma2.ori/lib/dvb/dvb.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/dvb.h	2011-12-16 06:15:29.000000000 +0100
@@ -135,7 +135,7 @@
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
-	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD };
+	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD, X86 };
 
 	int m_boxtype;
 
@@ -218,6 +218,7 @@
 	PSignal1<void,int> frontendUseMaskChanged;
 	SWIG_VOID(RESULT) allocateRawChannel(eUsePtr<iDVBChannel> &SWIG_OUTPUT, int slot_index);
 	PyObject *setFrontendSlotInformations(SWIG_PYOBJECT(ePyObject) list);
+	RESULT getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr);
 };
 SWIG_TEMPLATE_TYPEDEF(ePtr<eDVBResourceManager>, eDVBResourceManager);
 SWIG_EXTEND(ePtr<eDVBResourceManager>,
diff -Naur enigma2.ori/lib/dvb/dvbtime.cpp enigma2/lib/dvb/dvbtime.cpp
--- enigma2.ori/lib/dvb/dvbtime.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/dvbtime.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -17,13 +17,13 @@
 
 void setRTC(time_t time)
 {
-	FILE *f = fopen("/proc/stb/fp/rtc", "w");
+	FILE *f = fopen("/usr/local/e2/etc/stb/fp/rtc", "w");
 	if (f)
 	{
 		if (fprintf(f, "%u", (unsigned int)time))
 			prev_time = time;
 		else
-			eDebug("write /proc/stb/fp/rtc failed (%m)");
+			eDebug("write /usr/local/e2/etc/stb/fp/rtc failed (%m)");
 		fclose(f);
 	}
 	else
@@ -43,13 +43,13 @@
 time_t getRTC()
 {
 	time_t rtc_time=0;
-	FILE *f = fopen("/proc/stb/fp/rtc", "r");
+	FILE *f = fopen("/usr/local/e2/etc/stb/fp/rtc", "r");
 	if (f)
 	{
 		// sanity check to detect corrupt atmel firmware
 		unsigned int tmp;
 		if (fscanf(f, "%u", &tmp) != 1)
-			eDebug("read /proc/stb/fp/rtc failed (%m)");
+			eDebug("read /usr/local/e2/etc/stb/fp/rtc failed (%m)");
 		else
 			rtc_time=tmp;
 		fclose(f);
diff -Naur enigma2.ori/lib/dvb/frontend.cpp enigma2/lib/dvb/frontend.cpp
--- enigma2.ori/lib/dvb/frontend.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/frontend.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -1485,8 +1485,8 @@
 	int power=m_slotid;  // this is needed for read inputpower from the correct tuner !
 	char proc_name[64];
 	char proc_name2[64];
-	sprintf(proc_name, "/proc/stb/frontend/%d/lnb_sense", m_slotid);
-	sprintf(proc_name2, "/proc/stb/fp/lnb_sense%d", m_slotid);
+	sprintf(proc_name, "/usr/local/e2/etc/stb/frontend/%d/lnb_sense", m_slotid);
+	sprintf(proc_name2, "/usr/local/e2/etc/stb/fp/lnb_sense%d", m_slotid);
 	FILE *f;
 	if ((f=fopen(proc_name, "r")) || (f=fopen(proc_name2, "r")))
 	{
@@ -1855,7 +1855,7 @@
 				if (!m_simulate)
 				{
 					char proc_name[64];
-					sprintf(proc_name, "/proc/stb/frontend/%d/static_current_limiting", sec_fe->m_dvbid);
+					sprintf(proc_name, "/usr/local/e2/etc/stb/frontend/%d/static_current_limiting", sec_fe->m_dvbid);
 					FILE *f=fopen(proc_name, "w");
 					if (f) // new interface exist?
 					{
diff -Naur enigma2.ori/lib/dvb/idemux.h enigma2/lib/dvb/idemux.h
--- enigma2.ori/lib/dvb/idemux.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/idemux.h	2011-12-16 06:15:29.000000000 +0100
@@ -56,4 +56,29 @@
 	virtual RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn)=0;
 };
 
+class iDVBTSPlayer: public iObject
+{
+public:
+	virtual RESULT setBufferSize(int size) = 0;
+	virtual RESULT start() = 0;
+	virtual RESULT addPID(int pid) = 0;
+	virtual RESULT removePID(int pid) = 0;
+	virtual RESULT setTargetFD(int fd) = 0;
+	
+	virtual RESULT stop() = 0;
+
+	//virtual RESULT getCurrentPCR(pts_t &pcr) = 0;
+	
+	enum {
+		eventWriteError,
+				/* a write error has occured. data won't get lost if fd is writable after return. */
+				/* you MUST respond with either stop() or fixing the problems, else you get the error */
+				/* again. */
+		eventReachedBoundary,
+				/* the programmed boundary was reached. you might set a new target fd. you can close the */
+				/* old one. */
+	};
+	//virtual RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn)=0;
+};
+
 #endif
diff -Naur enigma2.ori/lib/dvb/idvb.h enigma2/lib/dvb/idvb.h
--- enigma2.ori/lib/dvb/idvb.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/idvb.h	2011-12-16 06:15:29.000000000 +0100
@@ -618,6 +618,7 @@
 class iDVBSectionReader;
 class iDVBPESReader;
 class iDVBTSRecorder;
+class iDVBTSPlayer;
 class iTSMPEGDecoder;
 
 class iDVBDemux: public iObject
@@ -626,6 +627,7 @@
 	virtual RESULT createSectionReader(eMainloop *context, ePtr<iDVBSectionReader> &reader)=0;
 	virtual RESULT createPESReader(eMainloop *context, ePtr<iDVBPESReader> &reader)=0;
 	virtual RESULT createTSRecorder(ePtr<iDVBTSRecorder> &recorder)=0;
+	virtual RESULT createTSPlayer(ePtr<iDVBTSPlayer> &player)=0;
 	virtual RESULT getMPEGDecoder(ePtr<iTSMPEGDecoder> &reader, int primary=1)=0;
 	virtual RESULT getSTC(pts_t &pts, int num=0)=0;
 	virtual RESULT getCADemuxID(uint8_t &id)=0;
diff -Naur enigma2.ori/lib/dvb/pmt.cpp enigma2/lib/dvb/pmt.cpp
--- enigma2.ori/lib/dvb/pmt.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/pmt.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -50,7 +50,7 @@
 	if ((m_last_channel_state != iDVBChannel::state_ok)
 		&& (state == iDVBChannel::state_ok) && (!m_demux))
 	{
-		if (m_channel)
+		if (m_channel && !m_pvr_channel)
 		{
 			if (m_pvr_demux_tmp)
 			{
@@ -74,7 +74,9 @@
 				else
 					m_PMT.begin(eApp, eDVBPMTSpec(m_pmt_pid, m_reference.getServiceID().get()), m_demux);
 			}
+		}
 
+		if (m_demux || m_pvr_channel) {
 			if ( m_service && !m_service->cacheEmpty() )
 				serviceEvent(eventNewProgramInfo);
 		}
@@ -1135,11 +1137,10 @@
 
 		if (m_pvr_channel)
 		{
+printf("m_pvr_channel !!!!!!!!!!!!!!!!\n");
 			m_pvr_channel->setCueSheet(cue);
 
-			if (m_pvr_channel->getDemux(m_pvr_demux_tmp, (!m_use_decode_demux) ? 0 : iDVBChannel::capDecode))
-				eDebug("Allocating %s-decoding a demux for PVR channel failed.", m_use_decode_demux ? "" : "non-");
-			else if (source)
+			if (source)
 				m_pvr_channel->playSource(source, streaminfo_file);
 			else
 				m_pvr_channel->playFile(ref.path.c_str());
diff -Naur enigma2.ori/lib/dvb/tstools.cpp enigma2/lib/dvb/tstools.cpp
--- enigma2.ori/lib/dvb/tstools.cpp	2011-12-15 19:03:29.000000000 +0100
+++ enigma2/lib/dvb/tstools.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -95,7 +95,8 @@
 
 		if (packet[0] != 0x47)
 		{
-			const unsigned char* match = memchr(packet+1, 0x47, 188-1);
+			const unsigned char* match = NULL;
+			//const unsigned char* match = memchr(packet+1, 0x47, 188-1);
 			if (match != NULL)
 			{
 				eDebug("resync %d", match - packet);
diff -Naur enigma2.ori/lib/dvb/volume.cpp enigma2/lib/dvb/volume.cpp
--- enigma2.ori/lib/dvb/volume.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/volume.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -1,21 +1,5 @@
-#include <lib/base/eerror.h>
 #include <lib/dvb/volume.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-
-#if HAVE_DVB_API_VERSION < 3
-#define VIDEO_DEV "/dev/dvb/card0/video0"
-#define AUDIO_DEV "/dev/dvb/card0/audio0"
-#include <ost/audio.h>
-#include <ost/video.h>
-#else
-#define VIDEO_DEV "/dev/dvb/adapter0/video0"
-#define AUDIO_DEV "/dev/dvb/adapter0/audio0"
-#include <linux/dvb/audio.h>
-#include <linux/dvb/video.h>
-#endif
+#include <lib/gdi/xineLib.h>
 
 eDVBVolumecontrol* eDVBVolumecontrol::instance = NULL;
 
@@ -36,67 +20,6 @@
 	setVolume(100, 100);
 }
 
-int eDVBVolumecontrol::openMixer()
-{
-#ifdef HAVE_ALSA
-	if (!mainVolume)
-	{
-		int err;
-		char *card = "default";
-
-		/* Perform the necessary pre-amble to start up ALSA Mixer */
-		err = snd_mixer_open(&alsaMixerHandle, 0);
-		if (err < 0)
-		{
-			eDebug("Mixer %s open error: %s", card, snd_strerror(err));
-			return err;
-		}
-		err = snd_mixer_attach(alsaMixerHandle, card);
-		if (err < 0)
-		{
-			eDebug("Mixer attach %s error: %s", card, snd_strerror(err));
-			snd_mixer_close(alsaMixerHandle);
-			alsaMixerHandle = NULL;
-			return err;
-		}
-		err = snd_mixer_selem_register(alsaMixerHandle, NULL, NULL);
-		if (err < 0)
-		{
-			eDebug("Mixer register error: %s", snd_strerror(err));
-			snd_mixer_close(alsaMixerHandle);
-			alsaMixerHandle = NULL;
-			return err;
-		}
-		err = snd_mixer_load(alsaMixerHandle);
-		if (err < 0)
-		{
-			eDebug("Mixer %s load error: %s", card, snd_strerror(err));
-			snd_mixer_close(alsaMixerHandle);
-			alsaMixerHandle = NULL;
-			return err;
-		}
-
-		/* Set up Decoder 0 as the main volume control. */
-		snd_mixer_selem_id_t *sid;
-		snd_mixer_selem_id_alloca(&sid);
-		snd_mixer_selem_id_set_name(sid, ALSA_VOLUME_MIXER);
-		snd_mixer_selem_id_set_index(sid, 0);
-		mainVolume = snd_mixer_find_selem(alsaMixerHandle, sid);
-	}
-	return mainVolume ? 0 : -1;
-#else
-	return open( AUDIO_DEV, O_RDWR );
-#endif
-}
-
-void eDVBVolumecontrol::closeMixer(int fd)
-{
-#ifdef HAVE_ALSA
-	/* we want to keep the alsa mixer */
-#else
-	close(fd);
-#endif
-}
 
 void eDVBVolumecontrol::volumeUp(int left, int right)
 {
@@ -119,60 +42,15 @@
 
 void eDVBVolumecontrol::setVolume(int left, int right)
 {
-		/* left, right is 0..100 */
+	cXineLib *xineLib = cXineLib::getInstance();
+
+	/* left, right is 0..100 */
 	leftVol = checkVolume(left);
 	rightVol = checkVolume(right);
 
-#ifdef HAVE_ALSA
-	if (mainVolume) snd_mixer_selem_set_playback_volume_all(mainVolume, muted ? 0 : leftVol);
-#else
-		/* convert to -1dB steps */
-	left = 63 - leftVol * 63 / 100;
-	right = 63 - rightVol * 63 / 100;
-		/* now range is 63..0, where 0 is loudest */
-
-#if HAVE_DVB_API_VERSION < 3
-	audioMixer_t mixer;
-#else
-	audio_mixer_t mixer;
-#endif
-
-#if HAVE_DVB_API_VERSION < 3
-		/* convert to linear scale. 0 = loudest, ..63 */
-	mixer.volume_left = 63.0-pow(1.068241, 63-left);
-	mixer.volume_right = 63.0-pow(1.068241, 63-right);
-#else
-	mixer.volume_left = left;
-	mixer.volume_right = right;
-#endif
-
-	eDebug("Setvolume: %d %d (raw)", leftVol, rightVol);
-	eDebug("Setvolume: %d %d (-1db)", left, right);
-#if HAVE_DVB_API_VERSION < 3
-	eDebug("Setvolume: %d %d (lin)", mixer.volume_left, mixer.volume_right);
-#endif
-
-	int fd = openMixer();
-	if (fd >= 0)
-	{
-#ifdef HAVE_DVB_API_VERSION
-		ioctl(fd, AUDIO_SET_MIXER, &mixer);
-#endif
-		closeMixer(fd);
-		return;
-	}
-
-	//HACK?
-	FILE *f;
-	if((f = fopen("/proc/stb/avs/0/volume", "wb")) == NULL) {
-		eDebug("cannot open /proc/stb/avs/0/volume(%m)");
-		return;
-	}
-
-	fprintf(f, "%d", left); /* in -1dB */
-
-	fclose(f);
-#endif
+	xineLib->setVolume(leftVol);
+	
+	eDebug("Setvolume: %d %d", leftVol, rightVol);
 }
 
 int eDVBVolumecontrol::getVolume()
@@ -188,54 +66,18 @@
 
 void eDVBVolumecontrol::volumeMute()
 {
-#ifdef HAVE_ALSA
-	if (mainVolume) snd_mixer_selem_set_playback_volume_all(mainVolume, 0);
-	muted = true;
-#else
-	int fd = openMixer();
-#ifdef HAVE_DVB_API_VERSION	
-	ioctl(fd, AUDIO_SET_MUTE, true);
-#endif
-	closeMixer(fd);
-	muted = true;
+	cXineLib *xineLib = cXineLib::getInstance();
 
-	//HACK?
-	FILE *f;
-	if((f = fopen("/proc/stb/audio/j1_mute", "wb")) == NULL) {
-		eDebug("cannot open /proc/stb/audio/j1_mute(%m)");
-		return;
-	}
-	
-	fprintf(f, "%d", 1);
-
-	fclose(f);
-#endif
+	xineLib->setVolumeMute(1);
+	muted = true;
 }
 
 void eDVBVolumecontrol::volumeUnMute()
 {
-#ifdef HAVE_ALSA
-	if (mainVolume) snd_mixer_selem_set_playback_volume_all(mainVolume, leftVol);
-	muted = false;
-#else
-	int fd = openMixer();
-#ifdef HAVE_DVB_API_VERSION
-	ioctl(fd, AUDIO_SET_MUTE, false);
-#endif
-	closeMixer(fd);
-	muted = false;
+	cXineLib *xineLib = cXineLib::getInstance();
 
-	//HACK?
-	FILE *f;
-	if((f = fopen("/proc/stb/audio/j1_mute", "wb")) == NULL) {
-		eDebug("cannot open /proc/stb/audio/j1_mute(%m)");
-		return;
-	}
-	
-	fprintf(f, "%d", 0);
-
-	fclose(f);
-#endif
+	xineLib->setVolumeMute(0);
+	muted = false;
 }
 
 void eDVBVolumecontrol::volumeToggleMute()
diff -Naur enigma2.ori/lib/dvb/volume.h enigma2/lib/dvb/volume.h
--- enigma2.ori/lib/dvb/volume.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb/volume.h	2011-12-16 06:15:29.000000000 +0100
@@ -19,9 +19,6 @@
 #ifdef SWIG
 	~eDVBVolumecontrol();
 #endif
-	int openMixer();
-	void closeMixer(int fd);
-	
 	bool muted;
 	int leftVol, rightVol;
 	
diff -Naur enigma2.ori/lib/dvb_ci/dvbci.cpp enigma2/lib/dvb_ci/dvbci.cpp
--- enigma2.ori/lib/dvb_ci/dvbci.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/dvb_ci/dvbci.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -653,7 +653,7 @@
 	if (getNumOfSlots() > 1) // FIXME .. we force DM8000 when more than one CI Slot is avail
 	{
 		char buf[64];
-		snprintf(buf, 64, "/proc/stb/tsmux/input%d", tuner_no);
+		snprintf(buf, 64, "/usr/local/e2/etc/stb/tsmux/input%d", tuner_no);
 
 		FILE *input=0;
 		if((input = fopen(buf, "wb")) == NULL) {
@@ -700,7 +700,7 @@
 	else  // DM7025
 	{
 		char buf[64];
-		snprintf(buf, 64, "/proc/stb/tsmux/input%d", tuner_no);
+		snprintf(buf, 64, "/usr/local/e2/etc/stb/tsmux/input%d", tuner_no);
 
 		if (tuner_no > 1)
 			eDebug("setInputSource(%d, %d) failed... dm7025 just have two inputs", tuner_no, (int)source);
@@ -1277,7 +1277,7 @@
 	if (eDVBCIInterfaces::getInstance()->getNumOfSlots() > 1) // FIXME .. we force DM8000 when more than one CI Slot is avail
 	{
 		char buf[64];
-		snprintf(buf, 64, "/proc/stb/tsmux/ci%d_input", slotid);
+		snprintf(buf, 64, "/usr/local/e2/etc/stb/tsmux/ci%d_input", slotid);
 		FILE *ci = fopen(buf, "wb");
 		switch(source)
 		{
@@ -1315,9 +1315,9 @@
 	{
 //		eDebug("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
 //		eDebug("eDVBCISlot::enableTS(%d %d)", enable, (int)source);
-		FILE *ci = fopen("/proc/stb/tsmux/input2", "wb");
+		FILE *ci = fopen("/usr/local/e2/etc/stb/tsmux/input2", "wb");
 		if(ci == NULL) {
-			eDebug("cannot open /proc/stb/tsmux/input2");
+			eDebug("cannot open /usr/local/e2/etc/stb/tsmux/input2");
 			return 0;
 		}
 		if (source != TUNER_A && source != TUNER_B)
@@ -1333,7 +1333,7 @@
 int eDVBCISlot::setClockRate(int rate)
 {
 	char buf[64];
-	snprintf(buf, 64, "/proc/stb/tsmux/ci%d_tsclk", slotid);
+	snprintf(buf, 64, "/usr/local/e2/etc/stb/tsmux/ci%d_tsclk", slotid);
 	FILE *ci = fopen(buf, "wb");
 	if (ci)
 	{
diff -Naur enigma2.ori/lib/gdi/Makefile.am enigma2/lib/gdi/Makefile.am
--- enigma2.ori/lib/gdi/Makefile.am	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/gdi/Makefile.am	2011-12-16 06:15:29.000000000 +0100
@@ -47,12 +47,19 @@
 	picload.h \
 	region.h
 
-if HAVE_LIBSDL
+if HAVE_XLIB
 libenigma_gdi_a_SOURCES += \
-	sdl.cpp \
-	sdl.h
+	gxlibdc.cpp \
+	gxlibdc.h \
+	xineLib.cpp \
+	xineLib.h
 else
 libenigma_gdi_a_SOURCES += \
-	gfbdc.cpp \
-	gfbdc.h
+	sdl.cpp \
+	sdl.h
 endif
+
+#libenigma_gdi_a_SOURCES += \
+#	gfbdc.cpp \
+#	gfbdc.h
+#endif
diff -Naur enigma2.ori/lib/gdi/gxlibdc.cpp enigma2/lib/gdi/gxlibdc.cpp
--- enigma2.ori/lib/gdi/gxlibdc.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/gdi/gxlibdc.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,356 @@
+#include <fstream>
+#include <lib/gdi/gxlibdc.h>
+#include <lib/actions/action.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+#include <lib/base/eenv.h>
+#include <lib/driver/input_fake.h>
+#include <lib/driver/rcxlib.h>
+
+gXlibDC   *gXlibDC::instance;
+Display   *gXlibDC::display;
+Window    gXlibDC::window;
+int       gXlibDC::width, gXlibDC::height;
+double    gXlibDC::pixel_aspect;
+
+static const std::string getConfigString(const std::string &key, const std::string &defaultValue)
+{
+	std::string value = defaultValue;
+
+	// get value from enigma2 settings file
+	std::ifstream in(eEnv::resolve("${sysconfdir}/enigma2/settings").c_str());
+	if (in.good()) {
+		do {
+			std::string line;
+			std::getline(in, line);
+			size_t size = key.size();
+			if (!line.compare(0, size, key) && line[size] == '=') {
+				value = line.substr(size + 1);
+				break;
+			}
+		} while (in.good());
+		in.close();
+	}
+
+	return value;
+}
+
+static bool getConfigBool(const std::string &key, bool defaultValue)
+{
+	std::string value = getConfigString(key, defaultValue ? "true" : "false");
+	const char *cvalue = value.c_str();
+
+	if (!strcasecmp(cvalue, "true"))
+		return true;
+	if (!strcasecmp(cvalue, "false"))
+		return false;
+
+	return defaultValue;
+}
+
+gXlibDC::gXlibDC() : m_pump(eApp, 1)
+{
+	double      res_h, res_v;
+	
+	umask(0);
+	mknod("/tmp/ENIGMA_FIFO", S_IFIFO|0666, 0);
+
+	CONNECT(m_pump.recv_msg, gXlibDC::pumpEvent);
+
+	argb_buffer = NULL;
+	fullscreen = getConfigBool("config.pc.default_fullscreen", false);
+	windowWidth  = 720;
+	windowHeight = 576;
+
+	ASSERT(instance == 0);
+	instance = this;
+	
+	if(!XInitThreads())
+	{
+		eFatal("XInitThreads() failed\n");
+		return;
+	}
+
+	if((display = XOpenDisplay(getenv("DISPLAY"))) == NULL) {
+		eFatal("XOpenDisplay() failed.\n");
+		return;
+	}
+
+	screen       = XDefaultScreen(display);
+
+	if (fullscreen)	{
+		width  = DisplayWidth( display, screen );
+		height = DisplayHeight( display, screen );
+	} else {
+		width  = windowWidth;
+		height = windowHeight;
+	}
+
+	XLockDisplay(display);
+ 	window = XCreateSimpleWindow(display, XDefaultRootWindow(display), 0, 0, windowWidth, windowHeight, 0, 0, 0);
+	XSelectInput (display, window, INPUT_MOTION);
+	XMapRaised(display, window);
+	res_h = (DisplayWidth(display, screen) * 1000 / DisplayWidthMM(display, screen));
+	res_v = (DisplayHeight(display, screen) * 1000 / DisplayHeightMM(display, screen));
+	XSync(display, False);
+	XUnlockDisplay(display);
+
+	wmDelete=XInternAtom(display, "WM_DELETE_WINDOW", True);
+	XSetWMProtocols(display, window, &wmDelete, 1);
+
+	printf("Display resolution %d %d\n", DisplayWidth(display, screen), DisplayHeight(display, screen));
+
+	vis.display           = display;
+	vis.screen            = screen;
+	vis.d                 = window;
+	vis.dest_size_cb      = dest_size_cb;
+	vis.frame_output_cb   = frame_output_cb;
+	vis.user_data         = NULL;
+	pixel_aspect          = res_v / res_h;
+
+	if(fabs(pixel_aspect - 1.0) < 0.01)
+		pixel_aspect = 1.0;
+
+	xineLib = new cXineLib(&vis);
+
+	setResolution(width, height); // default res
+
+	run();
+
+	/*m_surface.type = 0;
+	m_surface.clut.colors = 256;
+	m_surface.clut.data = new gRGB[m_surface.clut.colors];
+
+	m_pixmap = new gPixmap(&m_surface);
+
+	memset(m_surface.clut.data, 0, sizeof(*m_surface.clut.data)*m_surface.clut.colors);*/
+}
+
+gXlibDC::~gXlibDC()
+{
+	instance = 0;
+
+	thread_stop = true;
+	kill();
+
+	if (xineLib) {
+		delete xineLib;
+		xineLib = NULL;
+	}
+
+	XLockDisplay(display);
+	XUnmapWindow(display, window);
+	XDestroyWindow(display, window);
+	XUnlockDisplay(display);
+
+	XCloseDisplay (display);
+}
+
+void gXlibDC::keyEvent(const XKeyEvent &event)
+{
+	eXlibInputDriver *driver = eXlibInputDriver::getInstance();
+	xineLib->getVideoFrameRate();
+	eDebug("SDL Key %s: key=%d", (event.type == KeyPress) ? "Down" : "Up", event.keycode);
+
+	if (driver)
+		driver->keyPressed(event);
+}
+
+void gXlibDC::pumpEvent(const XKeyEvent &event)
+{
+	switch (event.type) {
+	case KeyPress:
+	case KeyRelease:
+		switch (event.keycode) {
+		case 95: // F11
+			if (event.type==KeyPress) {
+				fullscreen_switch();
+			}
+			break;
+		case 53: // X
+			if (event.type==KeyPress) {
+				eDebug("Enigma2 Quit");
+				extern void quitMainloop(int exit_code);
+				quitMainloop(0);
+			}
+			break;
+		default:
+			keyEvent(event);
+			break;
+		}
+		break;
+	}
+}
+
+/*void gSDLDC::pushEvent(enum event code, void *data1, void *data2)
+{
+	SDL_Event event;
+
+	event.type = SDL_USEREVENT;
+	event.user.code = code;
+	event.user.data1 = data1;
+	event.user.data2 = data2;
+
+	SDL_PushEvent(&event);
+}*/
+
+void gXlibDC::exec(const gOpcode *o)
+{
+	switch (o->opcode)
+	{
+	case gOpcode::flush:
+		eDebug("FLUSH");
+		xineLib->showOsd();
+		break;
+	default:
+		gDC::exec(o);
+		break;
+	}
+}
+
+void gXlibDC::setResolution(int xres, int yres)
+{
+	printf("setResolution %d %d\n", xres, yres);
+	windowWidth  = xres;
+	windowHeight = yres;
+
+	if (!fullscreen) {
+		width = xres;
+		height = yres;
+	}
+
+	if (argb_buffer)
+		delete [] argb_buffer;
+	argb_buffer = new uint32_t[windowWidth*windowHeight];
+
+	xineLib->newOsd(windowWidth, windowHeight, argb_buffer);
+
+	m_surface.type = 0;
+	m_surface.x = windowWidth;
+	m_surface.y = windowHeight;
+	m_surface.bpp = 32;
+	m_surface.bypp = 4;
+	m_surface.stride = windowWidth*4;
+	m_surface.data = argb_buffer;
+	m_surface.offset = 0;
+
+	m_pixmap = new gPixmap(&m_surface);
+
+	updateWindowState();
+}
+
+void gXlibDC::updateWindowState() {
+	if (fullscreen)	{
+		width  = DisplayWidth( display, screen );
+		height = DisplayHeight( display, screen );
+	} else {
+		width  = windowWidth;
+		height = windowHeight;
+	}
+
+	XEvent xev;
+	Atom wm_state = XInternAtom(display, "_NET_WM_STATE", False);
+	Atom fullscreenAtom = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", False);
+
+	memset(&xev, 0, sizeof(xev));
+	xev.type = ClientMessage;
+	xev.xclient.window = window;
+	xev.xclient.message_type = wm_state;
+	xev.xclient.format = 32;
+	xev.xclient.data.l[0] = fullscreen ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
+	xev.xclient.data.l[1] = fullscreenAtom;
+	xev.xclient.data.l[2] = 0;
+	XSendEvent(display, XDefaultRootWindow(display), False, SubstructureNotifyMask, &xev);
+
+	if (!fullscreen)
+		XResizeWindow(display, window, windowWidth, windowHeight);
+
+	XFlush(display);
+
+	xineLib->updateWindowSize(width, height);
+	xineLib->showOsd();
+}
+
+void gXlibDC::fullscreen_switch() {
+	printf("FULLSCREEN EVENT\n");
+	fullscreen ^= 1;
+	updateWindowState();
+}
+
+void gXlibDC::evFlip()
+{
+	//SDL_Flip(m_screen);
+}
+
+void gXlibDC::thread()
+{
+	hasStarted();
+
+	int x11_fd = ConnectionNumber(display);
+	thread_stop = false;
+	fd_set in_fds;
+	struct timeval tv;
+	XEvent event;
+
+	while (!thread_stop) {
+		FD_ZERO(&in_fds);
+		FD_SET(x11_fd, &in_fds);
+
+		tv.tv_usec = 100000;
+		tv.tv_sec = 0;
+
+		if (select(x11_fd+1, &in_fds, 0, 0, &tv))
+			printf("Event Received!\n");
+
+		while(XPending(display))
+		{
+			XNextEvent(display, &event);
+			printf("XNextEvent %d\n", event.type);
+			switch(event.type)
+			{
+			case KeyPress:
+			case KeyRelease:
+				{
+					XKeyEvent& xKeyEvent = (XKeyEvent&)event;
+					m_pump.send(xKeyEvent);
+				}
+				break;
+			case ClientMessage:
+				if (event.xclient.data.l[0] == wmDelete) {
+					thread_stop = true;
+					XKeyEvent xKeyEvent;
+					xKeyEvent.type = KeyPress;
+					xKeyEvent.keycode = 53; // X
+					m_pump.send(xKeyEvent);
+				}
+				break;
+			case Expose:
+				xineLib->showOsd();
+				break;
+			}
+		}
+	}
+}
+
+void gXlibDC::frame_output_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+		int *dest_x, int *dest_y, int *dest_width, int *dest_height, double *dest_pixel_aspect,
+		int *win_x, int *win_y)
+{
+	*dest_x            = 0;
+	*dest_y            = 0;
+	*win_x             = 0;
+	*win_y             = 0;
+	*dest_width        = gXlibDC::width;
+	*dest_height       = gXlibDC::height;
+	*dest_pixel_aspect = gXlibDC::pixel_aspect;
+}
+
+void gXlibDC::dest_size_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+			 int *dest_width, int *dest_height, double *dest_pixel_aspect)
+{
+	*dest_width        = gXlibDC::width;
+	*dest_height       = gXlibDC::height;
+	*dest_pixel_aspect = gXlibDC::pixel_aspect;
+}
+
+eAutoInitPtr<gXlibDC> init_gXlibDC(eAutoInitNumbers::graphic-1, "gXlibDC");
diff -Naur enigma2.ori/lib/gdi/gxlibdc.h enigma2/lib/gdi/gxlibdc.h
--- enigma2.ori/lib/gdi/gxlibdc.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/gdi/gxlibdc.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,78 @@
+#ifndef __lib_gdi_gxlibdc_h
+#define __lib_gdi_gxlibdc_h
+
+#include <lib/base/thread.h>
+#include <lib/gdi/gmaindc.h>
+#include <lib/dvb/idvb.h>
+
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+
+#include <lib/gdi/xineLib.h>
+
+#define INPUT_MOTION (ExposureMask | KeyPressMask | KeyReleaseMask)
+
+enum
+{
+	_NET_WM_STATE_REMOVE =0,
+	_NET_WM_STATE_ADD = 1,
+	_NET_WM_STATE_TOGGLE =2
+};
+
+class gXlibDC: public gMainDC, public eThread, public Object
+{
+private:
+	static gXlibDC       *instance;
+
+	int                  screen;
+	x11_visual_t         vis;
+	int                  fullscreen;
+	int                  windowWidth, windowHeight;
+	cXineLib            *xineLib;
+	gSurface             m_surface;
+	uint32_t            *argb_buffer;
+	bool                 thread_stop;
+
+	Atom                 wmDelete;
+
+	void exec(const gOpcode *opcode);
+
+	eFixedMessagePump<XKeyEvent> m_pump;
+	void keyEvent(const XKeyEvent &event);
+	void pumpEvent(const XKeyEvent &event);
+	virtual void thread();
+
+	enum event {
+		EV_SET_VIDEO_MODE,
+		EV_FLIP,
+		EV_QUIT,
+	};
+
+	//void pushEvent(enum event code, void *data1 = 0, void *data2 = 0);
+	void evFlip();
+	void fullscreen_switch();
+	void updateWindowState();
+
+public:
+	static int            width, height;
+	static double         pixel_aspect;
+	static Display       *display;
+	static Window         window;
+
+	gXlibDC();
+	virtual ~gXlibDC();
+
+	static gXlibDC *getInstance() { return instance; }
+	void setResolution(int xres, int yres);
+	int islocked() { return 0; }
+
+	static void frame_output_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+			int *dest_x, int *dest_y, int *dest_width, int *dest_height, double *dest_pixel_aspect,
+			int *win_x, int *win_y);
+	static void dest_size_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+			 int *dest_width, int *dest_height, double *dest_pixel_aspect);
+
+};
+
+#endif
diff -Naur enigma2.ori/lib/gdi/lcd.cpp enigma2/lib/gdi/lcd.cpp
--- enigma2.ori/lib/gdi/lcd.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/gdi/lcd.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -75,8 +75,8 @@
 	lcdfd = open("/dev/dbox/oled0", O_RDWR);
 	if (lcdfd < 0)
 	{
-		if (!access("/proc/stb/lcd/oled_brightness", W_OK) ||
-		    !access("/proc/stb/fp/oled_brightness", W_OK) )
+		if (!access("/usr/local/e2/etc/stb/lcd/oled_brightness", W_OK) ||
+		    !access("/usr/local/e2/etc/stb/fp/oled_brightness", W_OK) )
 			is_oled = 2;
 		lcdfd = open("/dev/dbox/lcd0", O_RDWR);
 	} else
@@ -92,20 +92,20 @@
 		int i=LCD_MODE_BIN;
 		ioctl(lcdfd, LCD_IOCTL_ASC_MODE, &i);
 		inverted=0;
-		FILE *f = fopen("/proc/stb/lcd/xres", "r");
+		FILE *f = fopen("/usr/local/e2/etc/stb/lcd/xres", "r");
 		if (f)
 		{
 			int tmp;
 			if (fscanf(f, "%x", &tmp) == 1)
 				xres = tmp;
 			fclose(f);
-			f = fopen("/proc/stb/lcd/yres", "r");
+			f = fopen("/usr/local/e2/etc/stb/lcd/yres", "r");
 			if (f)
 			{
 				if (fscanf(f, "%x", &tmp) == 1)
 					yres = tmp;
 				fclose(f);
-				f = fopen("/proc/stb/lcd/bpp", "r");
+				f = fopen("/usr/local/e2/etc/stb/lcd/bpp", "r");
 				if (f)
 				{
 					if (fscanf(f, "%x", &tmp) == 1)
@@ -151,13 +151,13 @@
 {
 #ifndef NO_LCD
 	eDebug("setLCDBrightness %d", brightness);
-	FILE *f=fopen("/proc/stb/lcd/oled_brightness", "w");
+	FILE *f=fopen("/usr/local/e2/etc/stb/lcd/oled_brightness", "w");
 	if (!f)
-		f = fopen("/proc/stb/fp/oled_brightness", "w");
+		f = fopen("/usr/local/e2/etc/stb/fp/oled_brightness", "w");
 	if (f)
 	{
 		if (fprintf(f, "%d", brightness) == 0)
-			eDebug("write /proc/stb/lcd/oled_brightness failed!! (%m)");
+			eDebug("write /usr/local/e2/etc/stb/lcd/oled_brightness failed!! (%m)");
 		fclose(f);
 	}
 	else
diff -Naur enigma2.ori/lib/gdi/xineLib.cpp enigma2/lib/gdi/xineLib.cpp
--- enigma2.ori/lib/gdi/xineLib.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/gdi/xineLib.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,563 @@
+#include <fstream>
+#include <lib/gdi/xineLib.h>
+#include <lib/base/eenv.h>
+
+cXineLib   *cXineLib::instance;
+
+DEFINE_REF(cXineLib);
+
+cXineLib::cXineLib(x11_visual_t *vis) : m_pump(eApp, 1) {
+	char        configfile[150];
+	char        vo_driver[] = "auto";
+	char        ao_driver[] = "alsa";
+
+	instance = this;
+	osd = NULL;
+	stream = NULL;
+	end_of_stream = false;
+	videoPlayed = false;
+
+	printf("XINE-LIB version: %s\n", xine_get_version_string() );
+
+	xine = xine_new();
+	strcpy(configfile, eEnv::resolve("${datadir}/enigma2/xine.conf").c_str());
+	printf("configfile  %s\n", configfile);
+	xine_config_load(xine, configfile);
+	xine_init(xine);
+
+	if((vo_port = xine_open_video_driver(xine, vo_driver, XINE_VISUAL_TYPE_X11, (void *) vis)) == NULL)
+	{
+		printf("I'm unable to initialize '%s' video driver. Giving up.\n", vo_driver);
+		return;
+	}
+
+	ao_port     = xine_open_audio_driver(xine , ao_driver, NULL);
+	stream      = xine_stream_new(xine, ao_port, vo_port);
+
+	if ( (!xine_open(stream, eEnv::resolve("${sysconfdir}/tuxbox/logo.mvi").c_str()))
+			|| (!xine_play(stream, 0, 0)) ) {
+		return;
+	}
+
+	//setPrebuffer(150000);
+	xine_engine_set_param(xine, XINE_ENGINE_PARAM_VERBOSITY, XINE_VERBOSITY_DEBUG);
+
+	xine_queue = xine_event_new_queue (stream);
+	xine_event_create_listener_thread(xine_queue, xine_event_handler, this);
+
+	CONNECT(m_pump.recv_msg, cXineLib::pumpEvent);
+
+	m_width     = 0;
+	m_height    = 0;
+	m_framerate = 0;
+	m_aspect    = -1;
+	m_windowAspectRatio = 0;
+	m_policy43 = 0;
+	m_policy169 = 0;
+
+	m_sharpness = 0;
+	m_noise = 0;
+}
+
+cXineLib::~cXineLib() {
+	instance = 0;
+
+	if (stream)
+	{
+		xine_stop(stream);
+		xine_close(stream);
+
+		if (xine_queue)
+		{
+			xine_event_dispose_queue(xine_queue);
+			xine_queue = 0;
+		}
+
+		_x_demux_flush_engine(stream);
+
+		xine_dispose(stream);
+		stream = NULL;
+	}
+
+	if (ao_port)
+		xine_close_audio_driver(xine, ao_port);
+	if (vo_port)
+		xine_close_video_driver(xine, vo_port);
+}
+
+void cXineLib::setVolume(int value) {
+//	xine_set_param (stream, XINE_PARAM_AUDIO_VOLUME, value);
+	xine_set_param (stream, XINE_PARAM_AUDIO_AMP_LEVEL , value);
+}
+
+void cXineLib::setVolumeMute(int value) {
+//	xine_set_param (stream, XINE_PARAM_AUDIO_MUTE, value==0?0:1);
+	xine_set_param(stream, XINE_PARAM_AUDIO_AMP_MUTE, value==0?0:1);
+}
+
+void cXineLib::showOsd() {
+	xine_osd_show_scaled(osd, 0);
+	//stream->osd_renderer->draw_bitmap(osd, (uint8_t*)m_surface.data, 0, 0, 720, 576, temp_bitmap_mapping);
+}
+
+void cXineLib::newOsd(int width, int height, uint32_t *argb_buffer) {
+	osdWidth  = width;
+	osdHeight = height;
+
+	if (osd)
+		xine_osd_free(osd);
+
+	osd = xine_osd_new(stream, 0, 0, osdWidth, osdHeight);
+	xine_osd_set_extent(osd, osdWidth, osdHeight);
+	xine_osd_set_argb_buffer(osd, argb_buffer, 0, 0, osdWidth, osdHeight);
+}
+
+void cXineLib::playVideo(void) {
+	xine_stop(stream);
+	end_of_stream = false;
+	videoPlayed = false;
+
+	printf("XINE try START !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+	if ( !xine_open(stream, "enigma:/") ) {
+		printf("Unable to open stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+	}
+
+//	setStreamType(1);
+//	setStreamType(0);
+xine_pids_data_t data;
+xine_event_t event;
+  event.type = XINE_EVENT_PIDS_CHANGE;
+  data.vpid = videoData.pid;
+  data.apid = audioData.pid;
+  event.data = &data;
+  event.data_length = sizeof (xine_pids_data_t);
+
+  printf ("input_dvb: sending event\n");
+
+  xine_event_send (stream, &event);
+setStreamType(1);
+setStreamType(0);
+
+        //_x_demux_control_start(stream);
+        //_x_demux_seek(stream, 0, 0, 0);
+
+	if( !xine_play(stream, 0, 0) ) {
+		printf("Unable to play stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+	}
+	printf("XINE STARTED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+
+	videoPlayed = true;
+}
+
+void cXineLib::stopVideo(void) {
+	xine_stop(stream);
+	xine_close (stream);
+	end_of_stream = false;
+	videoPlayed = false;
+}
+
+void cXineLib::setStreamType(int video) {
+	xine_event_t event;
+
+	if (video==1) {
+		event.type = XINE_EVENT_SET_VIDEO_STREAMTYPE;
+		event.data = &videoData;
+	} else {
+		event.type = XINE_EVENT_SET_AUDIO_STREAMTYPE;
+		event.data = &audioData;
+	}
+
+	event.data_length = sizeof (xine_streamtype_data_t);
+
+	xine_event_send (stream, &event);
+}
+
+void cXineLib::setVideoType(int pid, int type) {
+	videoData.pid = pid;
+	videoData.streamtype = type;
+}
+
+//////////////////////7
+void cXineLib::FilmVideo(char *mrl) {
+ASSERT(stream);
+	
+	if (!xine_open(stream, mrl))
+	{
+		eWarning("xine_open failed!");
+		return ;
+	}
+	
+	if (!xine_play(stream, 0, 0))
+	{
+		eWarning("xine_play failed!");
+		return ;
+	}
+videoPlayed = true;
+}
+
+int
+cXineLib::VideoPause()
+{
+xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
+return 1;
+}
+
+
+int
+cXineLib::VideoResume()
+{
+	int ret;
+	/* Resume the playback. */
+	ret = xine_get_param(stream, XINE_PARAM_SPEED);
+	if( ret != XINE_SPEED_NORMAL ){
+		xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
+	}
+	return 1;
+}
+
+int
+cXineLib::VideoGeriT(pts_t Sar)
+{// 10 saniye Geri Sarma 
+pts_t geriSar;
+xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
+VideoPosisyon();
+geriSar=Vpos+Sar;
+printf("%d---Vpos=%d---Sar=%d",geriSar,Vpos,Sar);
+if (geriSar<0) geriSar=0;
+xine_play(stream, 0, geriSar);
+xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
+return 1;
+}
+
+int
+cXineLib::VideoIleriF()
+{
+	int ret;
+	/* Slow the playback. */
+	ret = xine_get_param(stream, XINE_PARAM_SPEED);
+	if( ret != XINE_EVENT_INPUT_RIGHT){
+		xine_set_param(stream, XINE_PARAM_SPEED, XINE_EVENT_INPUT_RIGHT);
+	}
+	return 1;
+}
+
+int
+cXineLib::VideoPosisyon()
+{
+xine_get_pos_length (stream, &VposStream, &Vpos, &Vlength);
+return 1;
+}
+/*
+XINE_SPEED_SLOW_4
+XINE_SPEED_SLOW_2
+XINE_SPEED_NORMAL
+XINE_SPEED_FAST_2
+XINE_SPEED_FAST_4
+XINE_FINE_SPEED_NORMAL
+*/
+/////////////////////
+
+void cXineLib::SeekTo(long long value) {
+	xine_play(stream, value, 0);
+}
+
+void cXineLib::setAudioType(int pid, int type) {
+	audioData.pid = pid;
+	audioData.streamtype = type;
+}
+
+void cXineLib::setPrebuffer(int prebuffer) {
+	xine_set_param(stream, XINE_PARAM_METRONOM_PREBUFFER, prebuffer);
+}
+
+void cXineLib::xine_event_handler(void *user_data, const xine_event_t *event)
+{
+	cXineLib *xineLib = (cXineLib*)user_data;
+	//if (event->type!=15)
+	//	printf("I have event %d\n", event->type);
+
+	switch (event->type)
+	{
+	case XINE_EVENT_UI_PLAYBACK_FINISHED:
+		printf("XINE_EVENT_UI_PLAYBACK_FINISHED\n");
+		break;
+	case XINE_EVENT_NBC_STATS:
+		return;
+	case XINE_EVENT_FRAME_FORMAT_CHANGE:
+		printf("XINE_EVENT_FRAME_FORMAT_CHANGE\n");
+		{
+			xine_format_change_data_t* data = (xine_format_change_data_t*)event->data;
+			printf("width %d  height %d  aspect %d\n", data->width, data->height, data->aspect);
+
+			struct iTSMPEGDecoder::videoEvent evt;
+			evt.type = iTSMPEGDecoder::videoEvent::eventSizeChanged;
+			xineLib->m_aspect = evt.aspect = data->aspect;
+			xineLib->m_height = evt.height = data->height;
+			xineLib->m_width  = evt.width  = data->width;
+			xineLib->m_pump.send(evt);
+
+			xineLib->adjust_policy();
+		}
+		return;
+	case XINE_EVENT_FRAMERATE_CHANGE:
+		printf("XINE_EVENT_FRAMERATE_CHANGE\n");
+		{
+			xine_framerate_data_t* data = (xine_framerate_data_t*)event->data;
+			printf("framerate %d  \n", data->framerate);
+
+			struct iTSMPEGDecoder::videoEvent evt;
+			evt.type = iTSMPEGDecoder::videoEvent::eventFrameRateChanged;
+			xineLib->m_framerate = evt.framerate = data->framerate;
+			xineLib->m_pump.send(evt);
+		}
+		return;
+	case XINE_EVENT_PROGRESS:
+		{
+			xine_progress_data_t* data = (xine_progress_data_t*) event->data;
+			printf("XINE_EVENT_PROGRESS  %s  %d\n", data->description, data->percent);
+			if (xineLib->videoPlayed && data->percent==0)
+				xineLib->end_of_stream = true;
+		}
+		break;
+
+	default:
+		printf("xine_event_handler(): event->type: %d\n", event->type);
+		return;
+	}
+}
+
+void cXineLib::pumpEvent(const iTSMPEGDecoder::videoEvent &event)
+{
+	m_event(event);
+}
+
+int cXineLib::getVideoWidth()
+{
+	return m_width;
+}
+
+int cXineLib::getVideoHeight()
+{
+	return m_height;
+}
+
+int cXineLib::getVideoFrameRate()
+{
+	return m_framerate;
+}
+
+int cXineLib::getVideoAspect()
+{
+	return m_aspect;
+}
+
+RESULT cXineLib::getPTS(pts_t &pts)
+{
+	pts_t* last_pts_l = (pts_t*)vo_port->get_property(vo_port, VO_PROP_LAST_PTS);
+
+	pts = *last_pts_l;
+
+	if (pts != 0)
+		return 0;
+	
+	return -1;
+}
+
+void cXineLib::setVideoWindow(int window_x, int window_y, int window_width, int window_height)
+{
+	int left = window_x * windowWidth / osdWidth;
+	int top = window_y * windowHeight / osdHeight;
+	int width = window_width * windowWidth / osdWidth;
+	int height = window_height * windowHeight / osdHeight;
+
+	xine_osd_set_video_window(osd, left, top, width, height);
+	showOsd();
+}
+
+void cXineLib::updateWindowSize(int width, int height)
+{
+	windowWidth  = width;
+	windowHeight = height;
+}
+
+void cXineLib::setDeinterlace(int global, int sd, int hd)
+{
+	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_SD, sd);
+	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_HD, hd);
+	vo_port->set_property(vo_port, VO_PROP_INTERLACED, global);
+}
+
+void cXineLib::setSDfeatures(int sharpness, int noise)
+{
+	m_sharpness = sharpness;
+	m_noise = noise;
+}
+
+void cXineLib::setAspectRatio(int ratio)
+{
+	m_windowAspectRatio = ratio;
+}
+
+void cXineLib::setPolicy43(int mode)
+{
+	m_policy43 = mode;
+}
+
+void cXineLib::setPolicy169(int mode)
+{
+	m_policy169 = mode;
+}
+
+void cXineLib::setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y)
+{
+	m_zoom43_x = zoom43_x;
+	m_zoom43_y = zoom43_y;
+	m_zoom169_x = zoom169_x;
+	m_zoom169_y = zoom169_y;
+}
+
+void cXineLib::set_zoom_settings(int x, int y)
+{
+	xine_set_param(stream, XINE_PARAM_VO_ZOOM_X, x);
+	xine_set_param(stream, XINE_PARAM_VO_ZOOM_Y, y);
+}
+
+void cXineLib::set_crop_settings(int left, int right, int top, int bottom)
+{
+	xine_set_param(stream, XINE_PARAM_VO_CROP_LEFT, left);
+	xine_set_param(stream, XINE_PARAM_VO_CROP_RIGHT, right);
+	xine_set_param(stream, XINE_PARAM_VO_CROP_TOP, top);
+	xine_set_param(stream, XINE_PARAM_VO_CROP_BOTTOM, bottom);
+}
+
+void cXineLib::adjust_policy()
+{
+	switch (m_windowAspectRatio) {
+	case XINE_VO_ASPECT_AUTO:
+		printf("XINE_VO_ASPECT_AUTO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+		xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, 0);
+		set_zoom_settings(100, 100);
+	 	set_crop_settings(0, 0, 0, 0);
+		break;
+	case XINE_VO_ASPECT_4_3:
+		printf("XINE_VO_ASPECT_4_3 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+		switch (m_aspect) {
+		case 2: // 4:3
+			printf("m_policy43 %d\n", m_policy43);
+			switch (m_policy43) {
+			case 0: // scale
+			case 1: // nonlinear
+			case 2: // panscan
+			case 3: // pillarbox
+				printf("4:3 SCALE/NONLINEAR/PANSCAN/PILLARBOX\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+			 	set_crop_settings(0, 0, 0, 0);
+				break;
+			case 4: // zoom
+				printf("4:3 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
+				set_zoom_settings(m_zoom43_x, m_zoom43_y);
+	 			set_crop_settings(0, 0, 0, 0);
+				break;
+			}
+			break;
+		case 3: // 16:9
+			printf("m_policy169 %d\n", m_policy169);
+			switch (m_policy169) {
+			case 0: // scale
+				printf("16:9 SCALE\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+			 	set_crop_settings(0, 0, 0, 0);
+				break;
+			case 1: // panscan
+				printf("16:9 PANSCAN\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+			 	set_crop_settings(m_width/8, m_width/8, 0, 0);
+				break;
+			case 2: // letterbox
+				printf("16:9 LETTERBOX\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+			 	set_crop_settings(0, 0, 0, 0);
+				break;
+			case 3: // zoom
+				printf("16:9 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
+				set_zoom_settings(m_zoom169_x, m_zoom169_y);
+	 			set_crop_settings(0, 0, 0, 0);
+				break;
+			}
+			break;
+		}
+		break;
+	case XINE_VO_ASPECT_ANAMORPHIC: //16:9
+		printf("XINE_VO_ASPECT_ANAMORPHIC (16:9) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+		switch (m_aspect) {
+		case 2: // 4:3
+			switch (m_policy43) {
+			case 0: // scale
+				printf("4:3 SCALE\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+			 	set_crop_settings(0, 0, 0, 0);
+				break;
+			case 1: // nonlinear
+				printf("4:3 NONLINEAR\n");
+				break;
+			case 2: // panscan
+				printf("4:3 PANSCAN\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+			 	set_crop_settings(0, 0, m_height/8, m_height/8);
+				break;
+			case 3: // pillarbox
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+				printf("4:3 PILLARBOX\n");
+				break;
+			case 4: // zoom
+				printf("4:3 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
+				set_zoom_settings(m_zoom43_x, m_zoom43_y);
+	 			set_crop_settings(0, 0, 0, 0);
+				break;
+			}
+			break;
+		case 3: // 16:9
+			printf("m_policy169 %d\n", m_policy169);
+			switch (m_policy169) {
+			case 0: // scale
+			case 1: // panscan
+			case 2: // letterbox
+				printf("16:9 SCALE/PANSCAN/LETTERBOX\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+			 	set_crop_settings(0, 0, 0, 0);
+				break;
+			case 3: // zoom
+				printf("16:9 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
+				set_zoom_settings(m_zoom169_x, m_zoom169_y);
+	 			set_crop_settings(0, 0, 0, 0);
+				break;
+			}
+			break;
+		}
+		break;
+	}
+
+	if (m_width<=720) // SD channels
+	{
+		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, m_sharpness);
+		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, m_noise);
+	}
+	else // HD channels
+	{
+		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, 0);
+		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, 0);
+	}
+}
+
diff -Naur enigma2.ori/lib/gdi/xineLib.h enigma2/lib/gdi/xineLib.h
--- enigma2.ori/lib/gdi/xineLib.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2/lib/gdi/xineLib.h	2011-12-16 06:15:29.000000000 +0100
@@ -0,0 +1,94 @@
+#ifndef __lib_gdi_xineLib_h
+#define __lib_gdi_xineLib_h
+
+#include <lib/gdi/gpixmap.h>
+#include <xine.h>
+#include <xine/xineutils.h>
+#include <xine/xine_internal.h>
+#include <lib/dvb/idvb.h>
+#include <lib/base/message.h>
+
+class cXineLib : public Object {
+	DECLARE_REF(cXineLib);
+private:
+	static cXineLib        *instance;
+
+	xine_t                 *xine;
+	xine_stream_t          *stream;
+	xine_video_port_t      *vo_port;
+	xine_audio_port_t      *ao_port;
+	xine_osd_t             *osd;
+	xine_event_queue_t     *xine_queue;
+
+        xine_streamtype_data_t  videoData, audioData;
+
+	bool                    videoPlayed;
+	int                     osdWidth, osdHeight;
+	int                     windowWidth, windowHeight;
+
+	int m_width, m_height, m_framerate, m_aspect, m_progressive;
+	int m_windowAspectRatio, m_policy43, m_policy169;
+	int m_zoom43_x, m_zoom43_y, m_zoom169_x, m_zoom169_y;
+	int m_sharpness, m_noise;
+
+	void setStreamType(int video);
+
+	static void xine_event_handler(void *user_data, const xine_event_t *event);
+
+	eFixedMessagePump<iTSMPEGDecoder::videoEvent> m_pump;
+	void pumpEvent(const iTSMPEGDecoder::videoEvent &event);
+
+	void set_zoom_settings(int x, int y);
+	void set_crop_settings(int left, int right, int top, int bottom);
+public:
+	bool                    end_of_stream;
+
+	cXineLib(x11_visual_t *vis);
+	virtual ~cXineLib();
+
+	static cXineLib *getInstance() { return instance; }
+
+	void setPrebuffer(int prebuffer);
+	void setVolume(int value);
+	void setVolumeMute(int value);
+	void showOsd();
+	void newOsd(int width, int height, uint32_t *argb_buffer);
+	void playVideo(void);
+	void stopVideo(void);
+	void setVideoType(int pid, int type);
+	void setAudioType(int pid, int type);
+	
+	//////////////////////////////
+	void FilmVideo(char *mrl); 
+	int VideoPause();
+	int VideoResume();
+	int VideoPosisyon();
+	int VideoIleriF();
+	int VposStream;
+	int Vpos; 
+	int Vlength;
+	int VideoGeriT(pts_t Sar);
+    void SeekTo(long long value);
+	///////////////////////
+	
+
+	Signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
+
+	int getVideoWidth();
+	int getVideoHeight();
+	int getVideoFrameRate();
+	int getVideoAspect();
+	void adjust_policy();
+	RESULT getPTS(pts_t &pts);
+	void setVideoWindow(int window_x, int window_y, int window_width, int window_height);
+	void updateWindowSize(int width, int height);
+
+	void setDeinterlace(int global, int sd, int hd);
+	void setSDfeatures(int sharpness, int noise);
+	void setAspectRatio(int ratio);
+	void setPolicy43(int mode);
+	void setPolicy169(int mode);
+	void setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y);
+};
+
+#endif
diff -Naur enigma2.ori/lib/gui/evideo.cpp enigma2/lib/gui/evideo.cpp
--- enigma2.ori/lib/gui/evideo.cpp	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/gui/evideo.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -1,8 +1,24 @@
 #include <lib/gui/evideo.h>
 #include <lib/gui/ewidgetdesktop.h>
+#include <lib/gdi/xineLib.h>
+
+ePtr<eTimer> fullsizeTimer;
+//int eVideoWidget::pendingFullsize = 0;
+static int pendingFullsize;
+
+void setFullsize()
+{
+	for (int decoder=0; decoder < 1; ++decoder)
+	{
+		if (pendingFullsize & (1 << decoder))
+		{
+			cXineLib* xineLib = cXineLib::getInstance();
+			xineLib->setVideoWindow(0, 0, 0, 0);
+			pendingFullsize &= ~(1 << decoder);
+		}
+	}
+}
 
-ePtr<eTimer> eVideoWidget::fullsizeTimer;
-int eVideoWidget::pendingFullsize = 0;
 
 eVideoWidget::eVideoWidget(eWidget *parent)
 	:eLabel(parent), m_fb_size(720, 576), m_state(0), m_decoder(1)
@@ -10,7 +26,7 @@
 	if (!fullsizeTimer)
 	{
 		fullsizeTimer = eTimer::create(eApp);
-		fullsizeTimer->timeout.connect(slot(eVideoWidget::setFullsize));
+		fullsizeTimer->timeout.connect(slot(setFullsize));
 	}
 	parent->setPositionNotifyChild(1);
 }
@@ -67,17 +83,6 @@
 	writeProc(filename + "apply", 1);
 }
 
-void eVideoWidget::setFullsize()
-{
-	for (int decoder=0; decoder < 1; ++decoder)
-	{
-		if (pendingFullsize & (1 << decoder))
-		{
-			eVideoWidget::setPosition(decoder, 0, 0, 0, 0);
-			pendingFullsize &= ~(1 << decoder);
-		}
-	}
-}
 
 void eVideoWidget::updatePosition(int disable)
 {
@@ -86,22 +91,29 @@
 
 	if (disable && !(m_state & 4))
 	{
+//		eDebug("was not visible!");
 		return;
 	}
 
 	if ((m_state & 2) != 2)
 	{
+//		eDebug("no size!");
 		return;
 	}
 
+//	eDebug("position %d %d -> %d %d", position().x(), position().y(), size().width(), size().height());
+
 	eRect pos(0,0,0,0);
 	if (!disable)
 		pos = eRect(getAbsolutePosition(), size());
 	else
 		m_state &= ~4;
 
+//	eDebug("abs position %d %d -> %d %d", pos.left(), pos.top(), pos.width(), pos.height());
+
 	if (!disable && m_state & 8 && pos == m_user_rect)
 	{
+//		eDebug("matched");
 		return;
 	}
 
@@ -109,25 +121,15 @@
 	{
 		m_user_rect = pos;
 		m_state |= 1;
+//		eDebug("set user rect pos!");
 	}
 
-	int left = pos.left() * 720 / m_fb_size.width();
-	int top = pos.top() * 576 / m_fb_size.height();
-	int width = pos.width() * 720 / m_fb_size.width();
-	int height = pos.height() * 576 / m_fb_size.height();
-
-	int tmp = left - (width * 4) / 100;
-	left = tmp < 0 ? 0 : tmp;
-	tmp = top - (height * 4) / 100;
-	top = tmp < 0 ? 0 : tmp;
-	tmp = (width * 108) / 100;
-	width = left + tmp > 720 ? 720 - left : tmp;
-	tmp = (height * 108) / 100;
-	height = top + tmp > 576 ? 576 - top : tmp;
+//	eDebug("m_user_rect %d %d -> %d %d", m_user_rect.left(), m_user_rect.top(), m_user_rect.width(), m_user_rect.height());
 
 	if (!disable)
 	{
-		setPosition(m_decoder, left, top, width, height);
+		cXineLib* xineLib = cXineLib::getInstance();
+		xineLib->setVideoWindow(pos.left(), pos.top(), pos.width(), pos.height());
 		pendingFullsize &= ~(1 << m_decoder);
 		m_state |= 8;
 	}
@@ -137,8 +139,10 @@
 		pendingFullsize |= (1 << m_decoder);
 		fullsizeTimer->start(100, true);
 	}
+
 }
 
+
 void eVideoWidget::setDecoder(int decoder)
 {
 	m_decoder = decoder;
diff -Naur enigma2.ori/lib/gui/evideo.h enigma2/lib/gui/evideo.h
--- enigma2.ori/lib/gui/evideo.h	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/gui/evideo.h	2011-12-16 06:15:29.000000000 +0100
@@ -9,14 +9,14 @@
 	int m_state;
 	eRect m_user_rect;
 	int m_decoder;
-	static ePtr<eTimer> fullsizeTimer;
-	static int pendingFullsize;
+//	static ePtr<eTimer> fullsizeTimer;
+//	static int pendingFullsize;
 public:
 	eVideoWidget(eWidget *parent);
 	~eVideoWidget();
 	void setDecoder(int target);
 	void setFBSize(eSize size);
-	static void setFullsize();
+//	static void setFullsize();
 protected:
 	int event(int event, void *data=0, void *data2=0);
 	void updatePosition(int disable = 0);
diff -Naur enigma2.ori/lib/python/Components/AVSwitch.py enigma2/lib/python/Components/AVSwitch.py
--- enigma2.ori/lib/python/Components/AVSwitch.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/AVSwitch.py	2011-12-16 06:15:29.000000000 +0100
@@ -24,7 +24,7 @@
 			return (4,3)
 		elif valstr == "16_9": # auto ... 4:3 or 16:9
 			try:
-				aspect_str = open("/proc/stb/vmpeg/0/aspect", "r").read()
+				aspect_str = open("/usr/local/e2/etc/stb/vmpeg/0/aspect", "r").read()
 				if aspect_str == "1": # 4:3
 					return (4,3)
 			except IOError:
@@ -97,7 +97,9 @@
 				# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
 			"panscan": _("Pan&Scan"),  
 				# TRANSLATORS: (aspect ratio policy: display as fullscreen, even if this breaks the aspect)
-			"scale": _("Just Scale")},
+			"scale": _("Just Scale"),
+
+			"zoom": _("Zoom")},
 			default = "letterbox")
 	config.av.policy_43 = ConfigSelection(choices={
 				# TRANSLATORS: (aspect ratio policy: black bars on left/right) in doubt, keep english term.
@@ -105,9 +107,11 @@
 				# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
 			"panscan": _("Pan&Scan"),  
 				# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching the left/right)
-			"nonlinear": _("Nonlinear"),  
+			#"nonlinear": _("Nonlinear"),  
 				# TRANSLATORS: (aspect ratio policy: display as fullscreen, even if this breaks the aspect)
-			"scale": _("Just Scale")},
+			"scale": _("Just Scale"),
+
+			"zoom": _("Zoom")},
 			default = "pillarbox")
 	config.av.tvsystem = ConfigSelection(choices = {"pal": _("PAL"), "ntsc": _("NTSC"), "multinorm": _("multinorm")}, default="pal")
 	config.av.wss = ConfigEnableDisable(default = True)
@@ -142,14 +146,14 @@
 	SystemInfo["ScartSwitch"] = eAVSwitch.getInstance().haveScartSwitch()
 
 	try:
-		can_downmix = open("/proc/stb/audio/ac3_choices", "r").read()[:-1].find("downmix") != -1
+		can_downmix = open("/usr/local/e2/etc/stb/audio/ac3_choices", "r").read()[:-1].find("downmix") != -1
 	except:
 		can_downmix = False
 
 	SystemInfo["CanDownmixAC3"] = can_downmix
 	if can_downmix:
 		def setAC3Downmix(configElement):
-			open("/proc/stb/audio/ac3", "w").write(configElement.value and "downmix" or "passthrough")
+			open("/usr/local/e2/etc/stb/audio/ac3", "w").write(configElement.value and "downmix" or "passthrough")
 		config.av.downmix_ac3 = ConfigYesNo(default = True)
 		config.av.downmix_ac3.addNotifier(setAC3Downmix)
 
@@ -166,26 +170,26 @@
 		config.av.downmix_dts.addNotifier(setDTSDownmix)
 
 	try:
-		can_osd_alpha = open("/proc/stb/video/alpha", "r") and True or False
+		can_osd_alpha = open("/usr/local/e2/etc/stb/video/alpha", "r") and True or False
 	except:
 		can_osd_alpha = False
 
 	SystemInfo["CanChangeOsdAlpha"] = can_osd_alpha
 
 	def setAlpha(config):
-		open("/proc/stb/video/alpha", "w").write(str(config.value))
+		open("/usr/local/e2/etc/stb/video/alpha", "w").write(str(config.value))
 
 	if can_osd_alpha:
 		config.av.osd_alpha = ConfigSlider(default=255, limits=(0,255))
 		config.av.osd_alpha.addNotifier(setAlpha)
 
-	if os.path.exists("/proc/stb/vmpeg/0/pep_scaler_sharpness"):
+	if os.path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_scaler_sharpness"):
 		def setScaler_sharpness(config):
 			myval = int(config.value)
 			try:
 				print "--> setting scaler_sharpness to: %0.8X" % myval
-				open("/proc/stb/vmpeg/0/pep_scaler_sharpness", "w").write("%0.8X" % myval)
-				open("/proc/stb/vmpeg/0/pep_apply", "w").write("1")
+				open("/usr/local/e2/etc/stb/vmpeg/0/pep_scaler_sharpness", "w").write("%0.8X" % myval)
+				open("/usr/local/e2/etc/stb/vmpeg/0/pep_apply", "w").write("1")
 			except IOError:
 				print "couldn't write pep_scaler_sharpness"
 
diff -Naur enigma2.ori/lib/python/Components/Converter/ServiceInfo.py enigma2/lib/python/Components/Converter/ServiceInfo.py
--- enigma2.ori/lib/python/Components/Converter/ServiceInfo.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/Converter/ServiceInfo.py	2011-12-16 06:15:29.000000000 +0100
@@ -42,7 +42,7 @@
 				"TsId": (self.TSID, (iPlayableService.evUpdatedInfo,)),
 				"OnId": (self.ONID, (iPlayableService.evUpdatedInfo,)),
 				"Sid": (self.SID, (iPlayableService.evUpdatedInfo,)),
-				"Framerate": (self.FRAMERATE, (iPlayableService.evVideoSizeChanged,iPlayableService.evUpdatedInfo,)),
+				"Framerate": (self.FRAMERATE, (iPlayableService.evVideoFramerateChanged,)),
 				"TransferBPS": (self.TRANSFERBPS, (iPlayableService.evUpdatedInfo,)),
 				"HasHBBTV": (self.HAS_HBBTV, (iPlayableService.evUpdatedInfo,iPlayableService.evHBBTVInfo,)),
 				"AudioTracksAvailable": (self.AUDIOTRACKS_AVAILABLE, (iPlayableService.evUpdatedInfo,)),
diff -Naur enigma2.ori/lib/python/Components/Harddisk.py enigma2/lib/python/Components/Harddisk.py
--- enigma2.ori/lib/python/Components/Harddisk.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/Harddisk.py	2011-12-16 06:15:29.000000000 +0100
@@ -560,7 +560,7 @@
 		self.partitions = [ ]
 		self.devices_scanned_on_init = [ ]
 		self.on_partition_list_change = CList()
-		self.enumerateBlockDevices()
+#		self.enumerateBlockDevices()
 		# Find stuff not detected by the enumeration
 		p = (
 			("/media/hdd", _("Harddisk")),
diff -Naur enigma2.ori/lib/python/Components/InputDevice.py enigma2/lib/python/Components/InputDevice.py
--- enigma2.ori/lib/python/Components/InputDevice.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/InputDevice.py	2011-12-16 06:15:29.000000000 +0100
@@ -8,8 +8,8 @@
 # asm-generic/ioctl.h
 IOC_NRBITS = 8L
 IOC_TYPEBITS = 8L
-IOC_SIZEBITS = 13L
-IOC_DIRBITS = 3L
+IOC_SIZEBITS = 14L
+IOC_DIRBITS = 2L
 
 IOC_NRSHIFT = 0L
 IOC_TYPESHIFT = IOC_NRSHIFT+IOC_NRBITS
diff -Naur enigma2.ori/lib/python/Components/NimManager.py enigma2/lib/python/Components/NimManager.py
--- enigma2.ori/lib/python/Components/NimManager.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/NimManager.py	2011-12-16 06:15:29.000000000 +0100
@@ -538,12 +538,12 @@
 	def setInternalLink(self):
 		if self.internally_connectable is not None:
 			print "setting internal link on frontend id", self.frontend_id
-			open("/proc/stb/frontend/%d/rf_switch" % self.frontend_id, "w").write("internal")
+			open("/usr/local/e2/etc/stb/frontend/%d/rf_switch" % self.frontend_id, "w").write("internal")
 		
 	def removeInternalLink(self):
 		if self.internally_connectable is not None:
 			print "removing internal link on frontend id", self.frontend_id
-			open("/proc/stb/frontend/%d/rf_switch" % self.frontend_id, "w").write("external")
+			open("/usr/local/e2/etc/stb/frontend/%d/rf_switch" % self.frontend_id, "w").write("external")
 	
 	def isMultiType(self):
 		return (len(self.multi_type) > 0)
@@ -659,9 +659,9 @@
 #			print "TRANSPONDERS", self.transpondersterrestrial
 
 	def enumerateNIMs(self):
-		# enum available NIMs. This is currently very dreambox-centric and uses the /proc/bus/nim_sockets interface.
+		# enum available NIMs. This is currently very dreambox-centric and uses the /usr/local/e2/etc/tuxbox/nim_sockets interface.
 		# the result will be stored into nim_slots.
-		# the content of /proc/bus/nim_sockets looks like:
+		# the content of /usr/local/e2/etc/tuxbox/nim_sockets looks like:
 		# NIM Socket 0:
 		#          Type: DVB-S
 		#          Name: BCM4501 DVB-S2 NIM (internal)
@@ -682,7 +682,7 @@
 		self.nim_slots = [ ]
 
 		try:
-			nimfile = open("/proc/bus/nim_sockets")
+			nimfile = open("/usr/local/e2/etc/tuxbox/nim_sockets")
 		except IOError:
 			return
 
@@ -740,7 +740,7 @@
 			if not (entry.has_key("has_outputs")):
 				entry["has_outputs"] = True
 			if entry.has_key("frontend_device"): # check if internally connectable
-				if path.exists("/proc/stb/frontend/%d/rf_switch" % entry["frontend_device"]):
+				if path.exists("/usr/local/e2/etc/stb/frontend/%d/rf_switch" % entry["frontend_device"]):
 					entry["internally_connectable"] = entry["frontend_device"] - 1
 				else:
 					entry["internally_connectable"] = None
@@ -1353,12 +1353,12 @@
 		fe_id = configElement.fe_id
 		slot_id = configElement.slot_id
 		if nimmgr.nim_slots[slot_id].description == 'Alps BSBE2':
-			open("/proc/stb/frontend/%d/tone_amplitude" %(fe_id), "w").write(configElement.value)
+			open("/usr/local/e2/etc/stb/frontend/%d/tone_amplitude" %(fe_id), "w").write(configElement.value)
 
 	def tunerTypeChanged(nimmgr, configElement):
 		fe_id = configElement.fe_id
 
-		cur_type = int(open("/proc/stb/frontend/%d/mode" % (fe_id), "r").read())
+		cur_type = int(open("/usr/local/e2/etc/stb/frontend/%d/mode" % (fe_id), "r").read())
 		if cur_type != int(configElement.value):
 			print "tunerTypeChanged feid %d from %d to mode %d" % (fe_id, cur_type, int(configElement.value))
 
@@ -1370,7 +1370,7 @@
 
 			frontend = eDVBResourceManager.getInstance().allocateRawChannel(fe_id).getFrontend()
 			frontend.closeFrontend()
-			open("/proc/stb/frontend/%d/mode" % (fe_id), "w").write(configElement.value)
+			open("/usr/local/e2/etc/stb/frontend/%d/mode" % (fe_id), "w").write(configElement.value)
 			frontend.reopenFrontend()
 			try:
 				open("/sys/module/dvb_core/parameters/dvb_shutdown_timeout", "w").write(oldvalue)
diff -Naur enigma2.ori/lib/python/Components/Sources/CurrentService.py enigma2/lib/python/Components/Sources/CurrentService.py
--- enigma2.ori/lib/python/Components/Sources/CurrentService.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/Sources/CurrentService.py	2011-12-16 06:15:29.000000000 +0100
@@ -16,6 +16,7 @@
 				iPlayableService.evUpdatedEventInfo: self.serviceEvent,
 				iPlayableService.evCuesheetChanged: self.serviceEvent,
 				iPlayableService.evVideoSizeChanged: self.serviceEvent,
+				iPlayableService.evVideoFramerateChanged: self.serviceEvent,
 				iPlayableService.evHBBTVInfo: self.serviceEvent
 			}, with_event=True)
 		self.navcore = navcore
diff -Naur enigma2.ori/lib/python/Components/Timezones.py enigma2/lib/python/Components/Timezones.py
--- enigma2.ori/lib/python/Components/Timezones.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/Timezones.py	2011-12-16 06:15:29.000000000 +0100
@@ -25,7 +25,7 @@
 		try:
 			timezonesHandler = self.parseTimezones(self.timezones)
 			parser.setContentHandler(timezonesHandler)
-			parser.parse('/etc/timezone.xml')
+			parser.parse('/usr/local/e2/etc/tuxbox/timezone.xml')
 		except:
 			pass
 		
diff -Naur enigma2.ori/lib/python/Components/UsageConfig.py enigma2/lib/python/Components/UsageConfig.py
--- enigma2.ori/lib/python/Components/UsageConfig.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Components/UsageConfig.py	2011-12-16 06:15:29.000000000 +0100
@@ -374,6 +374,14 @@
 		("8", "4"),("9", "1,4"),("10", "2,4"),("11", "1,2,4"),
 		("12", "3,4"),("13", "1,3,4"),("14", "2,3,4"),("15", "All")])
 
+	config.pc = ConfigSubsection();
+	config.pc.default_fullscreen = ConfigYesNo(default = False)
+ 	config.pc.zoom_enable = ConfigYesNo(default = False);
+ 	config.pc.image4_3_zoom_x = ConfigNumber(default = 100)
+ 	config.pc.image4_3_zoom_y = ConfigNumber(default = 100)
+ 	config.pc.image16_9_zoom_x = ConfigNumber(default = 100)
+ 	config.pc.image16_9_zoom_y = ConfigNumber(default = 100)
+
 def updateChoices(sel, choices):
 	if choices:
 		defval = None
diff -Naur enigma2.ori/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py enigma2/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py
--- enigma2.ori/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/Plugins/SystemPlugins/SkinSelector/plugin.py	2011-12-16 06:15:29.000000000 +0100
@@ -85,7 +85,7 @@
 		for x in names:
 			if x == "skin.xml":
 				if dirname <> self.root:
-					subdir = dirname[19:]
+					subdir = path.basename(dirname)
 					self.skinlist.append(subdir)
 				else:
 					subdir = "Default Skin"
diff -Naur enigma2.ori/lib/python/Plugins/SystemPlugins/VideoEnhancement/VideoEnhancement.py enigma2/lib/python/Plugins/SystemPlugins/VideoEnhancement/VideoEnhancement.py
--- enigma2.ori/lib/python/Plugins/SystemPlugins/VideoEnhancement/VideoEnhancement.py	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/python/Plugins/SystemPlugins/VideoEnhancement/VideoEnhancement.py	2011-12-16 06:15:29.000000000 +0100
@@ -1,7 +1,7 @@
 from Components.config import config, ConfigSubsection, ConfigSlider, ConfigSelection, ConfigNothing, NoSave
 from Tools.CList import CList
 from os import path as os_path
-# The "VideoEnhancement" is the interface to /proc/stb/vmpeg/0.
+# The "VideoEnhancement" is the interface to /usr/local/e2/etc/stb/vmpeg/0.
 
 class VideoEnhancement:
 	firstRun = True
@@ -14,12 +14,12 @@
 		config.pep = ConfigSubsection()
 		config.pep.configsteps = NoSave(ConfigSelection(choices=[1, 5, 10, 25], default = 1))
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_contrast"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_contrast"):
 			def setContrast(config):
 				myval = int(config.value*256)
 				try:
 					print "--> setting contrast to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_contrast", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_contrast", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_contrast."
 
@@ -31,12 +31,12 @@
 		else:
 			config.pep.contrast = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_saturation"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_saturation"):
 			def setSaturation(config):
 				myval = int(config.value*256)
 				try:
 					print "--> setting saturation to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_saturation", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_saturation", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_saturaion."
 
@@ -48,12 +48,12 @@
 		else:
 			config.pep.saturation = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_hue"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_hue"):
 			def setHue(config):
 				myval = int(config.value*256)
 				try:
 					print "--> setting hue to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_hue", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_hue", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_hue."
 
@@ -65,12 +65,12 @@
 		else:
 			config.pep.hue = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_brightness"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_brightness"):
 			def setBrightness(config):
 				myval = int(config.value*256)
 				try:
 					print "--> setting brightness to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_brightness", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_brightness", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_brightness."
 
@@ -82,12 +82,12 @@
 		else:
 			config.pep.brightness = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_block_noise_reduction"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_block_noise_reduction"):
 			def setBlock_noise_reduction(config):
 				myval = int(config.value)
 				try:
 					print "--> setting block_noise_reduction to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_block_noise_reduction", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_block_noise_reduction", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_block_noise_reduction."
 
@@ -99,12 +99,12 @@
 		else:
 			config.pep.block_noise_reduction = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_mosquito_noise_reduction"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_mosquito_noise_reduction"):
 			def setMosquito_noise_reduction(config):
 				myval = int(config.value)
 				try:
 					print "--> setting mosquito_noise_reduction to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_mosquito_noise_reduction", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_mosquito_noise_reduction", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_mosquito_noise_reduction."
 
@@ -116,12 +116,12 @@
 		else:
 			config.pep.mosquito_noise_reduction = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_digital_contour_removal"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_digital_contour_removal"):
 			def setDigital_contour_removal(config):
 				myval = int(config.value)
 				try:
 					print "--> setting digital_contour_removal to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_digital_contour_removal", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_digital_contour_removal", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_digital_contour_removal."
 
@@ -133,11 +133,11 @@
 		else:
 			config.pep.digital_contour_removal = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_split"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_split"):
 			def setSplitMode(config):
 				try:
 					print "--> setting splitmode to:",str(config.value)
-					open("/proc/stb/vmpeg/0/pep_split", "w").write(str(config.value))
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_split", "w").write(str(config.value))
 				except IOError:
 					print "couldn't write pep_split."
 
@@ -153,12 +153,12 @@
 		else:
 			config.pep.split = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_sharpness"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_sharpness"):
 			def setSharpness(config):
 				myval = int(config.value*256)
 				try:
 					print "--> setting sharpness to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_sharpness", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_sharpness", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_sharpness."
 
@@ -170,12 +170,12 @@
 		else:
 			config.pep.sharpness = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_auto_flesh"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_auto_flesh"):
 			def setAutoflesh(config):
 				myval = int(config.value)
 				try:
 					print "--> setting auto_flesh to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_auto_flesh", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_auto_flesh", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_auto_flesh."
 
@@ -187,12 +187,12 @@
 		else:
 			config.pep.auto_flesh = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_green_boost"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_green_boost"):
 			def setGreenboost(config):
 				myval = int(config.value)
 				try:
 					print "--> setting green_boost to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_green_boost", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_green_boost", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_green_boost."
 
@@ -204,12 +204,12 @@
 		else:
 			config.pep.green_boost = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_blue_boost"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_blue_boost"):
 			def setBlueboost(config):
 				myval = int(config.value)
 				try:
 					print "--> setting blue_boost to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_blue_boost", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_blue_boost", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_blue_boost."
 
@@ -221,12 +221,12 @@
 		else:
 			config.pep.blue_boost = NoSave(ConfigNothing())
 
-		if os_path.exists("/proc/stb/vmpeg/0/pep_dynamic_contrast"):
+		if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_dynamic_contrast"):
 			def setDynamic_contrast(config):
 				myval = int(config.value)
 				try:
 					print "--> setting dynamic_contrast to: %0.8X" % myval
-					open("/proc/stb/vmpeg/0/pep_dynamic_contrast", "w").write("%0.8X" % myval)
+					open("/usr/local/e2/etc/stb/vmpeg/0/pep_dynamic_contrast", "w").write("%0.8X" % myval)
 				except IOError:
 					print "couldn't write pep_dynamic_contrast."
 
@@ -241,12 +241,12 @@
 		try:
 			x = config.av.scaler_sharpness.value
 		except KeyError:
-			if os_path.exists("/proc/stb/vmpeg/0/pep_scaler_sharpness"):
+			if os_path.exists("/usr/local/e2/etc/stb/vmpeg/0/pep_scaler_sharpness"):
 				def setScaler_sharpness(config):
 					myval = int(config.value)
 					try:
 						print "--> setting scaler_sharpness to: %0.8X" % myval
-						open("/proc/stb/vmpeg/0/pep_scaler_sharpness", "w").write("%0.8X" % myval)
+						open("/usr/local/e2/etc/stb/vmpeg/0/pep_scaler_sharpness", "w").write("%0.8X" % myval)
 					except IOError:
 						print "couldn't write pep_scaler_sharpness."
 
@@ -266,7 +266,7 @@
 	def setConfiguredValues(self):
 		try:
 			print "--> applying pep values"
-			open("/proc/stb/vmpeg/0/pep_apply", "w").write("1")
+			open("/usr/local/e2/etc/stb/vmpeg/0/pep_apply", "w").write("1")
 		except IOError:
 			print "couldn't apply pep values."
 
diff -Naur enigma2.ori/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py enigma2/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- enigma2.ori/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2011-12-16 06:15:29.000000000 +0100
@@ -1,280 +1,131 @@
-from enigma import eTimer
+from enigma import eTimer, eAVSwitch
 from Components.config import config, ConfigSelection, ConfigSubDict, ConfigYesNo
 
 from Tools.CList import CList
 from Tools.HardwareInfo import HardwareInfo
+from Components.AVSwitch import AVSwitch
 
 # The "VideoHardware" is the interface to /proc/stb/video.
 # It generates hotplug events, and gives you the list of 
 # available and preferred modes, as well as handling the currently
 # selected mode. No other strict checking is done.
 class VideoHardware:
-	rates = { } # high-level, use selectable modes.
-
-	modes = { }  # a list of (high-level) modes for a certain port.
-
-	rates["PAL"] =			{ "50Hz":		{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
-
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
-
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
-
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
-
-	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" } }
-
-	rates["1080i"] =		{ "50Hz":		{ 50: "1080i50" },
-								"60Hz":		{ 60: "1080i" },
-								"multi":	{ 50: "1080i50", 60: "1080i" } }
-
-	rates["PC"] = { 
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+	rates = {
+		"50": _("50Hz"),
+		"60": _("60Hz"),
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
-
-	widescreen_modes = set(["720p", "1080i"])
+	deinterlace_modes = {
+		"0": _("bob"),
+		"1": _("half temporal"),
+		"2": _("half temporal spatial"),
+		"3": _("temporal"),
+		"4": _("temporal spatial"),
+	}
 
 	def getOutputAspect(self):
 		ret = (16,9)
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print "current port not available in getOutputAspect!!! force 16:9"
-		else:
-			mode = config.av.videomode[port].value
-			force_widescreen = self.isWidescreenMode(port, mode)
-			is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
-			is_auto = config.av.aspect.value == "auto"
-			if is_widescreen:
-				if force_widescreen:
-					pass
-				else:
-					aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-					if aspect == "16:10":
-						ret = (16,10)
-			elif is_auto:
-				try:
-					aspect_str = open("/proc/stb/vmpeg/0/aspect", "r").read()
-					if aspect_str == "1": # 4:3
-						ret = (4,3)
-				except IOError:
-					pass
-			else:  # 4:3
-				ret = (4,3)
+
+		is_widescreen = config.av.aspect.value in ("16_9", "16_10")
+		is_auto = config.av.aspect.value == "auto"
+		if is_widescreen:
+			aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
+			if aspect == "16:10":
+				ret = (16,10)
+		elif is_auto:
+			try:
+				aspect_str = open("/usr/local/e2/stb/vmpeg/0/aspect", "r").read()
+				if aspect_str == "1": # 4:3
+					ret = (4,3)
+			except IOError:
+				pass
+		else:  # 4:3
+			ret = (4,3)
 		return ret
 
 	def __init__(self):
-		self.last_modes_preferred =  [ ]
 		self.on_hotplug = CList()
-		self.current_mode = None
-		self.current_port = None
-
-		self.readAvailableModes()
-
-		if self.modes.has_key("DVI-PC") and not self.getModeList("DVI-PC"):
-			print "remove DVI-PC because of not existing modes"
-			del self.modes["DVI-PC"]
 
 		self.createConfig()
 #		self.on_hotplug.append(self.createConfig)
 
-		self.readPreferredModes()
-
-		# take over old AVSwitch component :)
-		from Components.AVSwitch import AVSwitch
 #		config.av.colorformat.notifiers = [ ] 
 		config.av.aspectratio.notifiers = [ ]
 		config.av.tvsystem.notifiers = [ ]
-		config.av.wss.notifiers = [ ]
 		AVSwitch.getOutputAspect = self.getOutputAspect
 
 		config.av.aspect.addNotifier(self.updateAspect)
-		config.av.wss.addNotifier(self.updateAspect)
-		config.av.policy_169.addNotifier(self.updateAspect)
 		config.av.policy_43.addNotifier(self.updateAspect)
+		config.pc.image4_3_zoom_x.addNotifier(self.updateAspect)
+		config.pc.image4_3_zoom_y.addNotifier(self.updateAspect)
+		config.av.policy_169.addNotifier(self.updateAspect)
+		config.pc.image16_9_zoom_x.addNotifier(self.updateAspect)
+		config.pc.image16_9_zoom_y.addNotifier(self.updateAspect)
+
+		config.av.deinterlace    = ConfigSelection(choices = {"0": _("Off"), "1": _("On")}, default="0")
+		config.av.deinterlace_sd = ConfigSelection(choices = self.deinterlace_modes, default="4")
+		config.av.deinterlace_hd = ConfigSelection(choices = self.deinterlace_modes, default="3")
+		config.av.deinterlace.addNotifier(self.updateDeinterlace)
+		config.av.deinterlace_sd.addNotifier(self.updateDeinterlace)
+		config.av.deinterlace_hd.addNotifier(self.updateDeinterlace)
+
+		config.pc.sd_sharpness = ConfigSelection(choices = {"0": _("Off"), "1": _("On")}, default="0")
+		config.pc.sd_noise     = ConfigSelection(choices = {"0": _("Off"), "1": _("On")}, default="0")
+		config.pc.sd_sharpness.addNotifier(self.updateSDfeatures)
+		config.pc.sd_noise.addNotifier(self.updateSDfeatures)
 
 		# until we have the hotplug poll socket
 #		self.timer = eTimer()
 #		self.timer.callback.append(self.readPreferredModes)
 #		self.timer.start(1000)
 
-	def readAvailableModes(self):
-		try:
-			modes = open("/proc/stb/video/videomode_choices").read()[:-1]
-		except IOError:
-			print "couldn't read available videomodes."
-			self.modes_available = [ ]
-			return
-		self.modes_available = modes.split(' ')
-
-	def readPreferredModes(self):
-		try:
-			modes = open("/proc/stb/video/videomode_preferred").read()[:-1]
-			self.modes_preferred = modes.split(' ')
-		except IOError:
-			print "reading preferred modes failed, using all modes"
-			self.modes_preferred = self.modes_available
-
-		if self.modes_preferred != self.last_modes_preferred:
-			self.last_modes_preferred = self.modes_preferred
-			print "hotplug on dvi"
-			self.on_hotplug("DVI") # must be DVI
-
-	# check if a high-level mode with a given rate is available.
-	def isModeAvailable(self, port, mode, rate):
-		rate = self.rates[mode][rate]
-		for mode in rate.values():
-			# DVI modes must be in "modes_preferred"
-#			if port == "DVI":
-#				if mode not in self.modes_preferred and not config.av.edid_override.value:
-#					print "no, not preferred"
-#					return False
-			if mode not in self.modes_available:
-				return False
-		return True
-
-	def isWidescreenMode(self, port, mode):
-		return mode in self.widescreen_modes
-
-	def setMode(self, port, mode, rate, force = None):
-		print "setMode - port:", port, "mode:", mode, "rate:", rate
+	def setMode(self, port, rate, force = None):
+		print "setMode - port:", port, "rate:", rate
 		# we can ignore "port"
-		self.current_mode = mode
-		self.current_port = port
-		modes = self.rates[mode][rate]
-
-		mode_50 = modes.get(50)
-		mode_60 = modes.get(60)
+		mode_50 = self.rates.get(50)
+		mode_60 = self.rates.get(60)
 		if mode_50 is None or force == 60:
 			mode_50 = mode_60
 		if mode_60 is None or force == 50: 
 			mode_60 = mode_50
 
-		try:
-			open("/proc/stb/video/videomode_50hz", "w").write(mode_50)
-			open("/proc/stb/video/videomode_60hz", "w").write(mode_60)
-		except IOError:
-			try:
-				# fallback if no possibility to setup 50/60 hz mode
-				open("/proc/stb/video/videomode", "w").write(mode_50)
-			except IOError:
-				print "setting videomode failed."
-
-		try:
-			open("/etc/videomode", "w").write(mode_50) # use 50Hz mode (if available) for booting
-		except IOError:
-			print "writing initial videomode to /etc/videomode failed."
+		#try:
+		#	open("/proc/stb/video/videomode_50hz", "w").write(mode_50)
+		#	open("/proc/stb/video/videomode_60hz", "w").write(mode_60)
+		#except IOError:
+		#	try:
+		#		# fallback if no possibility to setup 50/60 hz mode
+		#		open("/proc/stb/video/videomode", "w").write(mode_50)
+		#	except IOError:
+		#		print "setting videomode failed."
+
+		#try:
+		#	open("/etc/videomode", "w").write(mode_50) # use 50Hz mode (if available) for booting
+		#except IOError:
+		#	print "writing initial videomode to /etc/videomode failed."
 
+		self.updateDeinterlace(None)
+		self.updateSDfeatures(None)
 		self.updateAspect(None)
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
-		config.av.videoport.value = port
-		config.av.videoport.save()
-		if port in config.av.videomode:
-			config.av.videomode[port].value = mode
-			config.av.videomode[port].save()
-		if mode in config.av.videorate:
-			config.av.videorate[mode].value = rate
-			config.av.videorate[mode].save()
-
-	def isPortAvailable(self, port):
-		# fixme
-		return True
-
-	def isPortUsed(self, port):
-		if port == "DVI":
-			self.readPreferredModes()
-			return len(self.modes_preferred) != 0
-		else:
-			return True
-
-	def getPortList(self):
-		return [port for port in self.modes if self.isPortAvailable(port)]
 
-	# get a list with all modes, with all rates, for a given port.
-	def getModeList(self, port):
-		print "getModeList for port", port
-		res = [ ]
-		for mode in self.modes[port]:
-			# list all rates which are completely valid
-			rates = [rate for rate in self.rates[mode] if self.isModeAvailable(port, mode, rate)]
-
-			# if at least one rate is ok, add this mode
-			if len(rates):
-				res.append( (mode, rates) )
-		return res
+		config.av.videorate.value = rate
+		config.av.videorate.save()
 
 	def createConfig(self, *args):
 		hw_type = HardwareInfo().get_device_name()
 		has_hdmi = HardwareInfo().has_hdmi()
 		lst = []
 
-		config.av.videomode = ConfigSubDict()
-		config.av.videorate = ConfigSubDict()
-
-		# create list of output ports
-		portlist = self.getPortList()
-		for port in portlist:
-			descr = port
-			if descr == 'DVI' and has_hdmi:
-				descr = 'HDMI'
-			elif descr == 'DVI-PC' and has_hdmi:
-				descr = 'HDMI-PC'
-			lst.append((port, descr))
-
-			# create list of available modes
-			modes = self.getModeList(port)
-			if len(modes):
-				config.av.videomode[port] = ConfigSelection(choices = [mode for (mode, rates) in modes])
-			for (mode, rates) in modes:
-				config.av.videorate[mode] = ConfigSelection(choices = rates)
-		config.av.videoport = ConfigSelection(choices = lst)
+		config.av.videorate = ConfigSelection(choices = self.rates)
 
 	def setConfiguredMode(self):
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print "current port not available, not setting videomode"
-			return
-
-		mode = config.av.videomode[port].value
-
-		if mode not in config.av.videorate:
-			print "current mode not available, not setting videomode"
-			return
-
-		rate = config.av.videorate[mode].value
-		self.setMode(port, mode, rate)
+		rate = config.av.videorate.value
+		self.setMode("DVI-PC", rate)
 
 	def updateAspect(self, cfgelement):
-		# determine aspect = {any,4:3,16:9,16:10}
-		# determine policy = {bestfit,letterbox,panscan,nonlinear}
-
 		# based on;
 		#   config.av.videoport.value: current video output device
 		#     Scart: 
@@ -292,45 +143,50 @@
 		#     nonlinear       use nonlinear
 		#     scale           use bestfit
 
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print "current port not available, not setting videomode"
-			return
-		mode = config.av.videomode[port].value
-
-		force_widescreen = self.isWidescreenMode(port, mode)
-
-		is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
-		is_auto = config.av.aspect.value == "auto"
-		policy2 = "policy" # use main policy
-
-		if is_widescreen:
-			if force_widescreen:
-				aspect = "16:9"
-			else:
-				aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-			policy = {"pillarbox": "panscan", "panscan": "letterbox", "nonlinear": "nonlinear", "scale": "bestfit"}[config.av.policy_43.value]
-			policy2 = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit"}[config.av.policy_169.value]
-		elif is_auto:
-			aspect = "any"
-			policy = "bestfit"
+		valstr = config.av.aspect.value
+		if valstr == "auto":
+			val = 0
+		elif valstr == "4_3":
+			val = 2
+		elif valstr == "16_9":
+			val = 3
+		elif valstr == "16_10":
+			val = 3
+		eAVSwitch.getInstance().setAspectRatio(val)
+
+		valstr = config.av.policy_43.value
+		if valstr == "zoom":
+			val = 4
+		elif valstr == "pillarbox":
+			val = 3
+		elif valstr == "panscan":
+			val = 2
+		elif valstr == "nonlinear":
+			val = 1
 		else:
-			aspect = "4:3"
-			policy = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit"}[config.av.policy_169.value]
-
-		if not config.av.wss.value:
-			wss = "auto(4:3_off)"
+			val = 0
+		eAVSwitch.getInstance().setPolicy43(val)
+		
+		valstr = config.av.policy_169.value
+		if valstr == "zoom":
+			val = 3
+		elif valstr == "letterbox":
+			val = 2
+		elif valstr == "panscan":
+			val = 1
 		else:
-			wss = "auto"
-
-		print "-> setting aspect, policy, policy2, wss", aspect, policy, policy2, wss
-		open("/proc/stb/video/aspect", "w").write(aspect)
-		open("/proc/stb/video/policy", "w").write(policy)
-		open("/proc/stb/denc/0/wss", "w").write(wss)
-		try:
-			open("/proc/stb/video/policy2", "w").write(policy2)
-		except IOError:
-			pass
+			val = 0
+		eAVSwitch.getInstance().setPolicy169(val)
+		eAVSwitch.getInstance().setZoom(int(config.pc.image4_3_zoom_x.value), int(config.pc.image4_3_zoom_y.value), int(config.pc.image16_9_zoom_x.value), int(config.pc.image16_9_zoom_y.value))
+		eAVSwitch.getInstance().updateScreen()
+
+	def updateDeinterlace(self, cfgelement):
+		print "-> update deinterlace !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
+		eAVSwitch.getInstance().setDeinterlace(int(config.av.deinterlace.value), int(config.av.deinterlace_sd.value), int(config.av.deinterlace_hd.value))
+
+	def updateSDfeatures(self, cfgelement):
+		print "-> update SD features !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
+		eAVSwitch.getInstance().setSDfeatures(int(config.pc.sd_sharpness.value), int(config.pc.sd_noise.value))
 
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
diff -Naur enigma2.ori/lib/python/Plugins/SystemPlugins/Videomode/plugin.py enigma2/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- enigma2.ori/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2011-12-16 06:15:29.000000000 +0100
@@ -19,6 +19,8 @@
 		self.hw = hw
 		self.onChangedEntry = [ ]
 
+		self.port = "DVI-PC"
+
 		# handle hotplug by re-creating setup
 		self.onShow.append(self.startHotplug)
 		self.onHide.append(self.stopHotplug)
@@ -52,47 +54,34 @@
 	def createSetup(self):
 		level = config.usage.setup_level.index
 
-		self.list = [
-			getConfigListEntry(_("Video Output"), config.av.videoport)
-		]
-
-		# if we have modes for this port:
-		if config.av.videoport.value in config.av.videomode:
-			# add mode- and rate-selection:
-			self.list.append(getConfigListEntry(_("Mode"), config.av.videomode[config.av.videoport.value]))
-			if config.av.videomode[config.av.videoport.value].value == 'PC':
-				self.list.append(getConfigListEntry(_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value]))
-			else:
-				self.list.append(getConfigListEntry(_("Refresh Rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value]))
-
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			mode = None
-		else:
-			mode = config.av.videomode[port].value
-
-		# some modes (720p, 1080i) are always widescreen. Don't let the user select something here, "auto" is not what he wants.
-		force_wide = self.hw.isWidescreenMode(port, mode)
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Refresh Rate"), config.av.videorate))
+		self.list.append(getConfigListEntry(_("Aspect Ratio"), config.av.aspect))
 
-		if not force_wide:
-			self.list.append(getConfigListEntry(_("Aspect Ratio"), config.av.aspect))
+		if config.av.aspect.value != "auto":
+			self.list.append(getConfigListEntry(_("Display 4:3 content as"), config.av.policy_43))
+			if config.av.policy_43.value == "zoom":
+				self.list.extend((
+					getConfigListEntry(_("Zoom 4:3 X"), config.pc.image4_3_zoom_x),
+					getConfigListEntry(_("Zoom 4:3 Y"), config.pc.image4_3_zoom_y)
+				))
 
-		if force_wide or config.av.aspect.value in ("16_9", "16_10"):
-			self.list.extend((
-				getConfigListEntry(_("Display 4:3 content as"), config.av.policy_43),
-				getConfigListEntry(_("Display >16:9 content as"), config.av.policy_169)
-			))
-		elif config.av.aspect.value == "4_3":
 			self.list.append(getConfigListEntry(_("Display 16:9 content as"), config.av.policy_169))
+			if config.av.policy_169.value == "zoom":
+				self.list.extend((
+					getConfigListEntry(_("Zoom 16:9 X"), config.pc.image16_9_zoom_x),
+					getConfigListEntry(_("Zoom 16:9 Y"), config.pc.image16_9_zoom_y)
+				))
+
+		self.list.append(getConfigListEntry(_("Deinterlacing"), config.av.deinterlace))
+		if config.av.deinterlace.value == "1":
+			self.list.append(getConfigListEntry(_("SD deinterlace method"), config.av.deinterlace_sd))
+			self.list.append(getConfigListEntry(_("HD deinterlace method"), config.av.deinterlace_hd))
 
-#		if config.av.videoport.value == "DVI":
-#			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
-		if config.av.videoport.value == "Scart":
-			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat))
-			if level >= 1:
-				self.list.append(getConfigListEntry(_("WSS on 4:3"), config.av.wss))
-				if SystemInfo["ScartSwitch"]:
-					self.list.append(getConfigListEntry(_("Auto scart switching"), config.av.vcrswitch))
+		self.list.append(getConfigListEntry(_("SD sharpness"), config.pc.sd_sharpness))
+		self.list.append(getConfigListEntry(_("SD noise reduction"), config.pc.sd_noise))
+
+		self.list.append(getConfigListEntry(_("Fullscreen default"), config.pc.default_fullscreen))
 
 		if level >= 1:
 			if SystemInfo["CanDownmixAC3"]:
@@ -123,25 +112,24 @@
 
 	def confirm(self, confirmed):
 		if not confirmed:
-			config.av.videoport.value = self.last_good[0]
-			config.av.videomode[self.last_good[0]].value = self.last_good[1]
-			config.av.videorate[self.last_good[1]].value = self.last_good[2]
+			config.av.videorate.value = self.last_good[2]
 			self.hw.setMode(*self.last_good)
 		else:
 			self.keySave()
 
 	def grabLastGoodMode(self):
-		port = config.av.videoport.value
-		mode = config.av.videomode[port].value
-		rate = config.av.videorate[mode].value
-		self.last_good = (port, mode, rate)
+                rate = config.av.videorate.value
+		self.last_good = (self.port, rate)
 
 	def apply(self):
-		port = config.av.videoport.value
-		mode = config.av.videomode[port].value
-		rate = config.av.videorate[mode].value
-		if (port, mode, rate) != self.last_good:
-			self.hw.setMode(port, mode, rate)
+		print "Apply"
+		rate = config.av.videorate.value
+		video_hw.updateAspect(None)
+		#deinterlace    = config.av.deinterlace.value
+		#deinterlace_sd = config.av.deinterlace_sd.value
+		#deinterlace_hd = config.av.deinterlace_hd.value
+		if (self.port, rate) != self.last_good:
+			self.hw.setMode(self.port, rate)
 			from Screens.MessageBox import MessageBox
 			self.session.openWithCallback(self.confirm, MessageBox, _("Is this videomode ok?"), MessageBox.TYPE_YESNO, timeout = 20, default = False)
 		else:
@@ -174,20 +162,18 @@
 
 	def hotplug(self, what):
 		print "hotplug detected on port '%s'" % (what)
-		port = config.av.videoport.value
-		mode = config.av.videomode[port].value
-		rate = config.av.videorate[mode].value
-
-		if not self.hw.isModeAvailable(port, mode, rate):
-			print "mode %s/%s/%s went away!" % (port, mode, rate)
-			modelist = self.hw.getModeList(port)
+		rate = config.av.videorate.value
+
+		if not self.hw.isModeAvailable(self.port, mode, rate):
+			print "mode %s/%s/%s went away!" % (self.port, mode, rate)
+			modelist = self.hw.getModeList(self.port)
 			if not len(modelist):
 				print "sorry, no other mode is available (unplug?). Doing nothing."
 				return
 			mode = modelist[0][0]
 			rate = modelist[0][1]
-			print "setting %s/%s/%s" % (port, mode, rate)
-			self.hw.setMode(port, mode, rate)
+			print "setting %s/%s/%s" % (self.port, mode, rate)
+			self.hw.setMode(self.port, mode, rate)
 
 hotplug = None
 
diff -Naur enigma2.ori/lib/python/Screens/Ci.py enigma2/lib/python/Screens/Ci.py
--- enigma2.ori/lib/python/Screens/Ci.py	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/python/Screens/Ci.py	2011-12-16 06:15:29.000000000 +0100
@@ -242,7 +242,7 @@
 		eDVBCI_UI.getInstance().ciStateChanged.get().append(self.ciStateChanged)
 		SystemInfo["CommonInterface"] = eDVBCIInterfaces.getInstance().getNumOfSlots() > 0
 		try:
-			file = open("/proc/stb/tsmux/ci0_tsclk", "r")
+			file = open("/usr/local/e2/etc/stb/tsmux/ci0_tsclk", "r")
 			file.close()
 			SystemInfo["CommonInterfaceSupportsHighBitrates"] = True
 		except:
diff -Naur enigma2.ori/lib/python/Tools/DreamboxHardware.py enigma2/lib/python/Tools/DreamboxHardware.py
--- enigma2.ori/lib/python/Tools/DreamboxHardware.py	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/python/Tools/DreamboxHardware.py	2011-12-16 06:15:29.000000000 +0100
@@ -4,7 +4,7 @@
 def getFPVersion():
 	ret = None
 	try:
-		ret = long(open("/proc/stb/fp/version", "r").read())
+		ret = long(open("/usr/local/e2/etc/stb/fp/version", "r").read())
 	except IOError:
 		try:
 			fp = open("/dev/dbox/fp0")
@@ -15,7 +15,7 @@
 
 def setFPWakeuptime(wutime):
 	try:
-		open("/proc/stb/fp/wakeup_time", "w").write(str(wutime))
+		open("/usr/local/e2/etc/stb/fp/wakeup_time", "w").write(str(wutime))
 	except IOError:
 		try:
 			fp = open("/dev/dbox/fp0")
@@ -25,7 +25,7 @@
 
 def setRTCtime(wutime):
 	try:
-		open("/proc/stb/fp/rtc", "w").write(str(wutime))
+		open("/usr/local/e2/etc/stb/fp/rtc", "w").write(str(wutime))
 	except IOError:
 		try:
 			fp = open("/dev/dbox/fp0")
@@ -36,7 +36,7 @@
 def getFPWakeuptime():
 	ret = 0
 	try:
-		ret = long(open("/proc/stb/fp/wakeup_time", "r").read())
+		ret = long(open("/usr/local/e2/etc/stb/fp/wakeup_time", "r").read())
 	except IOError:
 		try:
 			fp = open("/dev/dbox/fp0")
@@ -53,7 +53,7 @@
 		return wasTimerWakeup
 	wasTimerWakeup = False
 	try:
-		wasTimerWakeup = int(open("/proc/stb/fp/was_timer_wakeup", "r").read()) and True or False
+		wasTimerWakeup = int(open("/usr/local/e2/etc/stb/fp/was_timer_wakeup", "r").read()) and True or False
 	except:
 		try:
 			fp = open("/dev/dbox/fp0")
@@ -67,7 +67,7 @@
 
 def clearFPWasTimerWakeup():
 	try:
-		open("/proc/stb/fp/was_timer_wakeup", "w").write('0')
+		open("/usr/local/e2/etc/stb/fp/was_timer_wakeup", "w").write('0')
 	except:
 		try:
 			fp = open("/dev/dbox/fp0")
diff -Naur enigma2.ori/lib/python/Tools/HardwareInfo.py enigma2/lib/python/Tools/HardwareInfo.py
--- enigma2.ori/lib/python/Tools/HardwareInfo.py	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/python/Tools/HardwareInfo.py	2011-12-16 06:15:29.000000000 +0100
@@ -9,7 +9,7 @@
 
 		HardwareInfo.device_name = "unknown"
 		try:
-			file = open("/proc/stb/info/model", "r")
+			file = open("/usr/local/e2/etc/stb/info/model", "r")
 			HardwareInfo.device_name = file.readline().strip()
 			file.close()
 			try:
@@ -22,7 +22,7 @@
 			print "----------------"
 			print "you should upgrade to new drivers for the hardware detection to work properly"
 			print "----------------"
-			print "fallback to detect hardware via /proc/cpuinfo!!"
+			print "fallback to detect hardware via /usr/local/e2/etc/cpuinfo!!"
 			try:
 				rd = open("/proc/cpuinfo", "r").read()
 				if rd.find("Brcm4380 V4.2") != -1:
diff -Naur enigma2.ori/lib/python/enigma_python.i enigma2/lib/python/enigma_python.i
--- enigma2.ori/lib/python/enigma_python.i	2011-12-14 02:00:09.000000000 +0100
+++ enigma2/lib/python/enigma_python.i	2011-12-16 06:15:29.000000000 +0100
@@ -95,7 +95,6 @@
 #include <lib/dvb/cablescan.h>
 #include <lib/components/scan.h>
 #include <lib/components/file_eraser.h>
-#include <lib/components/tuxtxtapp.h>
 #include <lib/driver/avswitch.h>
 #include <lib/driver/hdmi_cec.h>
 #include <lib/driver/rfmod.h>
@@ -180,7 +179,6 @@
 %immutable iCryptoInfo::usedcaid;
 %immutable iCryptoInfo::decodetime;
 %immutable iCryptoInfo::usedcardid;
-%immutable eTuxtxtApp::appClosed;
 %include <lib/base/message.h>
 %include <lib/base/etpm.h>
 %include <lib/base/nconfig.h>
@@ -231,7 +229,6 @@
 %include <lib/dvb/cablescan.h>
 %include <lib/components/scan.h>
 %include <lib/components/file_eraser.h>
-%include <lib/components/tuxtxtapp.h>
 %include <lib/driver/avswitch.h>
 %include <lib/driver/hdmi_cec.h>
 %include <lib/driver/rfmod.h>
@@ -384,8 +381,8 @@
 %{
 void setEnableTtCachingOnOff(int onoff)
 {
-	eTuxtxtApp *tt = eTuxtxtApp::getInstance();
-	if (tt) tt->setEnableTtCachingOnOff(onoff);
+/*	eTuxtxtApp *tt = eTuxtxtApp::getInstance();
+	if (tt) tt->setEnableTtCachingOnOff(onoff);*/
 }
 %}
 
diff -Naur enigma2.ori/lib/service/servicedvb.cpp enigma2/lib/service/servicedvb.cpp
--- enigma2.ori/lib/service/servicedvb.cpp	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/service/servicedvb.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -976,6 +976,9 @@
 	CONNECT(m_service_handler_timeshift.serviceEvent, eDVBServicePlay::serviceEventTimeshift);
 	CONNECT(m_event_handler.m_eit_changed, eDVBServicePlay::gotNewEvent);
 	CONNECT(m_subtitle_sync_timer->timeout, eDVBServicePlay::checkSubtitleTiming);
+	m_player = 0;
+	xineLib = cXineLib::getInstance();
+	xine_connection = CONNECT(xineLib->m_event, eDVBServicePlay::video_event);
 	CONNECT(m_nownext_timer->timeout, eDVBServicePlay::updateEpgCacheNowNext);
 }
 
@@ -1004,6 +1007,9 @@
 			meta.updateMeta(m_reference.path);
 		}
 	}
+
+	xine_connection.disconnect();
+
 	delete m_subtitle_widget;
 }
 
@@ -1129,6 +1135,23 @@
 		}
 		if (!m_timeshift_active)
 			m_event((iPlayableService*)this, evUpdatedInfo);
+
+		ePtr<iDVBDemux> m_demux;
+		if (!m_service_handler.getDataDemux(m_demux))
+		{
+			printf("Start live TV!\n");
+
+			m_demux->createTSPlayer(m_player);
+			if (!m_player)
+				printf("ERROR: !m_player\n");
+			
+			m_player->setTargetFD(m_fd_dst);
+			updateTimeshiftPids();
+			m_player->start();
+
+			printf("Start live TV END\n");
+		}
+
 		break;
 	}
 	case eDVBServicePMTHandler::eventPreStart:
@@ -1239,8 +1262,15 @@
 
 RESULT eDVBServicePlay::start()
 {
+	printf("eDVBServicePlay::start\n");
 	eServiceReferenceDVB service = (eServiceReferenceDVB&)m_reference;
 
+	m_fd_dst = ::open("/tmp/ENIGMA_FIFO", O_RDWR);
+	if (m_fd_dst < 0)
+	{
+		eDebug("can't open DVR device - FIFO file (%m)");
+	}
+
 		/* in pvr mode, we only want to use one demux. in tv mode, we're using 
 		   two (one for decoding, one for data source), as we must be prepared
 		   to start recording from the data demux. */
@@ -1281,6 +1311,7 @@
 
 RESULT eDVBServicePlay::stop()
 {
+	printf("eDVBServicePlay::stop\n");
 		/* add bookmark for last play position */
 		/* m_cutlist_enabled bit 2 is the "don't remember bit" */
 	if (m_is_pvr && ((m_cutlist_enabled & 2) == 0))
@@ -1313,6 +1344,16 @@
 
 	stopTimeshift(); /* in case timeshift was enabled, remove buffer etc. */
 
+	// stop TSPlayer
+	if (m_player) {
+		m_player->stop();
+		m_player = 0;
+	}
+	if (m_fd_dst>0) {
+		printf("close(m_fd_dst)  %d\n", m_fd_dst);
+		close(m_fd_dst);
+	}
+
 	m_service_handler_timeshift.free();
 	m_service_handler.free();
 	
@@ -1482,17 +1523,20 @@
 {
 	eDebug("eDVBServicePlay::seekTo: jump %lld", to);
 	
-	if (!m_decode_demux)
+/*	if (!m_decode_demux)
 		return -1;
 
 	ePtr<iDVBPVRChannel> pvr_channel;
 	
 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
-		return -1;
+		return -1; */
 	
 	if (!m_cue)
 		return -1;
-	
+
+        xineLib = cXineLib::getInstance();
+        xineLib->SeekTo(to);
+
 	m_cue->seekTo(0, to);
 	m_dvb_subtitle_pages.clear();
 	m_subtitle_pages.clear();
@@ -1533,24 +1577,17 @@
 {
 	ePtr<iDVBPVRChannel> pvr_channel;
 	
-	if (!m_decode_demux)
-		return -1;
-	
 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
 		return -1;
 	
 	int r = 0;
 
-		/* if there is a decoder, use audio or video PTS */
-	if (m_decoder)
-	{
-		r = m_decoder->getPTS(0, pos);
-		if (r)
-			return r;
-	}
+	r = xineLib->getPTS(pos);
+	if (r)
+		return r;
 	
 		/* fixup */
-	return pvr_channel->getCurrentPosition(m_decode_demux, pos, m_decoder ? 1 : 0);
+	return pvr_channel->getCurrentPosition(m_decode_demux, pos, 1);
 }
 
 RESULT eDVBServicePlay::setTrickmode(int trick)
@@ -1719,16 +1756,19 @@
 	switch (w)
 	{
 	case sVideoHeight:
-		if (m_decoder)
-			return m_decoder->getVideoHeight();
+		//if (m_decoder)
+		//	return m_decoder->getVideoHeight();
+		return xineLib->getVideoHeight();
 		break;
 	case sVideoWidth:
-		if (m_decoder)
-			return m_decoder->getVideoWidth();
+		//if (m_decoder)
+		//	return m_decoder->getVideoWidth();
+		return xineLib->getVideoWidth();
 		break;
 	case sFrameRate:
-		if (m_decoder)
-			return m_decoder->getVideoFrameRate();
+		//if (m_decoder)
+		//	return m_decoder->getVideoFrameRate();
+		return xineLib->getVideoFrameRate();
 		break;
 	case sProgressive:
 		if (m_decoder)
@@ -1736,9 +1776,10 @@
 		break;
 	case sAspect:
 	{
-		int aspect = -1;
-		if (m_decoder)
-			aspect = m_decoder->getVideoAspect();
+		//if (m_decoder)
+		//	aspect = m_decoder->getVideoAspect();
+		int aspect = xineLib->getVideoAspect();
+
 		if (aspect == -1 && no_program_info)
 			break;
 		else if (aspect == -1 && !program.videoStreams.empty() && program.videoStreams[0].component_tag != -1)
@@ -2394,9 +2435,6 @@
 
 void eDVBServicePlay::updateTimeshiftPids()
 {
-	if (!m_record)
-		return;
-	
 	eDVBServicePMTHandler::program program;
 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
 
@@ -2439,11 +2477,17 @@
 				std::inserter(new_pids, new_pids.begin())
 				);
 
-		for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
-			m_record->addPID(*i);
+		if (m_record) {
+			for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
+				m_record->addPID(*i);
+			for (std::set<int>::iterator i(obsolete_pids.begin()); i != obsolete_pids.end(); ++i)
+				m_record->removePID(*i);
+		}
 
+		for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
+			m_player->addPID(*i);
 		for (std::set<int>::iterator i(obsolete_pids.begin()); i != obsolete_pids.end(); ++i)
-			m_record->removePID(*i);
+			m_player->removePID(*i);
 	}
 }
 
@@ -2482,7 +2526,6 @@
 	m_new_subtitle_page_connection = 0;
 	m_new_dvb_subtitle_page_connection = 0;
 	m_rds_decoder_event_connection = 0;
-	m_video_event_connection = 0;
 	m_timeshift_changed = 1;
 	m_timeshift_file_next.clear();
 
@@ -2586,39 +2629,40 @@
 
 	if (!m_decoder)
 	{
-		h.getDecodeDemux(m_decode_demux);
-		if (m_decode_demux)
-		{
-			m_decode_demux->getMPEGDecoder(m_decoder, m_is_primary);
-			if (m_decoder)
-				m_decoder->connectVideoEvent(slot(*this, &eDVBServicePlay::video_event), m_video_event_connection);
-			if (m_is_primary)
-			{
-				m_teletext_parser = new eDVBTeletextParser(m_decode_demux);
-				m_teletext_parser->connectNewStream(slot(*this, &eDVBServicePlay::newSubtitleStream), m_new_subtitle_stream_connection);
-				m_teletext_parser->connectNewPage(slot(*this, &eDVBServicePlay::newSubtitlePage), m_new_subtitle_page_connection);
-				m_subtitle_parser = new eDVBSubtitleParser(m_decode_demux);
-				m_subtitle_parser->connectNewPage(slot(*this, &eDVBServicePlay::newDVBSubtitlePage), m_new_dvb_subtitle_page_connection);
-				if (m_timeshift_changed)
+		m_decoder = new eTSMPEGDecoder(m_is_primary ? 0 : 1);
+
+		if (!m_is_pvr) {
+			h.getDecodeDemux(m_decode_demux);
+ 			if (m_decode_demux)
+  			{
+				if (m_is_primary)
 				{
-					ePyObject subs = getCachedSubtitle();
-					if (subs != Py_None)
+					m_teletext_parser = new eDVBTeletextParser(m_decode_demux);
+					m_teletext_parser->connectNewPage(slot(*this, &eDVBServicePlay::newSubtitlePage), m_new_subtitle_page_connection);
+					m_subtitle_parser = new eDVBSubtitleParser(m_decode_demux);
+					m_subtitle_parser->connectNewPage(slot(*this, &eDVBServicePlay::newDVBSubtitlePage), m_new_dvb_subtitle_page_connection);
+					if (m_timeshift_changed)
 					{
-						int type = PyInt_AsLong(PyTuple_GET_ITEM(subs, 0)),
-						    pid = PyInt_AsLong(PyTuple_GET_ITEM(subs, 1)),
-						    comp_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 2)), // ttx page
-						    anc_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 3)); // ttx magazine
-						if (type == 0) // dvb
-							m_subtitle_parser->start(pid, comp_page, anc_page);
-						else if (type == 1) // ttx
-							m_teletext_parser->setPageAndMagazine(comp_page, anc_page);
+						ePyObject subs = getCachedSubtitle();
+						if (subs != Py_None)
+						{
+							int type = PyInt_AsLong(PyTuple_GET_ITEM(subs, 0)),
+							    pid = PyInt_AsLong(PyTuple_GET_ITEM(subs, 1)),
+							    comp_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 2)), // ttx page
+							    anc_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 3)); // ttx magazine
+							if (type == 0) // dvb
+								m_subtitle_parser->start(pid, comp_page, anc_page);
+							else if (type == 1) // ttx
+								m_teletext_parser->setPageAndMagazine(comp_page, anc_page);
+						}
+						Py_DECREF(subs);
 					}
-					Py_DECREF(subs);
 				}
 			}
+
+			if (m_cue)
+				m_cue->setDecodingDemux(m_decode_demux, m_decoder);
 		}
-		if (m_cue)
-			m_cue->setDecodingDemux(m_decode_demux, m_decoder);
 		mustPlay = true;
 	}
 
@@ -2672,7 +2716,7 @@
 		else
 			m_decoder->setSyncPCR(-1);
 
-		if (m_is_primary)
+		if (m_is_primary && m_decode_demux && !m_is_pvr)
 		{
 			m_decoder->setTextPID(tpid);
 			if (m_teletext_parser) m_teletext_parser->start(program.textPid);
@@ -2692,6 +2736,7 @@
 			m_decoder->setRadioPic(radio_pic);
 		}
 
+		printf("mustPlay %d\n", mustPlay);
 		if (mustPlay)
 			m_decoder->play();
 		else
@@ -3120,8 +3165,9 @@
 	if (m_subtitle_widget)
 	{
 		pts_t pos = 0;
-		if (m_decoder)
-			m_decoder->getPTS(0, pos);
+		//if (m_decoder)
+		//	m_decoder->getPTS(0, pos);
+		xineLib->getPTS(pos);
 //		eDebug("got new subtitle page %lld %lld %d", pos, page.m_pts, page.m_have_pts);
 		if ( !page.m_have_pts && (m_is_pvr || m_timeshift_enabled))
 		{
@@ -3174,8 +3220,9 @@
 	
 		pts_t pos = 0;
 	
-		if (m_decoder)
-			m_decoder->getPTS(0, pos);
+		//if (m_decoder)
+		//	m_decoder->getPTS(0, pos);
+		xineLib->getPTS(pos);
 
 //		eDebug("%lld %lld", pos, show_time);
 		int diff = show_time - pos;
@@ -3208,8 +3255,9 @@
 	if (m_subtitle_widget)
 	{
 		pts_t pos = 0;
-		if (m_decoder)
-			m_decoder->getPTS(0, pos);
+		//if (m_decoder)
+		//	m_decoder->getPTS(0, pos);
+		xineLib->getPTS(pos);
 		eDebug("got new subtitle page %lld %lld", pos, p.m_show_time);
 		if ( abs(pos-p.m_show_time)>1800000 && (m_is_pvr || m_timeshift_enabled))
 		{
diff -Naur enigma2.ori/lib/service/servicedvb.h enigma2/lib/service/servicedvb.h
--- enigma2.ori/lib/service/servicedvb.h	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/service/servicedvb.h	2011-12-16 06:15:29.000000000 +0100
@@ -4,12 +4,15 @@
 #include <lib/service/iservice.h>
 #include <lib/dvb/idvb.h>
 
+#include <lib/dvb/dvb.h>
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/eit.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
 #include <lib/dvb/radiotext.h>
 #include <lib/base/filepush.h>
+#include <lib/gdi/xineLib.h>
+
 
 class eStaticServiceDVBInformation;
 class eStaticServiceDVBBouquetInformation;
@@ -294,10 +297,16 @@
 	ePtr<eConnection> m_rds_decoder_event_connection;
 	void rdsDecoderEvent(int);
 
-	ePtr<eConnection> m_video_event_connection;
 	void video_event(struct iTSMPEGDecoder::videoEvent);
 
 	virtual ePtr<iTsSource> createTsSource(eServiceReferenceDVB &ref);
+
+		/* Live TV */
+	ePtr<iDVBTSPlayer> m_player;
+	int m_fd_dst;
+
+	Connection xine_connection;
+	cXineLib* xineLib;
 };
 
 class eStaticServiceDVBBouquetInformation: public iStaticServiceInformation
diff -Naur enigma2.ori/lib/service/servicemp3.cpp enigma2/lib/service/servicemp3.cpp
--- enigma2.ori/lib/service/servicemp3.cpp	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/service/servicemp3.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -15,9 +15,9 @@
 
 #include <string>
 
-#include <gst/gst.h>
-#include <gst/pbutils/missing-plugins.h>
-#include <sys/stat.h>
+//#include <gst/gst.h>
+//#include <gst/pbutils/missing-plugins.h>
+//#include <sys/stat.h>
 
 #define HTTP_TIMEOUT 10
 
@@ -240,193 +240,34 @@
 eServiceMP3::eServiceMP3(eServiceReference ref)
 	:m_ref(ref), m_pump(eApp, 1)
 {
-	m_subtitle_sync_timer = eTimer::create(eApp);
-	m_streamingsrc_timeout = 0;
-	m_stream_tags = 0;
-	m_currentAudioStream = -1;
-	m_currentSubtitleStream = -1;
-	m_subtitle_widget = 0;
-	m_currentTrickRatio = 1.0;
-	m_buffer_size = 1*1024*1024;
-	m_prev_decoder_time = -1;
-	m_decoder_time_valid_state = 0;
-	m_errorInfo.missing_codec = "";
-
-	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
-	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
-	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
-
+	cXineLib *xineLib = cXineLib::getInstance();
+//xineLib->stopVideo();
 	m_state = stIdle;
 	eDebug("eServiceMP3::construct!");
 
 	const char *filename = m_ref.path.c_str();
-	const char *ext = strrchr(filename, '.');
-	if (!ext)
-		ext = filename;
-
-	m_sourceinfo.is_video = FALSE;
-	m_sourceinfo.audiotype = atUnknown;
-	if ( (strcasecmp(ext, ".mpeg") && strcasecmp(ext, ".mpg") && strcasecmp(ext, ".vob") && strcasecmp(ext, ".bin") && strcasecmp(ext, ".dat") ) == 0 )
-	{
-		m_sourceinfo.containertype = ctMPEGPS;
-		m_sourceinfo.is_video = TRUE;
-	}
-	else if ( strcasecmp(ext, ".ts") == 0 )
-	{
-		m_sourceinfo.containertype = ctMPEGTS;
-		m_sourceinfo.is_video = TRUE;
-	}
-	else if ( strcasecmp(ext, ".mkv") == 0 )
-	{
-		m_sourceinfo.containertype = ctMKV;
-		m_sourceinfo.is_video = TRUE;
-	}
-	else if ( strcasecmp(ext, ".avi") == 0 || strcasecmp(ext, ".divx") == 0)
-	{
-		m_sourceinfo.containertype = ctAVI;
-		m_sourceinfo.is_video = TRUE;
-	}
-	else if ( strcasecmp(ext, ".mp4") == 0 || strcasecmp(ext, ".mov") == 0 || strcasecmp(ext, ".m4v") == 0)
-	{
-		m_sourceinfo.containertype = ctMP4;
-		m_sourceinfo.is_video = TRUE;
-	}
-	else if ( strcasecmp(ext, ".m4a") == 0 )
-	{
-		m_sourceinfo.containertype = ctMP4;
-		m_sourceinfo.audiotype = atAAC;
-	}
-	else if ( strcasecmp(ext, ".mp3") == 0 )
-		m_sourceinfo.audiotype = atMP3;
-	else if ( (strncmp(filename, "/autofs/", 8) || strncmp(filename+strlen(filename)-13, "/track-", 7) || strcasecmp(ext, ".wav")) == 0 )
-		m_sourceinfo.containertype = ctCDA;
-	if ( strcasecmp(ext, ".dat") == 0 )
-	{
-		m_sourceinfo.containertype = ctVCD;
-		m_sourceinfo.is_video = TRUE;
-	}
-	if ( strstr(filename, "://") )
-		m_sourceinfo.is_streaming = TRUE;
-
-	gchar *uri;
-
-	if ( m_sourceinfo.is_streaming )
-	{
-		uri = g_strdup_printf ("%s", filename);
-		m_streamingsrc_timeout = eTimer::create(eApp);;
-		CONNECT(m_streamingsrc_timeout->timeout, eServiceMP3::sourceTimeout);
-
-		std::string config_str;
-		if( ePythonConfigQuery::getConfigValue("config.mediaplayer.useAlternateUserAgent", config_str) == 0 )
-		{
-			if ( config_str == "True" )
-				ePythonConfigQuery::getConfigValue("config.mediaplayer.alternateUserAgent", m_useragent);
-		}
-		if ( m_useragent.length() == 0 )
-			m_useragent = "Dream Multimedia Dreambox Enigma2 Mediaplayer";
-	}
-	else if ( m_sourceinfo.containertype == ctCDA )
-	{
-		int i_track = atoi(filename+18);
-		uri = g_strdup_printf ("cdda://%i", i_track);
-	}
-	else if ( m_sourceinfo.containertype == ctVCD )
-	{
-		int fd = open(filename,O_RDONLY);
-		char tmp[128*1024];
-		int ret = read(fd, tmp, 128*1024);
-		close(fd);
-		if ( ret == -1 ) // this is a "REAL" VCD
-			uri = g_strdup_printf ("vcd://");
-		else
-			uri = g_filename_to_uri(filename, NULL, NULL);
-	}
-	else
-
-		uri = g_filename_to_uri(filename, NULL, NULL);
-
-	eDebug("eServiceMP3::playbin2 uri=%s", uri);
-
-	m_gst_playbin = gst_element_factory_make("playbin2", "playbin");
-	if (!m_gst_playbin)
-		m_errorInfo.error_message = "failed to create GStreamer pipeline!\n";
-
-	g_object_set (G_OBJECT (m_gst_playbin), "uri", uri, NULL);
-
-	int flags = 0x47; // ( GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_NATIVE_VIDEO | GST_PLAY_FLAG_TEXT );
-	g_object_set (G_OBJECT (m_gst_playbin), "flags", flags, NULL);
-
-	g_free(uri);
-
-	GstElement *subsink = gst_element_factory_make("subsink", "subtitle_sink");
-	if (!subsink)
-		eDebug("eServiceMP3::sorry, can't play: missing gst-plugin-subsink");
-	else
-	{
-		m_subs_to_pull_handler_id = g_signal_connect (subsink, "new-buffer", G_CALLBACK (gstCBsubtitleAvail), this);
-		g_object_set (G_OBJECT (subsink), "caps", gst_caps_from_string("text/plain; text/x-plain; text/x-pango-markup; video/x-dvd-subpicture; subpicture/x-pgs"), NULL);
-		g_object_set (G_OBJECT (m_gst_playbin), "text-sink", subsink, NULL);
-		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
-	}
-
-	if ( m_gst_playbin )
-	{
-		gst_bus_set_sync_handler(gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin)), gstBusSyncHandler, this);
-		char srt_filename[strlen(filename)+1];
-		strncpy(srt_filename,filename,strlen(filename)-3);
-		srt_filename[strlen(filename)-3]='\0';
-		strcat(srt_filename, "srt");
-		struct stat buffer;
-		if (stat(srt_filename, &buffer) == 0)
-		{
-			eDebug("eServiceMP3::subtitle uri: %s", g_filename_to_uri(srt_filename, NULL, NULL));
-			g_object_set (G_OBJECT (m_gst_playbin), "suburi", g_filename_to_uri(srt_filename, NULL, NULL), NULL);
-		}
-		if ( m_sourceinfo.is_streaming )
-		{
-			g_signal_connect (G_OBJECT (m_gst_playbin), "notify::source", G_CALLBACK (gstHTTPSourceSetAgent), this);
-		}
-	} else
-	{
-		m_event((iPlayableService*)this, evUser+12);
-
-		if (m_gst_playbin)
-			gst_object_unref(GST_OBJECT(m_gst_playbin));
-
-		eDebug("eServiceMP3::sorry, can't play: %s",m_errorInfo.error_message.c_str());
-		m_gst_playbin = 0;
-	}
-
-	setBufferSize(m_buffer_size);
+//const char *ext = strrchr(filename, '.');
+	int uzunluk;
+	uzunluk=strlen(filename);
+	char myfilesrt[1000];
+	sprintf(myfilesrt,"%s",filename);
+	myfilesrt[uzunluk-4]='\0';
+	char myfile[1000];
+//xine videoFileName.avi#subtitle:subtitleFileName.srt
+	sprintf(myfile,"%s#subtitle:%s.srt",filename,myfilesrt);
+//sprintf(myfile,"%s",filename);
+	ASSERT(m_state == stIdle);
+	xineLib->FilmVideo(myfile);
+	m_state = stRunning;
+	m_event(this, evStart);
+	return ;
+ 
 }
 
 eServiceMP3::~eServiceMP3()
 {
-	// disconnect subtitle callback
-	GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
-
-	if (subsink)
-	{
-		g_signal_handler_disconnect (subsink, m_subs_to_pull_handler_id);
-		gst_object_unref(subsink);
-	}
-
-	delete m_subtitle_widget;
-
-	// disconnect sync handler callback
-	gst_bus_set_sync_handler(gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin)), NULL, NULL);
-
 	if (m_state == stRunning)
 		stop();
-
-	if (m_stream_tags)
-		gst_tag_list_free(m_stream_tags);
-	
-	if (m_gst_playbin)
-	{
-		gst_object_unref (GST_OBJECT (m_gst_playbin));
-		eDebug("eServiceMP3::destruct!");
-	}
 }
 
 DEFINE_REF(eServiceMP3);
@@ -441,15 +282,8 @@
 
 RESULT eServiceMP3::start()
 {
-	ASSERT(m_state == stIdle);
-
+//	ASSERT(m_state == stIdle);
 	m_state = stRunning;
-	if (m_gst_playbin)
-	{
-		eDebug("eServiceMP3::starting pipeline");
-		gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
-	}
-
 	m_event(this, evStart);
 
 	return 0;
@@ -468,9 +302,9 @@
 	if (m_state == stStopped)
 		return -1;
 
-	eDebug("eServiceMP3::stop %s", m_ref.path.c_str());
-	gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
 	m_state = stStopped;
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->stopVideo();
 
 	return 0;
 }
@@ -503,20 +337,22 @@
 		// iPausableService
 RESULT eServiceMP3::pause()
 {
-	if (!m_gst_playbin || m_state != stRunning)
+	if (m_state != stRunning)
 		return -1;
 
-	trickSeek(0.0);
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoPause();
 
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
-	if (!m_gst_playbin || m_state != stRunning)
+	if (m_state != stRunning)
 		return -1;
 
-	trickSeek(1.0);
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoResume();
 
 	return 0;
 }
@@ -530,141 +366,53 @@
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
-	if (!m_gst_playbin)
-		return -1;
-
 	if (m_state != stRunning)
 		return -1;
 
-	GstFormat fmt = GST_FORMAT_TIME;
-	gint64 len;
-	
-	if (!gst_element_query_duration(m_gst_playbin, &fmt, &len))
-		return -1;
-		/* len is in nanoseconds. we have 90 000 pts per second. */
-	
-	pts = len / 11111LL;
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoPosisyon();
+	pts=xineLib->Vlength*90;
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
-		/* convert pts to nanoseconds */
-	gint64 time_nanoseconds = to * 11111LL;
-	if (!gst_element_seek (m_gst_playbin, m_currentTrickRatio, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
-		GST_SEEK_TYPE_SET, time_nanoseconds,
-		GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
-	{
-		eDebug("eServiceMP3::seekTo failed");
-		return -1;
-	}
-
 	return 0;
 }
 
 RESULT eServiceMP3::seekTo(pts_t to)
 {
-	RESULT ret = -1;
-
-	if (m_gst_playbin)
-	{
-		m_subtitle_pages.clear();
-		m_prev_decoder_time = -1;
-		m_decoder_time_valid_state = 0;
-		ret = seekToImpl(to);
-	}
-
+	RESULT ret = 0;
 	return ret;
 }
 
 
-RESULT eServiceMP3::trickSeek(gdouble ratio)
+RESULT eServiceMP3::trickSeek(int ratio)
 {
-	m_currentTrickRatio = ratio;
-
-	if (!m_gst_playbin)
-		return -1;
-	if (ratio > -0.01 && ratio < 0.01)
-	{
-		gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
-		return 0;
-	}
-
-	gint64 pos;
-	pts_t pts;
-	getPlayPosition(pts);
-	pos = pts * 11111LL;
-
-	gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
-
-	if (ratio >= 0.0)
-	{
-		gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, -1);
-	}
-	else
-	{
-		/* note that most elements will not support negative speed */
-		gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, pos);
-	}
-
-	m_subtitle_pages.clear();
-	m_prev_decoder_time = -1;
-	m_decoder_time_valid_state = 0;
+	printf("----Ratio=%d\n",ratio);
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoIleriF();
+	//if (!ratio) return seekRelative(0, 0);
 	return 0;
 }
 
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
-	if (!m_gst_playbin)
-		return -1;
-
-	pts_t ppos;
-	getPlayPosition(ppos);
-	ppos += to * direction;
-	if (ppos < 0)
-		ppos = 0;
-	seekTo(ppos);
-	
+	eDebug("eDVBServicePlay::seekRelative: jump %d, %lld", direction, to);
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoGeriT(to/90*direction);
 	return 0;
 }
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
-	GstFormat fmt = GST_FORMAT_TIME;
-	gint64 pos;
-	GstElement *sink;
-	pts = 0;
-
-	if (!m_gst_playbin)
-		return -1;
 	if (m_state != stRunning)
 		return -1;
 
-	g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
-
-	if (!sink)
-		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
-
-	if (!sink)
-		return -1;
-
-	gchar *name = gst_element_get_name(sink);
-	gboolean use_get_decoder_time = strstr(name, "dvbaudiosink") || strstr(name, "dvbvideosink");
-	g_free(name);
-
-	if (use_get_decoder_time)
-		g_signal_emit_by_name(sink, "get-decoder-time", &pos);
-
-	gst_object_unref(sink);
-
-	if (!use_get_decoder_time && !gst_element_query_position(m_gst_playbin, &fmt, &pos)) {
-		eDebug("gst_element_query_position failed in getPlayPosition");
-		return -1;
-	}
-
-	/* pos is in nanoseconds. we have 90 000 pts per second. */
-	pts = pos / 11111LL;
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoPosisyon();
+	pts=xineLib->Vpos*90;
 	return 0;
 }
 
@@ -676,13 +424,10 @@
 
 RESULT eServiceMP3::isCurrentlySeekable()
 {
-	int ret = 3; /* just assume that seeking and fast/slow winding are possible */
-
-	if (!m_gst_playbin)
-		return 0;
 	if (m_state != stRunning)
 		return 0;
 
+	int ret = 3; // seeking and fast/slow winding possible
 	return ret;
 }
 
@@ -709,19 +454,26 @@
 
 int eServiceMP3::getInfo(int w)
 {
-	const gchar *tag = 0;
-
-	switch (w)
-	{
-	case sServiceref: return m_ref;
-	case sVideoHeight: return m_height;
-	case sVideoWidth: return m_width;
-	case sFrameRate: return m_framerate;
-	case sProgressive: return m_progressive;
-	case sAspect: return m_aspect;
-	case sTagTitle:
-	case sTagArtist:
-	case sTagAlbum:
+	cXineLib *xineLib = cXineLib::getInstance();
+ 	const gchar *tag = 0;
+ 
+ 	switch (w)
+ 	{
+ 	case sServiceref: return m_ref;
+ 	case sProgressive: return m_progressive;
+ 	case sAspect: return m_aspect;
+	case sVideoHeight:
+		return xineLib->getVideoHeight();
+		break;
+	case sVideoWidth:
+		return xineLib->getVideoWidth();
+		break;
+	case sFrameRate:
+		return xineLib->getVideoFrameRate();
+		break;
+ 	case sTagTitle:
+ 	case sTagArtist:
+ 	case sTagAlbum:
 	case sTagTitleSortname:
 	case sTagArtistSortname:
 	case sTagAlbumSortname:
@@ -757,39 +509,9 @@
 	case sTagReferenceLevel:
 	case sTagBeatsPerMinute:
 	case sTagImage:
-	case sTagPreviewImage:
-	case sTagAttachment:
+ 	case sTagPreviewImage:
+ 	case sTagAttachment:
 		return resIsPyObject;
-	case sTagTrackNumber:
-		tag = GST_TAG_TRACK_NUMBER;
-		break;
-	case sTagTrackCount:
-		tag = GST_TAG_TRACK_COUNT;
-		break;
-	case sTagAlbumVolumeNumber:
-		tag = GST_TAG_ALBUM_VOLUME_NUMBER;
-		break;
-	case sTagAlbumVolumeCount:
-		tag = GST_TAG_ALBUM_VOLUME_COUNT;
-		break;
-	case sTagBitrate:
-		tag = GST_TAG_BITRATE;
-		break;
-	case sTagNominalBitrate:
-		tag = GST_TAG_NOMINAL_BITRATE;
-		break;
-	case sTagMinimumBitrate:
-		tag = GST_TAG_MINIMUM_BITRATE;
-		break;
-	case sTagMaximumBitrate:
-		tag = GST_TAG_MAXIMUM_BITRATE;
-		break;
-	case sTagSerial:
-		tag = GST_TAG_SERIAL;
-		break;
-	case sTagEncoderVersion:
-		tag = GST_TAG_ENCODER_VERSION;
-		break;
 	case sTagCRC:
 		tag = "has-crc";
 		break;
@@ -799,192 +521,19 @@
 
 	if (!m_stream_tags || !tag)
 		return 0;
-	
-	guint value;
-	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
-		return (int) value;
 
 	return 0;
 }
 
 std::string eServiceMP3::getInfoString(int w)
 {
-	if ( !m_stream_tags && w < sUser && w > 26 )
-		return "";
-	const gchar *tag = 0;
-	switch (w)
-	{
-	case sTagTitle:
-		tag = GST_TAG_TITLE;
-		break;
-	case sTagArtist:
-		tag = GST_TAG_ARTIST;
-		break;
-	case sTagAlbum:
-		tag = GST_TAG_ALBUM;
-		break;
-	case sTagTitleSortname:
-		tag = GST_TAG_TITLE_SORTNAME;
-		break;
-	case sTagArtistSortname:
-		tag = GST_TAG_ARTIST_SORTNAME;
-		break;
-	case sTagAlbumSortname:
-		tag = GST_TAG_ALBUM_SORTNAME;
-		break;
-	case sTagDate:
-		GDate *date;
-		if (gst_tag_list_get_date(m_stream_tags, GST_TAG_DATE, &date))
-		{
-			gchar res[5];
- 			g_date_strftime (res, sizeof(res), "%Y-%M-%D", date); 
-			return (std::string)res;
-		}
-		break;
-	case sTagComposer:
-		tag = GST_TAG_COMPOSER;
-		break;
-	case sTagGenre:
-		tag = GST_TAG_GENRE;
-		break;
-	case sTagComment:
-		tag = GST_TAG_COMMENT;
-		break;
-	case sTagExtendedComment:
-		tag = GST_TAG_EXTENDED_COMMENT;
-		break;
-	case sTagLocation:
-		tag = GST_TAG_LOCATION;
-		break;
-	case sTagHomepage:
-		tag = GST_TAG_HOMEPAGE;
-		break;
-	case sTagDescription:
-		tag = GST_TAG_DESCRIPTION;
-		break;
-	case sTagVersion:
-		tag = GST_TAG_VERSION;
-		break;
-	case sTagISRC:
-		tag = GST_TAG_ISRC;
-		break;
-	case sTagOrganization:
-		tag = GST_TAG_ORGANIZATION;
-		break;
-	case sTagCopyright:
-		tag = GST_TAG_COPYRIGHT;
-		break;
-	case sTagCopyrightURI:
-		tag = GST_TAG_COPYRIGHT_URI;
-		break;
-	case sTagContact:
-		tag = GST_TAG_CONTACT;
-		break;
-	case sTagLicense:
-		tag = GST_TAG_LICENSE;
-		break;
-	case sTagLicenseURI:
-		tag = GST_TAG_LICENSE_URI;
-		break;
-	case sTagCodec:
-		tag = GST_TAG_CODEC;
-		break;
-	case sTagAudioCodec:
-		tag = GST_TAG_AUDIO_CODEC;
-		break;
-	case sTagVideoCodec:
-		tag = GST_TAG_VIDEO_CODEC;
-		break;
-	case sTagEncoder:
-		tag = GST_TAG_ENCODER;
-		break;
-	case sTagLanguageCode:
-		tag = GST_TAG_LANGUAGE_CODE;
-		break;
-	case sTagKeywords:
-		tag = GST_TAG_KEYWORDS;
-		break;
-	case sTagChannelMode:
-		tag = "channel-mode";
-		break;
-	case sUser+12:
-		return m_errorInfo.error_message;
-	default:
-		return "";
-	}
-	if ( !tag )
-		return "";
-	gchar *value;
-	if (m_stream_tags && gst_tag_list_get_string(m_stream_tags, tag, &value))
-	{
-		std::string res = value;
-		g_free(value);
-		return res;
-	}
 	return "";
 }
 
 PyObject *eServiceMP3::getInfoObject(int w)
 {
-	const gchar *tag = 0;
-	bool isBuffer = false;
-	switch (w)
-	{
-		case sTagTrackGain:
-			tag = GST_TAG_TRACK_GAIN;
-			break;
-		case sTagTrackPeak:
-			tag = GST_TAG_TRACK_PEAK;
-			break;
-		case sTagAlbumGain:
-			tag = GST_TAG_ALBUM_GAIN;
-			break;
-		case sTagAlbumPeak:
-			tag = GST_TAG_ALBUM_PEAK;
-			break;
-		case sTagReferenceLevel:
-			tag = GST_TAG_REFERENCE_LEVEL;
-			break;
-		case sTagBeatsPerMinute:
-			tag = GST_TAG_BEATS_PER_MINUTE;
-			break;
-		case sTagImage:
-			tag = GST_TAG_IMAGE;
-			isBuffer = true;
-			break;
-		case sTagPreviewImage:
-			tag = GST_TAG_PREVIEW_IMAGE;
-			isBuffer = true;
-			break;
-		case sTagAttachment:
-			tag = GST_TAG_ATTACHMENT;
-			isBuffer = true;
-			break;
-		default:
-			break;
-	}
-
-	if (m_stream_tags && tag)
-	{
-		if (isBuffer)
-		{
-			const GValue *gv_buffer = gst_tag_list_get_value_index(m_stream_tags, tag, 0);
-			if ( gv_buffer )
-			{
-				GstBuffer *buffer;
-				buffer = gst_value_get_buffer (gv_buffer);
-				return PyBuffer_FromMemory(GST_BUFFER_DATA(buffer), GST_BUFFER_SIZE(buffer));
-			}
-		}
-		else
-		{
-			gdouble value = 0.0;
-			gst_tag_list_get_double(m_stream_tags, tag, &value);
-			return PyFloat_FromDouble(value);
-		}
-	}
-
-	Py_RETURN_NONE;
+	return 0;
+//	Py_RETURN_NONE;
 }
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
@@ -1018,9 +567,6 @@
 
 int eServiceMP3::getCurrentTrack()
 {
-	if (m_currentAudioStream == -1)
-		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
-	return m_currentAudioStream;
 }
 
 RESULT eServiceMP3::selectTrack(unsigned int i)
@@ -1042,16 +588,6 @@
 
 int eServiceMP3::selectAudioStream(int i)
 {
-	int current_audio;
-	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
-	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
-	if ( current_audio == i )
-	{
-		eDebug ("eServiceMP3::switched to audio stream %i", current_audio);
-		m_currentAudioStream = i;
-		return 0;
-	}
-	return -1;
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1095,387 +631,10 @@
 
 subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
 {
-	subtype_t type = stUnknown;
-	GstCaps* caps = gst_pad_get_negotiated_caps(pad);
-	if (!caps && !g_codec)
-	{
-		caps = gst_pad_get_allowed_caps(pad);
-	}
-
-	if ( caps )
-	{
-		GstStructure* str = gst_caps_get_structure(caps, 0);
-		const gchar *g_type = gst_structure_get_name(str);
-		eDebug("getSubtitleType::subtitle probe caps type=%s", g_type);
-
-		if ( !strcmp(g_type, "video/x-dvd-subpicture") )
-			type = stVOB;
-		else if ( !strcmp(g_type, "text/x-pango-markup") )
-			type = stSRT;
-		else if ( !strcmp(g_type, "text/plain") )
-			type = stPlainText;
-		else if ( !strcmp(g_type, "subpicture/x-pgs") )
-			type = stPGS;
-		else
-			eDebug("getSubtitleType::unsupported subtitle caps %s (%s)", g_type, g_codec);
-	}
-	else if ( g_codec )
-	{
-		eDebug("getSubtitleType::subtitle probe codec tag=%s", g_codec);
-		if ( !strcmp(g_codec, "VOB") )
-			type = stVOB;
-		else if ( !strcmp(g_codec, "SubStation Alpha") || !strcmp(g_codec, "SSA") )
-			type = stSSA;
-		else if ( !strcmp(g_codec, "ASS") )
-			type = stASS;
-		else if ( !strcmp(g_codec, "SRT") )
-			type = stSRT;
-		else if ( !strcmp(g_codec, "UTF-8 plain text") )
-			type = stPlainText;
-		else
-			eDebug("getSubtitleType::unsupported subtitle codec %s", g_codec);
-	}
-	else
-		eDebug("getSubtitleType::unidentifiable subtitle stream!");
-
-	return type;
 }
 
 void eServiceMP3::gstBusCall(GstMessage *msg)
 {
-	if (!msg)
-		return;
-	gchar *sourceName;
-	GstObject *source;
-	source = GST_MESSAGE_SRC(msg);
-	if (!GST_IS_OBJECT(source))
-		return;
-	sourceName = gst_object_get_name(source);
-#if 0
-	gchar *string;
-	if (gst_message_get_structure(msg))
-		string = gst_structure_to_string(gst_message_get_structure(msg));
-	else
-		string = g_strdup(GST_MESSAGE_TYPE_NAME(msg));
-	eDebug("eTsRemoteSource::gst_message from %s: %s", sourceName, string);
-	g_free(string);
-#endif
-	switch (GST_MESSAGE_TYPE (msg))
-	{
-		case GST_MESSAGE_EOS:
-			m_event((iPlayableService*)this, evEOF);
-			break;
-		case GST_MESSAGE_STATE_CHANGED:
-		{
-			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
-				break;
-
-			GstState old_state, new_state;
-			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
-		
-			if(old_state == new_state)
-				break;
-	
-			eDebug("eServiceMP3::state transition %s -> %s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
-	
-			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
-	
-			switch(transition)
-			{
-				case GST_STATE_CHANGE_NULL_TO_READY:
-				{
-				}	break;
-				case GST_STATE_CHANGE_READY_TO_PAUSED:
-				{
-					GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
-					if (subsink)
-					{
-#ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
-						/* 
-						 * HACK: disable sync mode for now, gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
-						 * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
-						 * Sideeffect of using sync=false is that we receive subtitle buffers (far) ahead of their
-						 * display time.
-						 * Not too far ahead for subtitles contained in the media container.
-						 * But for external srt files, we could receive all subtitles at once.
-						 * And not just once, but after each pause/resume / skip.
-						 * So as soon as gstreamer has been fixed to keep sync in sparse streams, sync needs to be re-enabled.
-						 */
-						g_object_set (G_OBJECT (subsink), "sync", FALSE, NULL);
-#endif
-#if 0
-						/* we should not use ts-offset to sync with the decoder time, we have to do our own decoder timekeeping */
-						g_object_set (G_OBJECT (subsink), "ts-offset", -2L * GST_SECOND, NULL);
-						/* late buffers probably will not occur very often */
-						g_object_set (G_OBJECT (subsink), "max-lateness", 0L, NULL);
-						/* avoid prerolling (it might not be a good idea to preroll a sparse stream) */
-						g_object_set (G_OBJECT (subsink), "async", TRUE, NULL);
-#endif
-						eDebug("eServiceMP3::subsink properties set!");
-						gst_object_unref(subsink);
-					}
-					setAC3Delay(ac3_delay);
-					setPCMDelay(pcm_delay);
-				}	break;
-				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
-				{
-					if ( m_sourceinfo.is_streaming && m_streamingsrc_timeout )
-						m_streamingsrc_timeout->stop();
-				}	break;
-				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
-				{
-				}	break;
-				case GST_STATE_CHANGE_PAUSED_TO_READY:
-				{
-				}	break;
-				case GST_STATE_CHANGE_READY_TO_NULL:
-				{
-				}	break;
-			}
-			break;
-		}
-		case GST_MESSAGE_ERROR:
-		{
-			gchar *debug;
-			GError *err;
-			gst_message_parse_error (msg, &err, &debug);
-			g_free (debug);
-			eWarning("Gstreamer error: %s (%i) from %s", err->message, err->code, sourceName );
-			if ( err->domain == GST_STREAM_ERROR )
-			{
-				if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
-				{
-					if ( g_strrstr(sourceName, "videosink") )
-						m_event((iPlayableService*)this, evUser+11);
-					else if ( g_strrstr(sourceName, "audiosink") )
-						m_event((iPlayableService*)this, evUser+10);
-				}
-			}
-			g_error_free(err);
-			break;
-		}
-		case GST_MESSAGE_INFO:
-		{
-			gchar *debug;
-			GError *inf;
-	
-			gst_message_parse_info (msg, &inf, &debug);
-			g_free (debug);
-			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
-			{
-				if ( g_strrstr(sourceName, "videosink") )
-					m_event((iPlayableService*)this, evUser+14);
-			}
-			g_error_free(inf);
-			break;
-		}
-		case GST_MESSAGE_TAG:
-		{
-			GstTagList *tags, *result;
-			gst_message_parse_tag(msg, &tags);
-	
-			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
-			if (result)
-			{
-				if (m_stream_tags)
-					gst_tag_list_free(m_stream_tags);
-				m_stream_tags = result;
-			}
-	
-			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
-			if ( gv_image )
-			{
-				GstBuffer *buf_image;
-				buf_image = gst_value_get_buffer (gv_image);
-				int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
-				int ret = write(fd, GST_BUFFER_DATA(buf_image), GST_BUFFER_SIZE(buf_image));
-				close(fd);
-				eDebug("eServiceMP3::/tmp/.id3coverart %d bytes written ", ret);
-				m_event((iPlayableService*)this, evUser+13);
-			}
-			gst_tag_list_free(tags);
-			m_event((iPlayableService*)this, evUpdatedInfo);
-			break;
-		}
-		case GST_MESSAGE_ASYNC_DONE:
-		{
-			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
-				break;
-
-			GstTagList *tags;
-			gint i, active_idx, n_video = 0, n_audio = 0, n_text = 0;
-
-			g_object_get (m_gst_playbin, "n-video", &n_video, NULL);
-			g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
-			g_object_get (m_gst_playbin, "n-text", &n_text, NULL);
-
-			eDebug("eServiceMP3::async-done - %d video, %d audio, %d subtitle", n_video, n_audio, n_text);
-
-			if ( n_video + n_audio <= 0 )
-				stop();
-
-			active_idx = 0;
-
-			m_audioStreams.clear();
-			m_subtitleStreams.clear();
-
-			for (i = 0; i < n_audio; i++)
-			{
-				audioStream audio;
-				gchar *g_codec, *g_lang;
-				GstPad* pad = 0;
-				g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
-				GstCaps* caps = gst_pad_get_negotiated_caps(pad);
-				if (!caps)
-					continue;
-				GstStructure* str = gst_caps_get_structure(caps, 0);
-				const gchar *g_type = gst_structure_get_name(str);
-				eDebug("AUDIO STRUCT=%s", g_type);
-				audio.type = gstCheckAudioPad(str);
-				g_codec = g_strdup(g_type);
-				g_lang = g_strdup_printf ("und");
-				g_signal_emit_by_name (m_gst_playbin, "get-audio-tags", i, &tags);
-				if ( tags && gst_is_tag_list(tags) )
-				{
-					gst_tag_list_get_string(tags, GST_TAG_AUDIO_CODEC, &g_codec);
-					gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
-					gst_tag_list_free(tags);
-				}
-				audio.language_code = std::string(g_lang);
-				audio.codec = std::string(g_codec);
-				eDebug("eServiceMP3::audio stream=%i codec=%s language=%s", i, g_codec, g_lang);
-				m_audioStreams.push_back(audio);
-				g_free (g_lang);
-				g_free (g_codec);
-				gst_caps_unref(caps);
-			}
-
-			for (i = 0; i < n_text; i++)
-			{	
-				gchar *g_codec = NULL, *g_lang = NULL;
-				g_signal_emit_by_name (m_gst_playbin, "get-text-tags", i, &tags);
-				subtitleStream subs;
-
-				g_lang = g_strdup_printf ("und");
-				if ( tags && gst_is_tag_list(tags) )
-				{
-					gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
-					gst_tag_list_get_string(tags, GST_TAG_SUBTITLE_CODEC, &g_codec);
-					gst_tag_list_free(tags);
-				}
-
-				subs.language_code = std::string(g_lang);
-				eDebug("eServiceMP3::subtitle stream=%i language=%s codec=%s", i, g_lang, g_codec);
-				
-				GstPad* pad = 0;
-				g_signal_emit_by_name (m_gst_playbin, "get-text-pad", i, &pad);
-				if ( pad )
-					g_signal_connect (G_OBJECT (pad), "notify::caps", G_CALLBACK (gstTextpadHasCAPS), this);
-				subs.type = getSubtitleType(pad, g_codec);
-
-				m_subtitleStreams.push_back(subs);
-				g_free (g_lang);
-			}
-			m_event((iPlayableService*)this, evUpdatedInfo);
-
-			if ( m_errorInfo.missing_codec != "" )
-			{
-				if ( m_errorInfo.missing_codec.find("video/") == 0 || ( m_errorInfo.missing_codec.find("audio/") == 0 && getNumberOfTracks() == 0 ) )
-					m_event((iPlayableService*)this, evUser+12);
-			}
-			break;
-		}
-		case GST_MESSAGE_ELEMENT:
-		{
-			if (const GstStructure *msgstruct = gst_message_get_structure(msg))
-			{
-				if ( gst_is_missing_plugin_message(msg) )
-				{
-					GstCaps *caps;
-					gst_structure_get (msgstruct, "detail", GST_TYPE_CAPS, &caps, NULL); 
-					std::string codec = (const char*) gst_caps_to_string(caps);
-					gchar *description = gst_missing_plugin_message_get_description(msg);
-					if ( description )
-					{
-						eDebug("eServiceMP3::m_errorInfo.missing_codec = %s", codec.c_str());
-						m_errorInfo.error_message = "GStreamer plugin " + (std::string)description + " not available!\n";
-						m_errorInfo.missing_codec = codec.substr(0,(codec.find_first_of(',')));
-						g_free(description);
-					}
-					gst_caps_unref(caps);
-				}
-				else
-				{
-					const gchar *eventname = gst_structure_get_name(msgstruct);
-					if ( eventname )
-					{
-						if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
-						{
-							gst_structure_get_int (msgstruct, "aspect_ratio", &m_aspect);
-							gst_structure_get_int (msgstruct, "width", &m_width);
-							gst_structure_get_int (msgstruct, "height", &m_height);
-							if (strstr(eventname, "Changed"))
-								m_event((iPlayableService*)this, evVideoSizeChanged);
-						}
-						else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
-						{
-							gst_structure_get_int (msgstruct, "frame_rate", &m_framerate);
-							if (strstr(eventname, "Changed"))
-								m_event((iPlayableService*)this, evVideoFramerateChanged);
-						}
-						else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
-						{
-							gst_structure_get_int (msgstruct, "progressive", &m_progressive);
-							if (strstr(eventname, "Changed"))
-								m_event((iPlayableService*)this, evVideoProgressiveChanged);
-						}
-					}
-				}
-			}
-			break;
-		}
-		case GST_MESSAGE_BUFFERING:
-		{
-			GstBufferingMode mode;
-			gst_message_parse_buffering(msg, &(m_bufferInfo.bufferPercent));
-			gst_message_parse_buffering_stats(msg, &mode, &(m_bufferInfo.avgInRate), &(m_bufferInfo.avgOutRate), &(m_bufferInfo.bufferingLeft));
-			m_event((iPlayableService*)this, evBuffering);
-			break;
-		}
-		case GST_MESSAGE_STREAM_STATUS:
-		{
-			GstStreamStatusType type;
-			GstElement *owner;
-			gst_message_parse_stream_status (msg, &type, &owner);
-			if ( type == GST_STREAM_STATUS_TYPE_CREATE && m_sourceinfo.is_streaming )
-			{
-				if ( GST_IS_PAD(source) )
-					owner = gst_pad_get_parent_element(GST_PAD(source));
-				else if ( GST_IS_ELEMENT(source) )
-					owner = GST_ELEMENT(source);
-				else
-					owner = 0;
-				if ( owner )
-				{
-					GstElementFactory *factory = gst_element_get_factory(GST_ELEMENT(owner));
-					const gchar *name = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(factory));
-					if (!strcmp(name, "souphttpsrc"))
-					{
-						m_streamingsrc_timeout->start(HTTP_TIMEOUT*1000, true);
-						g_object_set (G_OBJECT (owner), "timeout", HTTP_TIMEOUT, NULL);
-						eDebug("eServiceMP3::GST_STREAM_STATUS_TYPE_CREATE -> setting timeout on %s to %is", name, HTTP_TIMEOUT);
-					}
-					
-				}
-				if ( GST_IS_PAD(source) )
-					gst_object_unref(owner);
-			}
-			break;
-		}
-		default:
-			break;
-	}
-	g_free (sourceName);
 }
 
 void eServiceMP3::handleMessage(GstMessage *msg)
@@ -1494,298 +653,45 @@
 
 GstBusSyncReply eServiceMP3::gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data)
 {
-	eServiceMP3 *_this = (eServiceMP3*)user_data;
-	if (_this) _this->handleMessage(message);
-	return GST_BUS_DROP;
 }
 
 void eServiceMP3::gstHTTPSourceSetAgent(GObject *object, GParamSpec *unused, gpointer user_data)
 {
-	eServiceMP3 *_this = (eServiceMP3*)user_data;
-	GstElement *source;
-	g_object_get(_this->m_gst_playbin, "source", &source, NULL);
-	g_object_set (G_OBJECT (source), "user-agent", _this->m_useragent.c_str(), NULL);
-	gst_object_unref(source);
 }
 
 audiotype_t eServiceMP3::gstCheckAudioPad(GstStructure* structure)
 {
-	if (!structure)
-		return atUnknown;
-
-	if ( gst_structure_has_name (structure, "audio/mpeg"))
-	{
-		gint mpegversion, layer = -1;
-		if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
-			return atUnknown;
-
-		switch (mpegversion) {
-			case 1:
-				{
-					gst_structure_get_int (structure, "layer", &layer);
-					if ( layer == 3 )
-						return atMP3;
-					else
-						return atMPEG;
-					break;
-				}
-			case 2:
-				return atAAC;
-			case 4:
-				return atAAC;
-			default:
-				return atUnknown;
-		}
-	}
-
-	else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
-		return atAC3;
-	else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
-		return atDTS;
-	else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
-		return atPCM;
-
-	return atUnknown;
 }
 
+
 void eServiceMP3::gstPoll(ePtr<GstMessageContainer> const &msg)
 {
-	switch (msg->getType())
-	{
-		case 1:
-		{
-			GstMessage *gstmessage = *((GstMessageContainer*)msg);
-			if (gstmessage)
-			{
-				gstBusCall(gstmessage);
-			}
-			break;
-		}
-		case 2:
-		{
-			GstBuffer *buffer = *((GstMessageContainer*)msg);
-			if (buffer)
-			{
-				pullSubtitle(buffer);
-			}
-			break;
-		}
-		case 3:
-		{
-			GstPad *pad = *((GstMessageContainer*)msg);
-			gstTextpadHasCAPS_synced(pad);
-			break;
-		}
-	}
 }
 
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
 
 void eServiceMP3::gstCBsubtitleAvail(GstElement *subsink, GstBuffer *buffer, gpointer user_data)
 {
-	eServiceMP3 *_this = (eServiceMP3*)user_data;
-	if (_this->m_currentSubtitleStream < 0) 
-	{
-		if (buffer) gst_buffer_unref(buffer);
-		return;
-	}
-	eDebug("gstCBsubtitleAvail: %s", GST_BUFFER_DATA(buffer));
-	_this->m_pump.send(new GstMessageContainer(2, NULL, NULL, buffer));
 }
 
 void eServiceMP3::gstTextpadHasCAPS(GstPad *pad, GParamSpec * unused, gpointer user_data)
 {
-	eServiceMP3 *_this = (eServiceMP3*)user_data;
-
-	gst_object_ref (pad);
-
-	_this->m_pump.send(new GstMessageContainer(3, NULL, pad, NULL));
 }
 
 void eServiceMP3::gstTextpadHasCAPS_synced(GstPad *pad)
 {
-	GstCaps *caps;
-
-	g_object_get (G_OBJECT (pad), "caps", &caps, NULL);
-
-	eDebug("gstTextpadHasCAPS:: signal::caps = %s", gst_caps_to_string(caps));
-
-	if (caps)
-	{
-		subtitleStream subs;
-
-//		eDebug("gstGhostpadHasCAPS_synced %p %d", pad, m_subtitleStreams.size());
-
-		if (m_currentSubtitleStream >= 0 && m_currentSubtitleStream < m_subtitleStreams.size())
-			subs = m_subtitleStreams[m_currentSubtitleStream];
-		else {
-			subs.type = stUnknown;
-			subs.pad = pad;
-		}
-
-		if ( subs.type == stUnknown )
-		{
-			GstTagList *tags;
-//			eDebug("gstGhostpadHasCAPS::m_subtitleStreams[%i].type == stUnknown...", m_currentSubtitleStream);
-
-			gchar *g_lang;
-			g_signal_emit_by_name (m_gst_playbin, "get-text-tags", m_currentSubtitleStream, &tags);
-
-			g_lang = g_strdup_printf ("und");
-			if ( tags && gst_is_tag_list(tags) )
-				gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
-
-			subs.language_code = std::string(g_lang);
-			subs.type = getSubtitleType(pad);
-
-			if (m_currentSubtitleStream >= 0 && m_currentSubtitleStream < m_subtitleStreams.size())
-				m_subtitleStreams[m_currentSubtitleStream] = subs;
-			else
-				m_subtitleStreams.push_back(subs);
-
-			g_free (g_lang);
-		}
-
-//		eDebug("gstGhostpadHasCAPS:: m_gst_prev_subtitle_caps=%s equal=%i",gst_caps_to_string(m_gst_prev_subtitle_caps),gst_caps_is_equal(m_gst_prev_subtitle_caps, caps));
-
-		gst_caps_unref (caps);
-	}
 }
 
 void eServiceMP3::pullSubtitle(GstBuffer *buffer)
 {
-	if (buffer && m_currentSubtitleStream >= 0 && m_currentSubtitleStream < m_subtitleStreams.size())
-	{
-		gint64 buf_pos = GST_BUFFER_TIMESTAMP(buffer);
-		gint64 duration_ns = GST_BUFFER_DURATION(buffer);
-		size_t len = GST_BUFFER_SIZE(buffer);
-		eDebug("pullSubtitle m_subtitleStreams[m_currentSubtitleStream].type=%i",m_subtitleStreams[m_currentSubtitleStream].type);
-
-		if ( m_subtitleStreams[m_currentSubtitleStream].type )
-		{
-			if ( m_subtitleStreams[m_currentSubtitleStream].type < stVOB )
-			{
-				unsigned char line[len+1];
-				SubtitlePage page;
-				memcpy(line, GST_BUFFER_DATA(buffer), len);
-				line[len] = 0;
-				eDebug("got new text subtitle @ buf_pos = %lld ns (in pts=%lld): '%s' ", buf_pos, buf_pos/11111, line);
-				gRGB rgbcol(0xD0,0xD0,0xD0);
-				page.type = SubtitlePage::Pango;
-				page.pango_page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)line));
-				page.pango_page.m_show_pts = buf_pos / 11111L;
-				page.pango_page.m_timeout = duration_ns / 1000000;
-				m_subtitle_pages.push_back(page);
-				if (m_subtitle_pages.size()==1)
-					pushSubtitles();
-			}
-			else
-			{
-				eDebug("unsupported subpicture... ignoring");
-			}
-		}
-	}
 }
 
 void eServiceMP3::pushSubtitles()
 {
-	while ( !m_subtitle_pages.empty() )
-	{
-		SubtitlePage &frontpage = m_subtitle_pages.front();
-		pts_t running_pts;
-		gint64 diff_ms = 0;
-		gint64 show_pts = 0;
-
-		getPlayPosition(running_pts);
-		if (m_decoder_time_valid_state < 4) {
-			++m_decoder_time_valid_state;
-			if (m_prev_decoder_time == running_pts)
-				m_decoder_time_valid_state = 0;
-			if (m_decoder_time_valid_state < 4) {
-				m_subtitle_sync_timer->start(50, true);
-				m_prev_decoder_time = running_pts;
-				break;
-			}
-		}
-
-		if (frontpage.type == SubtitlePage::Pango)
-			show_pts = frontpage.pango_page.m_show_pts;
-
-		diff_ms = ( show_pts - running_pts ) / 90;
-		eDebug("check subtitle: decoder: %lld, show_pts: %lld, diff: %lld ms", running_pts/90, show_pts/90, diff_ms);
-
-		if ( diff_ms < -100 )
-		{
-			eDebug("subtitle too late... drop");
-			m_subtitle_pages.pop_front();
-		}
-		else if ( diff_ms > 20 )
-		{
-			eDebug("start timer, %lldms", diff_ms);
-			m_subtitle_sync_timer->start(diff_ms, true);
-			break;
-		}
-		else // immediate show
-		{
-			if ( m_subtitle_widget )
-			{
-				eDebug("show!\n");
-				if ( frontpage.type == SubtitlePage::Pango)
-					m_subtitle_widget->setPage(frontpage.pango_page);
-				m_subtitle_widget->show();
-			}
-			m_subtitle_pages.pop_front();
-		}
-	}
 }
 
 RESULT eServiceMP3::enableSubtitles(eWidget *parent, ePyObject tuple)
 {
-	ePyObject entry;
-	int tuplesize = PyTuple_Size(tuple);
-	int pid;
-
-	if (!PyTuple_Check(tuple))
-		goto error_out;
-	if (tuplesize < 1)
-		goto error_out;
-	entry = PyTuple_GET_ITEM(tuple, 1);
-	if (!PyInt_Check(entry))
-		goto error_out;
-	pid = PyInt_AsLong(entry);
-
-	if (m_currentSubtitleStream != pid)
-	{
-		g_object_set (G_OBJECT (m_gst_playbin), "current-text", -1, NULL);
-		m_subtitle_pages.clear();
-		m_prev_decoder_time = -1;
-		m_decoder_time_valid_state = 0;
-		m_currentSubtitleStream = pid;
-		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
-
-		m_subtitle_widget = 0;
-		m_subtitle_widget = new eSubtitleWidget(parent);
-		m_subtitle_widget->resize(parent->size()); /* full size */
-
-		eDebug ("eServiceMP3::switched to subtitle stream %i", m_currentSubtitleStream);
-
-		m_event((iPlayableService*)this, evUpdatedInfo);
-
-#ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
-		/* 
-		 * when we're running the subsink in sync=false mode, 
-		 * we have to force a seek, before the new subtitle stream will start
-		 */
-		seekRelative(-1, 90000);
-#endif
-	}
-
-	return 0;
-
-error_out:
-	eDebug("eServiceMP3::enableSubtitles needs a tuple as 2nd argument!\n"
-		"for gst subtitles (2, subtitle_stream_count, subtitle_type)");
-	return -1;
 }
 
 RESULT eServiceMP3::disableSubtitles(eWidget *parent)
@@ -1877,82 +783,9 @@
 
 void eServiceMP3::setAC3Delay(int delay)
 {
-	ac3_delay = delay;
-	if (!m_gst_playbin || m_state != stRunning)
-		return;
-	else
-	{
-		GstElement *sink;
-		int config_delay_int = delay;
-		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
-
-		if (sink)
-		{
-			std::string config_delay;
-			if(ePythonConfigQuery::getConfigValue("config.av.generalAC3delay", config_delay) == 0)
-				config_delay_int += atoi(config_delay.c_str());
-			gst_object_unref(sink);
-		}
-		else
-		{
-			eDebug("dont apply ac3 delay when no video is running!");
-			config_delay_int = 0;
-		}
-
-		g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
-
-		if (sink)
-		{
-			gchar *name = gst_element_get_name(sink);
-			if (strstr(name, "dvbaudiosink"))
-				eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
-			g_free(name);
-			gst_object_unref(sink);
-		}
-	}
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
-	pcm_delay = delay;
-	if (!m_gst_playbin || m_state != stRunning)
-		return;
-	else
-	{
-		GstElement *sink;
-		int config_delay_int = delay;
-		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
-
-		if (sink)
-		{
-			std::string config_delay;
-			if(ePythonConfigQuery::getConfigValue("config.av.generalPCMdelay", config_delay) == 0)
-				config_delay_int += atoi(config_delay.c_str());
-			gst_object_unref(sink);
-		}
-		else
-		{
-			eDebug("dont apply pcm delay when no video is running!");
-			config_delay_int = 0;
-		}
-
-		g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
-
-		if (sink)
-		{
-			gchar *name = gst_element_get_name(sink);
-			if (strstr(name, "dvbaudiosink"))
-				eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
-			else
-			{
-				// this is realy untested..and not used yet
-				gint64 offset = config_delay_int;
-				offset *= 1000000; // milli to nano
-				g_object_set (G_OBJECT (m_gst_playbin), "ts-offset", offset, NULL);
-			}
-			g_free(name);
-			gst_object_unref(sink);
-		}
-	}
 }
 
diff -Naur enigma2.ori/lib/service/servicemp3.h enigma2/lib/service/servicemp3.h
--- enigma2.ori/lib/service/servicemp3.h	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/lib/service/servicemp3.h	2011-12-16 06:15:29.000000000 +0100
@@ -269,7 +269,7 @@
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
 	std::string m_useragent;
-	RESULT trickSeek(gdouble ratio);
+	RESULT trickSeek(int ratio);
 };
 
 #endif
diff -Naur enigma2.ori/main/Makefile.am enigma2/main/Makefile.am
--- enigma2.ori/main/Makefile.am	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/main/Makefile.am	2011-12-16 06:15:29.000000000 +0100
@@ -50,8 +50,10 @@
 	@LIBXMLCCWRAP_LIBS@ \
 	@PTHREAD_LIBS@ \
 	@PYTHON_LDFLAGS@ \
+	@PYTHON_LDFLAGS@ \
+	@X11_LIBS@ \
 	@LIBDDVD_LIBS@ \
-	-ltuxtxt32bpp -lcrypt
+	-lcrypt -lnl -lnl-genl -ldvbcsa
 
 enigma2_LDFLAGS = -Wl,--export-dynamic
 
diff -Naur enigma2.ori/main/bsod.cpp enigma2/main/bsod.cpp
--- enigma2.ori/main/bsod.cpp	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/main/bsod.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -192,28 +192,17 @@
 		xml.stringFromFile("dreamboxmodel", "/proc/stb/info/model");
 		xml.stringFromFile("kernelcmdline", "/proc/cmdline");
 		xml.stringFromFile("nimsockets", "/proc/bus/nim_sockets");
-		if (!getConfigBool("config.plugins.crashlogautosubmit.sendAnonCrashlog", true)) {
-			xml.cDataFromFile("dreamboxca", "/proc/stb/info/ca");
-			xml.cDataFromFile("enigma2settings", eEnv::resolve("${sysconfdir}/enigma2/settings"), ".password=");
-		}
-		if (getConfigBool("config.plugins.crashlogautosubmit.addNetwork", false)) {
-			xml.cDataFromFile("networkinterfaces", "/etc/network/interfaces");
-			xml.cDataFromFile("dns", "/etc/resolv.conf");
-			xml.cDataFromFile("defaultgateway", "/etc/default_gw");
-		}
-		if (getConfigBool("config.plugins.crashlogautosubmit.addWlan", false))
-			xml.cDataFromFile("wpasupplicant", "/etc/wpa_supplicant.conf");
 		xml.cDataFromFile("imageversion", "/etc/image-version");
 		xml.cDataFromFile("imageissue", "/etc/issue.net");
 		xml.close();
 
 		if (detailedCrash)
 		{
-			xml.open("software");
-			xml.cDataFromCmd("enigma2software", "opkg list_installed 'enigma2*'");
-			xml.cDataFromCmd("dreamboxsoftware", "opkg list_installed 'dream*'");
-			xml.cDataFromCmd("gstreamersoftware", "opkg list_installed 'gst*'");
-			xml.close();
+		//xml.open("software");
+		//xml.cDataFromCmd("enigma2software", "opkg list_installed | grep enigma2");
+		//xml.cDataFromCmd("dreamboxsoftware", "opkg list_installed | grep dream");
+		//xml.cDataFromCmd("gstreamersoftware", "opkg list_installed | grep gst");
+		//xml.close();
 		}
 
 		xml.open("crashlogs");
diff -Naur enigma2.ori/main/enigma.cpp enigma2/main/enigma.cpp
--- enigma2.ori/main/enigma.cpp	2011-12-14 02:00:10.000000000 +0100
+++ enigma2/main/enigma.cpp	2011-12-16 06:15:29.000000000 +0100
@@ -231,7 +231,8 @@
 	python.execFile(eEnv::resolve("${libdir}/enigma2/python/mytest.py").c_str());
 
 	/* restore both decoders to full size */
-	eVideoWidget::setFullsize();
+	extern void setFullsize();
+	setFullsize();
 
 	if (exit_code == 5) /* python crash */
 	{
